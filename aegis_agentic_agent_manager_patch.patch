*** Begin Patch
*** Add File:agent-manager/crds/agent.crd.yaml
+apiVersion: apiextensions.k8s.io/v1
+kind: CustomResourceDefinition
+metadata:
+  name: agents.aegis.example.com
+spec:
+  group: aegis.example.com
+  names:
+    kind: Agent
+    plural: agents
+    singular: agent
+    shortNames:
+    - ag
+  scope: Namespaced
+  versions:
+  - name: v1
+    served: true
+    storage: true
+    schema:
+      openAPIV3Schema:
+        type: object
+        properties:
+          spec:
+            type: object
+            properties:
+              displayName:
+                type: string
+              image:
+                type: string
+              replicas:
+                type: integer
+              tools:
+                type: array
+                items:
+                  type: object
+                  properties:
+                    name:
+                      type: string
+                    kind:
+                      type: string
+                    image:
+                      type: string
+                    allowNetwork:
+                      type: boolean
+              memory:
+                type: object
+                properties:
+                  backend:
+                    type: string
+                  bucket:
+                    type: string
+              policyRef:
+                type: string
+          status:
+            type: object
+            properties:
+              state:
+                type: string
+              message:
+                type: string
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/README.md
+Agent Manager controller
+========================
+
+This folder contains a simple controller that reconciles Agent CRs and deploys agent workloads
+with a secure sandbox pattern (tool-runner sidecar, restricted pod security context, and network policy).
+
+Components:
+- controller/main.py : simple Python controller (watcher + reconciler)
+- k8s manifests: serviceaccount, role, rolebinding, deployment
+- example Agent manifest: agent-sample.yaml
+
+Notes:
+- This is a scaffold to be extended into a production controller (use a proper operator framework like Kopf or controller-runtime for production).
+- The controller enforces safety checks by consulting the OPA policy service before creating/patching agent workloads.
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/serviceaccount.yaml
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: aegis-agent-controller
+  namespace: ops
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/role.yaml
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: aegis-agent-controller
+rules:
+- apiGroups: ["aegis.example.com"]
+  resources: ["agents"]
+  verbs: ["get","list","watch","create","update","patch","delete"]
+- apiGroups: [""]
+  resources: ["pods","deployments","services","configmaps","secrets","networkpolicies"]
+  verbs: ["get","list","watch","create","update","patch","delete"]
+- apiGroups: ["apps"]
+  resources: ["deployments"]
+  verbs: ["get","list","watch","create","update","patch","delete"]
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/rolebinding.yaml
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: aegis-agent-controller-binding
+subjects:
+- kind: ServiceAccount
+  name: aegis-agent-controller
+  namespace: ops
+roleRef:
+  kind: ClusterRole
+  name: aegis-agent-controller
+  apiGroup: rbac.authorization.k8s.io
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-agent-controller
+  namespace: ops
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: aegis-agent-controller
+  template:
+    metadata:
+      labels:
+        app: aegis-agent-controller
+    spec:
+      serviceAccountName: aegis-agent-controller
+      containers:
+      - name: controller
+        image: aegis/agent-controller:latest   # replace with built image
+        command: ["python","/app/main.py"]
+        env:
+        - name: NAMESPACE
+          valueFrom:
+            fieldRef:
+              fieldPath: metadata.namespace
+        resources:
+          limits:
+            cpu: "500m"
+            memory: "512Mi"
+          requests:
+            cpu: "100m"
+            memory: "128Mi"
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/main.py
+#!/usr/bin/env python3
+"""
+Simple reconciler for Agent CR that creates a Deployment per Agent.
+This is a minimal example — for production use an operator framework (Kopf/controller-runtime).
+"""
+import os
+import time
+import json
+from kubernetes import client, config, watch
+import requests
+
+NAMESPACE = os.environ.get("NAMESPACE", "default")
+OPA_URL = os.environ.get("OPA_URL", "http://opa.opa.svc.cluster.local:8181/v1/data/agent/policy/allow")
+
+def load_kube():
+    try:
+        config.load_incluster_config()
+    except Exception:
+        config.load_kube_config()
+
+def opa_check(agent_spec):
+    # Query OPA policy with the agent_spec (returns True/False)
+    try:
+        resp = requests.post(OPA_URL, json={"input": agent_spec}, timeout=5)
+        if resp.status_code == 200:
+            result = resp.json().get("result", {})
+            return result.get("allow", False), result.get("reason", "")
+    except Exception as e:
+        print("OPA check failed:", e)
+    return False, "OPA unreachable or error"
+
+def deploy_agent(api, name, spec):
+    dep_name = f"agent-{name}"
+    image = spec.get("image", "python:3.10-slim")
+    replicas = int(spec.get("replicas", 1))
+    tools = spec.get("tools", [])
+
+    # Build container specs: runtime + tool-runner sidecar
+    runtime = client.V1Container(
+        name="agent-runtime",
+        image=image,
+        security_context=client.V1SecurityContext(
+            run_as_non_root=True,
+            read_only_root_filesystem=True,
+            allow_privilege_escalation=False
+        ),
+        resources=client.V1ResourceRequirements(
+            limits={"cpu":"1000m","memory":"1Gi"},
+            requests={"cpu":"200m","memory":"256Mi"}
+        )
+    )
+    tool_runner = client.V1Container(
+        name="tool-runner",
+        image="aegis/tool-runner:latest",
+        args=["--listen","0.0.0.0:8081"],
+        security_context=client.V1SecurityContext(
+            run_as_non_root=True,
+            read_only_root_filesystem=True,
+            allow_privilege_escalation=False
+        ),
+        resources=client.V1ResourceRequirements(
+            limits={"cpu":"500m","memory":"512Mi"},
+            requests={"cpu":"100m","memory":"128Mi"}
+        )
+    )
+
+    pod_spec = client.V1PodSpec(containers=[runtime, tool_runner], restart_policy="Always")
+    template = client.V1PodTemplateSpec(metadata=client.V1ObjectMeta(labels={"agent": name}), spec=pod_spec)
+    spec = client.V1DeploymentSpec(replicas=replicas, template=template, selector=client.V1LabelSelector(match_labels={"agent": name}))
+    body = client.V1Deployment(metadata=client.V1ObjectMeta(name=dep_name, namespace=NAMESPACE), spec=spec)
+
+    apps = client.AppsV1Api()
+    try:
+        existing = apps.read_namespaced_deployment(dep_name, NAMESPACE)
+        apps.patch_namespaced_deployment(dep_name, NAMESPACE, body)
+        print(f"Patched deployment {dep_name}")
+    except client.exceptions.ApiException as e:
+        if e.status == 404:
+            apps.create_namespaced_deployment(NAMESPACE, body)
+            print(f"Created deployment {dep_name}")
+        else:
+            raise
+
+def reconcile():
+    load_kube()
+    api = client.CustomObjectsApi()
+    w = watch.Watch()
+    group = "aegis.example.com"
+    version = "v1"
+    plural = "agents"
+    core = client.CoreV1Api()
+
+    for event in w.stream(api.list_namespaced_custom_object, group, version, NAMESPACE, plural, timeout_seconds=0):
+        typ = event['type']
+        obj = event['object']
+        name = obj['metadata']['name']
+        spec = obj.get('spec', {})
+        print(f"Event {typ} on Agent {name}")
+        allow, reason = opa_check(spec)
+        status = {"status": {"state": "Blocked" if not allow else "Deploying", "message": reason}}
+        try:
+            api.patch_namespaced_custom_object_status(group, version, NAMESPACE, plural, name, status)
+        except Exception:
+            pass
+        if not allow:
+            print(f"OPA denied Agent {name}: {reason}")
+            continue
+        # Deploy agent workload
+        deploy_agent(api, name, spec)
+        try:
+            api.patch_namespaced_custom_object_status(group, version, NAMESPACE, plural, name, {"status":{"state":"Running","message":"Deployed"}})
+        except Exception:
+            pass
+
+if __name__ == "__main__":
+    print("Starting Aegis Agent Controller")
+    reconcile()
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/controller/agent-sample.yaml
+apiVersion: aegis.example.com/v1
+kind: Agent
+metadata:
+  name: sample-agent
+  namespace: default
+spec:
+  displayName: "sample-agent"
+  image: "ghcr.io/yourorg/agent-runtime:latest"
+  replicas: 1
+  tools:
+    - name: qna
+      kind: wasm
+      image: "aegis/tools/qna:latest"
+      allowNetwork: false
+  memory:
+    backend: s3
+    bucket: "aegis-agent-memory"
+  policyRef: "default-agent-policy"
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/tool-runner/README.md
+Tool runner (WASM) sidecar
+===========================
+
+This sidecar runs small tool binaries as WASM modules (preferred) or containerized tools with strict limits.
+It exposes a simple HTTP JSON RPC to the agent runtime to request tool execution.
+
+Design:
+- Listen on localhost:8081 for execution requests: {tool: "qna", input: {...}}
+- Lookup tool manifest (from embedded config) and either execute a WASM module with wasmtime or spin a ephemeral container (if allowed).
+- Enforce timeouts, memory limits, and disallow network egress unless tool manifest allows it.
+
+See runner.py for a minimal implementation (requires wasmtime).
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/tool-runner/runner.py
+#!/usr/bin/env python3
+"""
+Minimal WASM tool-runner HTTP sidecar.
+Requires wasmtime Python package: pip install wasmtime flask
+This runner is a demo scaffold — in production use a hardened runtime and attestation for tool binaries.
+"""
+from flask import Flask, request, jsonify
+import subprocess, os, tempfile, json, signal, time
+
+app = Flask(__name__)
+TOOLS_DIR = os.environ.get("TOOLS_DIR", "/opt/tools")
+
+@app.post("/run")
+def run_tool():
+    payload = request.get_json(force=True)
+    tool = payload.get("tool")
+    inp = payload.get("input", {})
+    timeout = payload.get("timeout", 10)
+    # Tool manifest resolution
+    manifest_path = os.path.join(TOOLS_DIR, f"{tool}.json")
+    if not os.path.exists(manifest_path):
+        return jsonify({"error":"tool not found"}), 404
+    with open(manifest_path) as f:
+        manifest = json.load(f)
+    kind = manifest.get("kind","wasm")
+    if kind == "wasm":
+        wasm_path = os.path.join(TOOLS_DIR, manifest["binary"])
+        if not os.path.exists(wasm_path):
+            return jsonify({"error":"wasm not found"}), 404
+        # Write input to temp file and run wasmtime --invoke main <file>
+        with tempfile.NamedTemporaryFile("w+", delete=False) as tf:
+            json.dump(inp, tf)
+            tf.flush()
+            tfname = tf.name
+        try:
+            # Use wasmtime CLI for demo. In real deployments use sandboxed WASM runtime with capability restrictions.
+            cmd = ["wasmtime", wasm_path, "--invoke", "run", tfname]
+            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)
+            try:
+                out,err = proc.communicate(timeout=timeout)
+                return jsonify({"stdout": out.decode("utf-8"), "stderr": err.decode("utf-8")})
+            except subprocess.TimeoutExpired:
+                os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
+                return jsonify({"error":"timeout"}), 504
+        finally:
+            try: os.unlink(tfname)
+            except: pass
+    else:
+        # Containerized tool path (not implemented here)
+        return jsonify({"error":"unsupported tool kind"}), 400
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=8081)
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/tool-runner/tool-example.json
+{
+  "name": "qna",
+  "kind": "wasm",
+  "binary": "qna.wasm",
+  "allowNetwork": false,
+  "timeoutSeconds": 5
+}
+
*** End Patch
*** Begin Patch
*** Add File:agent-action-audit/README.md
+Agent action audit (Rekor)
+========================
+
+This folder contains utilities to capture and publish signed agent action receipts to Rekor for tamper-evidence.
+
+Flow:
+- Agent runtime executes action -> Controller/audit client collects action metadata (agent id, timestamp, action payload, tool used, result)
+- The audit client signs the action payload (via Vault Transit or cosign) and submits the signature and payload to Rekor (or stores as an artifact alongside cosign signature).
+
+Files:
+- submit_action.py : example script to sign an action using cosign (vault transit key supported) and record in Rekor
+
+Operator: provide REKOR_SERVER, VAULT_ADDR and appropriate auth (VAULT_TOKEN or OIDC).
+
*** End Patch
*** Begin Patch
*** Add File:agent-action-audit/submit_action.py
+#!/usr/bin/env python3
+"""
+Sign and submit an agent action payload to Rekor using cosign.
+Requires cosign installed and access to signing key (e.g., vault://transit/keys/aegis-signing-key or local key file).
+"""
+import os, sys, json, tempfile, subprocess
+
+REKOR = os.environ.get("REKOR_SERVER", "https://rekor.sigstore.dev")
+SIGN_KEY = os.environ.get("COSIGN_KEY", "vault://transit/keys/aegis-signing-key")
+
+def submit_action(agent_id, action, result):
+    payload = {"agent_id": agent_id, "action": action, "result": result, "ts": __import__("time").time()}
+    tmp = tempfile.NamedTemporaryFile("w+", delete=False)
+    tmp.write(json.dumps(payload))
+    tmp.flush()
+    tmp.close()
+    sig = tmp.name + ".sig"
+    cose = tmp.name + ".cose"
+    # Use cosign sign-blob to create signature and Rekor entry
+    cmd = ["cosign","sign-blob","--key", SIGN_KEY, "--rekor-server", REKOR, "--output-signature", sig, "--output-cose", cose, tmp.name]
+    print("Running:", " ".join(cmd))
+    subprocess.check_call(cmd)
+    print("Signed payload and submitted to Rekor. Signature:", sig)
+    return tmp.name, sig, cose
+
+if __name__ == "__main__":
+    if len(sys.argv) < 4:
+        print("Usage: submit_action.py <agent_id> <action-json> <result-json>")
+        sys.exit(1)
+    agent_id = sys.argv[1]
+    action = json.loads(sys.argv[2])
+    result = json.loads(sys.argv[3])
+    submit_action(agent_id, action, result)
+
*** End Patch
*** Begin Patch
*** Add File:agent-memory/service/README.md
+Agent memory service
+====================
+
+Lightweight HTTP service to persist per-agent memory to object storage (S3/lakeFS). The service provides:
+- PUT /memory/{agent_id}/{key} : store JSON blob
+- GET /memory/{agent_id}/{key} : retrieve JSON blob
+
+This is a simple implementation using Flask + boto3. In production you should:
+- Use encryption at rest (SSE-KMS)
+- Authenticate agent access (mTLS or JWT)
+- Use per-agent namespaces and TTL/retention policies
+
*** End Patch
*** Begin Patch
*** Add File:agent-memory/service/app.py
+#!/usr/bin/env python3
+from flask import Flask, request, jsonify
+import boto3, os, json
+
+app = Flask(__name__)
+S3_BUCKET = os.environ.get("AGENT_MEMORY_BUCKET", "aegis-agent-memory")
+S3_PREFIX = os.environ.get("AGENT_MEMORY_PREFIX", "memory")
+s3 = boto3.client("s3")
+
+def key_for(agent_id, key):
+    return f"{S3_PREFIX}/{agent_id}/{key}.json"
+
+@app.route("/memory/<agent_id>/<key>", methods=["PUT"])
+def put_memory(agent_id, key):
+    body = request.get_json(force=True)
+    k = key_for(agent_id, key)
+    s3.put_object(Bucket=S3_BUCKET, Key=k, Body=json.dumps(body).encode("utf-8"))
+    return jsonify({"ok": True})
+
+@app.route("/memory/<agent_id>/<key>", methods=["GET"])
+def get_memory(agent_id, key):
+    k = key_for(agent_id, key)
+    try:
+        obj = s3.get_object(Bucket=S3_BUCKET, Key=k)
+        return jsonify(json.loads(obj["Body"].read()))
+    except s3.exceptions.NoSuchKey:
+        return jsonify({}), 404
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "8080")))
+
*** End Patch
*** Begin Patch
*** Add File:agent-memory/service/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: agent-memory
+  namespace: ops
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: agent-memory
+  template:
+    metadata:
+      labels:
+        app: agent-memory
+    spec:
+      containers:
+      - name: agent-memory
+        image: aegis/agent-memory:latest
+        env:
+        - name: AGENT_MEMORY_BUCKET
+          value: "aegis-agent-memory"
+        resources:
+          limits:
+            cpu: "500m"
+            memory: "512Mi"
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: agent-memory
+  namespace: ops
+spec:
+  ports:
+  - port: 8080
+    targetPort: 8080
+  selector:
+    app: agent-memory
+
*** End Patch
*** Begin Patch
*** Add File:safety/opa/agent_policy.rego
+package agent.policy
+
+# Deny tools that enable raw shell execution or network access by default.
+default allow = false
+
+allow {
+  input.image
+  not disallowed_tool
+}
+
+disallowed_tool {
+  some t
+  tool := input.tools[t]
+  tool.kind == "container"
+  contains(tool.name, "shell")
+}
+
+contains(xs, sub) {
+  count({x | x := split(xs, sub)}) > 1
+}
+
*** End Patch
*** Begin Patch
*** Add File:safety/opa/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: opa
+  namespace: ops
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: opa
+  template:
+    metadata:
+      labels:
+        app: opa
+    spec:
+      containers:
+      - name: opa
+        image: openpolicyagent/opa:0.48.0
+        args:
+        - "run"
+        - "--server"
+        - "--addr=0.0.0.0:8181"
+        - "/policies"
+        volumeMounts:
+        - name: policies
+          mountPath: /policies
+      volumes:
+      - name: policies
+        configMap:
+          name: opa-policies
+
+---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: opa-policies
+  namespace: ops
+data:
+  agent_policy.rego: |
+    package agent.policy
+
+    default allow = false
+
+    allow {
+      input.image
+      not disallowed_tool
+    }
+
+    disallowed_tool {
+      some t
+      tool := input.tools[t]
+      tool.kind == "container"
+      contains(tool.name, "shell")
+    }
+
+    contains(xs, sub) {
+      count({x | x := split(xs, sub)}) > 1
+    }
+
*** End Patch
*** Begin Patch
*** Add File:agent-manager/networkpolicy/agent-restrict-egress.yaml
+apiVersion: networking.k8s.io/v1
+kind: NetworkPolicy
+metadata:
+  name: agent-restrict-egress
+  namespace: default
+spec:
+  podSelector:
+    matchLabels:
+      agent: sample-agent
+  policyTypes:
+  - Egress
+  egress:
+  - to:
+    - namespaceSelector:
+        matchLabels:
+          name: ops
+    ports:
+    - protocol: TCP
+      port: 8080
+  - to:
+    - ipBlock:
+        cidr: 10.0.0.0/8
+    ports:
+    - protocol: TCP
+      port: 443
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/agent_manager_runbook.md
+# Agent Manager runbook (deploy & validate)
+
+1) Install CRD:
+   kubectl apply -f agent-manager/crds/agent.crd.yaml
+
+2) Create namespace & RBAC:
+   kubectl create ns ops || true
+   kubectl apply -f agent-manager/controller/serviceaccount.yaml
+   kubectl apply -f agent-manager/controller/role.yaml
+   kubectl apply -f agent-manager/controller/rolebinding.yaml
+
+3) Deploy OPA policy engine:
+   kubectl apply -f safety/opa/deployment.yaml
+
+4) Deploy controller:
+   - Build and push controller image (image ref in deployment.yaml)
+   - kubectl apply -f agent-manager/controller/deployment.yaml
+
+5) Deploy agent-memory service:
+   - Build/push image aegis/agent-memory:latest
+   - kubectl apply -f agent-memory/service/deployment.yaml
+
+6) Deploy tool-runner image or ensure runner binary is available in sidecar image
+
+7) Create a sample Agent:
+   kubectl apply -f agent-manager/controller/agent-sample.yaml
+
+Validation:
+- kubectl get deployments -n default | grep agent-sample
+- curl http://<agent-pod-ip>:8081/health (tool-runner)
+- Exercise a tool: the agent runtime should call the tool-runner sidecar and record any external action using agent-action-audit/submit_action.py which will write a Rekor entry (requires cosign + REKOR_SERVER + signing key)
+
+Security & hardening checklist:
+- Ensure Pod Security admission is enabled and PodSecurityPolicy / PodSecurity admission is configured to restrict privileged containers.
+- Ensure NetworkPolicies limit egress as required (see agent-manager/networkpolicy/agent-restrict-egress.yaml)
+- Ensure tool images are scanned and WASM modules are validated / signed before being allowed into the tools directory.
+- Configure Vault transit key for signing (used by submit_action.py)
+
*** End Patch
*** Begin Patch
*** Add File:examples/agent_action_example.json
+{
+  "agent_id": "sample-agent",
+  "action": {
+    "type": "call_tool",
+    "tool": "qna",
+    "input": {"question": "What is the capital of France?"}
+  },
+  "result": {
+    "answer": "Paris"
+  },
+  "ts": 0
+}
+
*** End Patch
*** Begin Patch
*** Add File:docs/agentic_design_notes.md
+# Agentic design notes (Aegis)
+
+Summary of what we implemented in this patch:
+- Agent CRD + simple controller that reconciles Agents to Deployments
+- Tool-runner sidecar (WASM-oriented) with a JSON-RPC HTTP API
+- Agent memory service for per-agent persistent memory (S3/lakeFS backend)
+- OPA-based policy check performed by controller before rollout (safety gating)
+- Agent action audit helper that signs actions and submits to Rekor via cosign
+- NetworkPolicy example to restrict agent egress
+
+Production considerations:
+- Replace simple controller with a robust operator (Kopf, controller-runtime) with leader election, metrics, retries
+- Harden tool-runner: use verified WASM runtime, capability-based sandboxing, or gVisor-like isolation for containerized tools
+- Integrate attestation of tool artifacts: sign tool WASM binaries and verify before execution
+- Per-agent auth: mTLS tokens between runtime and memory service and tool-runner
+- Action auditing: persist both payload and signed receipts to Rekor and to SIEM for analysis
+
*** End Patch
*** End Patch
