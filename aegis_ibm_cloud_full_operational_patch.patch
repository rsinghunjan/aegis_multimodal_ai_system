*** Begin Patch
*** Add File:terraform/ibm/README.md
+# IBM Cloud Terraform & CLI scaffolds for Aegis (Key Protect, COS, Service IDs)
+
+This directory contains operator-friendly scaffolds to provision IBM Cloud resources needed to make IBM Cloud fully operational for Aegis:
+- Key Protect (KMS/HSM) for Vault auto-unseal and key material
+- Cloud Object Storage (COS) for artifacts, model checkpoints and backup
+- Service ID / API key for automation tasks (least privilege)
+
+Notes
+- IBM Cloud tenancy-specific IDs (account, resource group, region, etc.) must be filled in before applying.
+- The Terraform provider for IBM Cloud has specific versioning and provider configuration â€” use the IBM Cloud docs and your tenant's requirements.
+- Where Terraform resources are not stable across tenants or require additional manual steps (Key Protect instance configuration, HSM), we include helper CLI scripts in scripts/ibm/ to perform common tasks and provide runbook guidance.
+
+Operator steps (high level)
+1. Fill terraform/ibm/example.tfvars with your tenancy values.
+2. Run scripts/ibm/validate_prereqs.sh to ensure ibmcloud CLI is installed and you are logged in.
+3. Run terraform init & plan in terraform/ibm/ and inspect the plan.
+4. Apply terraform to create COS (and optional Key Protect if desired), or use scripts/ibm/create_key_protect_and_service_id.sh for interactive provisioning.
+5. Configure Vault to use Key Protect for auto-unseal (see runbook in runbooks/ibm_vault_keyprotect_runbook.md).
+
*** End Patch
*** Begin Patch
*** Add File:terraform/ibm/variables.tf
+variable "ibm_region" {
+  type = string
+  default = "us-south"
+}
+
+variable "resource_group" {
+  type = string
+  default = "aegis-rg"
+}
+
+variable "resource_prefix" {
+  type = string
+  default = "aegis"
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/ibm/cos/main.tf
+# Example IBM COS resource creation (scaffold)
+# Replace / extend with your chosen provider resources or use ibmcloud console for advanced configs.
+resource "ibm_resource_group" "rg" {
+  name = var.resource_group
+}
+
+resource "ibm_cos_bucket" "artifacts" {
+  # Note: ibm_cos_bucket is a placeholder name. Use the official IBM provider resource if available.
+  bucket = "${var.resource_prefix}-artifacts"
+  # Other arguments (region, class) depend on provider support.
+}
+
+output "cos_bucket" {
+  value = "${var.resource_prefix}-artifacts"
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/ibm/key_protect/README.md
+# Key Protect module (scaffold)
+
+This module documents common steps to provision a Key Protect instance or use an existing instance for Vault auto-unseal and secure key storage.
+
+Operator note:
+- IBM Key Protect provisioning and HSM-backed keys often require account-level entitlements and specific service plans. We provide a scaffold and CLI helper scripts for interactive provisioning.
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ibm/validate_prereqs.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Validate prerequisites for IBM operations: ibmcloud cli, jq
+#
+if ! command -v ibmcloud >/dev/null 2>&1; then
+  echo "ibmcloud CLI not found. Install it from https://cloud.ibm.com/docs/cli"
+  exit 2
+fi
+if ! command -v jq >/dev/null 2>&1; then
+  echo "jq not found. Please install jq."
+  exit 2
+fi
+
+echo "ibmcloud CLI and jq found. Please ensure you are logged in: ibmcloud login --apikey <APIKEY>"
+echo "If using IAM Identity Federation / OIDC for CI, follow runbook to configure."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ibm/create_key_protect_and_service_id.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Interactive helper to create Key Protect instance, a key, COS bucket and a service ID with least-privilege role for Vault/CI.
+#
+# WARNING: This script includes example commands and must be adapted to your IBM tenancy and policy.
+#
+if ! command -v ibmcloud >/dev/null 2>&1; then
+  echo "ibmcloud CLI required. Install and run 'ibmcloud login --apikey <APIKEY>' first."
+  exit 2
+fi
+
+echo "Creating resource group (if missing)..."
+echo "ibmcloud resource group-create aegis-rg -d 'Aegis resources' || true"
+
+echo "Create Key Protect instance (example, operator to choose plan and region):"
+echo "ibmcloud resource service-instance-create aegis-kp km 'crn:v1:bluemix:public:kms:us-south:a/ACCOUNTID::' us-south standard"
+echo
+echo "After creating Key Protect, create a key:"
+echo "ibmcloud kp key create --instance aegis-kp --name aegis-sign-key --type rsa-2048"
+echo
+echo "Create Cloud Object Storage bucket (example):"
+echo "ibmcloud cos create-bucket --bucket aegis-artifacts --region us-south --class standard"
+echo
+echo "Create a Service ID for CI and grant it minimal roles (example):"
+echo "ibmcloud iam service-id-create aegis-ci -d 'Aegis CI service id'"
+echo "ibmcloud iam service-policy-create aegis-ci --roles Writer --service-name cloud-object-storage --resource-group-name aegis-rg"
+echo
+echo "Operator: after running these commands, proceed to configure Vault auto-unseal with Key Protect (see runbooks/ibm_vault_keyprotect_runbook.md)."
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/ibm_vault_keyprotect_runbook.md
+# Vault Auto-Unseal & Transit with IBM Key Protect (Runbook)
+
+Overview
+- This runbook describes operator steps to integrate HashiCorp Vault with IBM Key Protect (or HSM) for:
+  - Auto-unseal of Vault (seal/unseal using Key Protect)
+  - Transit-based signing (create transit key and allow Vault to sign artifacts)
+
+High-level steps
+1) Provision Key Protect instance and create a key (see scripts/ibm/create_key_protect_and_service_id.sh).
+2) Ensure your Vault deployment can reach the Key Protect endpoint (networking / VPC peers).
+3) Configure Vault auto-unseal with the IBM KMS provider. Two approaches:
+   - PKCS#11 connector to an HSM (if using classic HSM).
+   - Use an IBM-provided plugin or a cloud-specific auto-unseal mechanism (operator: consult IBM docs).
+4) Enable Transit engine and create a signing key:
+   vault secrets enable transit
+   vault write -f transit/keys/aegis-signing-key type="ecdsa-p256" exportable=false
+5) Create a Vault policy allowing the CI role to call transit/sign:
+   path "transit/sign/aegis-signing-key" { capabilities = ["create","update"] }
+   path "transit/verify/aegis-signing-key" { capabilities = ["read"] }
+6) Configure Vault JWT (or OIDC) auth to allow GitHub Actions to authenticate:
+   - In Vault, enable JWT auth method:
+     vault auth enable jwt
+   - Create a role that maps GitHub Actions claims to the policy, e.g.:
+     vault write auth/jwt/role/github-actions role_type="jwt" bound_audiences="sts.amazonaws.com" user_claim="sub" bound_subjects="repo:org/repo:ref:refs/heads/main" policies="aegis-sign-policy" ttl="1h"
+   - Operator must adapt bound_subjects & audiences to GitHub OIDC tokens (issuer: https://token.actions.githubusercontent.com).
+7) Test signing locally:
+   VAULT_ADDR=<vault_addr> vault login -method=jwt role=github-actions jwt=<id_token_from_github>
+   cosign sign --key "vault://transit/keys/aegis-signing-key" <image>
+
+Notes & troubleshooting
+- Vault version compatibility: ensure your Vault version supports JWT auth & transit and cosign's vault KMS integration.
+- Networking: Vault must be able to reach Key Protect endpoints and vice versa where applicable.
+- Audit: enable Vault audit logs (file or syslog) and forward to SIEM.
+
*** End Patch
*** Begin Patch
*** Add File:scripts/vault/setup_vault_for_ibm.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Helper to prepare Vault: enable transit, create signing key, and write policy for CI.
+# Operator must run this with a Vault admin token and ensure Vault can access Key Protect for auto-unseal.
+#
+VAULT_ADDR=${VAULT_ADDR:-http://127.0.0.1:8200}
+export VAULT_ADDR
+
+if ! command -v vault >/dev/null 2>&1; then
+  echo "vault CLI required. Install and ensure VAULT_ADDR and VAULT_TOKEN are set."
+  exit 2
+fi
+
+echo "Enabling transit secrets engine (if not already enabled)..."
+if ! vault secrets list | grep -q "^transit/"; then
+  vault secrets enable transit
+fi
+
+KEY_NAME=${1:-aegis-signing-key}
+echo "Creating transit key: $KEY_NAME (non-exportable)"
+vault write -f transit/keys/"$KEY_NAME" type="ecdsa-p256" exportable=false
+
+POL_NAME="aegis-transit-sign"
+cat > /tmp/aegis-transit-policy.hcl <<'EOF'
+path "transit/sign/*" {
+  capabilities = ["create","update"]
+}
+path "transit/verify/*" {
+  capabilities = ["read"]
+}
+EOF
+
+vault policy write "$POL_NAME" /tmp/aegis-transit-policy.hcl
+rm -f /tmp/aegis-transit-policy.hcl
+echo "Policy $POL_NAME created. Attach to your CI or GitHub OIDC role in Vault."
+
+echo "Note: configure JWT/OIDC auth in Vault for GitHub Actions (see runbooks/ibm_vault_keyprotect_runbook.md)."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ibm/cosign_vault_sign_wrapper.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Wrapper that logs in to Vault using GitHub OIDC token (via the runner-provided endpoint),
+# obtains VAULT_TOKEN via Vault JWT method, then uses cosign to sign an image using Vault Transit key.
+#
+usage() {
+  cat <<EOF
+Usage: $0 --image <image:tag> --vault-role <vault-jwt-role> --key <transit-key-name> [--rekor <rekor-url>]
+
+Environment:
+ - Requires 'vault' and 'cosign' in PATH
+ - The GitHub Actions runner must have id-token: write permission so the script can request an OIDC token
+ - Vault must be configured with JWT auth method and a role matching GitHub OIDC claims
+EOF
+  exit 1
+}
+
+IMAGE=""
+VAULT_ROLE=""
+KEY_NAME=""
+REKOR_SERVER=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --image) IMAGE="$2"; shift 2;;
+    --vault-role) VAULT_ROLE="$2"; shift 2;;
+    --key) KEY_NAME="$2"; shift 2;;
+    --rekor) REKOR_SERVER="$2"; shift 2;;
+    -h|--help) usage;;
+    *) echo "Unknown arg: $1"; usage;;
+  esac
+done
+
+if [ -z "$IMAGE" ] || [ -z "$VAULT_ROLE" ] || [ -z "$KEY_NAME" ]; then
+  usage
+fi
+
+if ! command -v vault >/dev/null 2>&1; then echo "vault CLI required"; exit 2; fi
+if ! command -v cosign >/dev/null 2>&1; then echo "cosign required"; exit 2; fi
+
+echo "Requesting GitHub Actions OIDC token from runner endpoint..."
+ID_TOKEN_JSON=$(curl -s -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" "${ACTIONS_ID_TOKEN_REQUEST_URL:-}")
+ID_TOKEN=$(echo "$ID_TOKEN_JSON" | jq -r .value)
+if [ -z "$ID_TOKEN" ] || [ "$ID_TOKEN" = "null" ]; then
+  echo "Failed to obtain OIDC token. Response: $ID_TOKEN_JSON"
+  exit 2
+fi
+
+echo "Logging into Vault using JWT auth method and role: $VAULT_ROLE"
+VAULT_LOGIN_JSON=$(vault login -format=json -method=jwt role="$VAULT_ROLE" jwt="$ID_TOKEN")
+VAULT_TOKEN=$(echo "$VAULT_LOGIN_JSON" | jq -r .auth.client_token)
+if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" = "null" ]; then
+  echo "Vault login failed: $VAULT_LOGIN_JSON"
+  exit 2
+fi
+
+export VAULT_TOKEN
+echo "Logged into Vault. Using VAULT_ADDR=$VAULT_ADDR"
+
+echo "Signing image $IMAGE using Vault Transit key: $KEY_NAME"
+if [ -n "$REKOR_SERVER" ]; then
+  cosign sign --key "vault://transit/keys/$KEY_NAME" --rekor-server "$REKOR_SERVER" "$IMAGE"
+else
+  cosign sign --key "vault://transit/keys/$KEY_NAME" "$IMAGE"
+fi
+
+echo "Signed $IMAGE. cosign returned exit status: $?"
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/ibm_vault_cosign_sign.yml
+name: Build & Sign (IBM Cloud via Vault Transit + OIDC)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write
+  contents: read
+  packages: write
+
+jobs:
+  build-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Install tooling
+        run: |
+          sudo apt-get update
+          sudo apt-get install -y jq curl
+          curl -sSL https://github.com/sigstore/cosign/releases/download/v2.1.0/cosign-linux-amd64 -o /usr/local/bin/cosign
+          chmod +x /usr/local/bin/cosign
+          wget -qO- https://releases.hashicorp.com/vault/1.14.3/vault_1.14.3_linux_amd64.zip | bsdtar -xvf- -C /usr/local/bin
+          chmod +x /usr/local/bin/vault
+
+      - name: Build & push image
+        env:
+          GHCR_PAT: ${{ secrets.GHCR_PAT }}
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "$GHCR_PAT" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image via Vault Transit using GitHub OIDC (no long-lived secrets)
+        env:
+          REKOR_SERVER: ${{ secrets.REKOR_SERVER }}
+          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
+        run: |
+          chmod +x scripts/ibm/cosign_vault_sign_wrapper.sh
+          ./scripts/ibm/cosign_vault_sign_wrapper.sh --image "$IMAGE" --vault-role "github-actions" --key "aegis-signing-key" --rekor "$REKOR_SERVER"
+
+      - name: Upload Rekor artifact (optional)
+        uses: actions/upload-artifact@v4
+        with:
+          name: rekor-artifacts
+          path: artifacts || true
+
*** End Patch
*** Begin Patch
*** Add File:scripts/validate/ibm_end_to_end.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# End-to-end validation for IBM Cloud signing & webhook flow (operator-run).
+#
+# Usage:
+#  VAULT_ADDR=<vault_addr> REKOR_SERVER=<rekor_url> ./scripts/validate/ibm_end_to_end.sh --image <image:tag>
+#
+IMAGE=""
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --image) IMAGE="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 --image <image:tag>"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$IMAGE" ]; then
+  echo "Specify --image <image:tag> to validate"
+  exit 2
+fi
+
+if ! command -v cosign >/dev/null 2>&1; then
+  echo "cosign required"
+  exit 2
+fi
+if ! command -v kubectl >/dev/null 2>&1; then
+  echo "kubectl required"
+  exit 2
+fi
+
+REKOR_SERVER="${REKOR_SERVER:-}"
+if [ -z "$REKOR_SERVER" ]; then
+  echo "Set REKOR_SERVER env var to your Rekor server URL"
+  exit 2
+fi
+
+echo "1) Verify Rekor entry for $IMAGE"
+cosign verify --rekor-server "$REKOR_SERVER" "$IMAGE"
+
+echo "2) Attempt to deploy pod with image to test webhook"
+NS="aegis-ibm-validate"
+kubectl create ns "$NS" || true
+cat > /tmp/aegis-validate-pod.yaml <<YAML
+apiVersion: v1
+kind: Pod
+metadata:
+  name: aegis-validate-pod
+  namespace: $NS
+spec:
+  containers:
+  - name: app
+    image: $IMAGE
+    command: ["/bin/sh","-c","sleep 300"]
+  restartPolicy: Never
+YAML
+
+set +e
+kubectl apply -f /tmp/aegis-validate-pod.yaml
+APPLY_RC=$?
+set -e
+
+if [ $APPLY_RC -ne 0 ]; then
+  echo "Pod creation failed (admission webhook may have blocked it). Inspect webhook logs and kubectl events:"
+  kubectl get events -n $NS --sort-by='.metadata.creationTimestamp'
+  exit 2
+fi
+
+echo "Pod accepted by admission webhook. Waiting for readiness..."
+kubectl wait --for=condition=ready pod/aegis-validate-pod -n $NS --timeout=60s || true
+kubectl get pod aegis-validate-pod -n $NS -o wide
+
+echo "Validation complete. Clean up: kubectl delete ns $NS"
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/ibm_finalization_checklist.md
+# IBM Cloud Finalization Checklist (Operator)
+
+Follow these steps to finalize IBM Cloud as an operational provider for Aegis.
+
+1) Prerequisites
+- Install ibmcloud CLI and jq on your workstation or automation host.
+- Login with an API key: ibmcloud login --apikey <APIKEY> -r <region> -g <resource-group>
+
+2) Provision resources (CLI or Terraform)
+- Option A: Use scripts/ibm/create_key_protect_and_service_id.sh (interactive).
+- Option B: Fill terraform/ibm/example.tfvars and run terraform init & apply in terraform/ibm/
+- Create Key Protect instance and create a signing key (or ensure an existing key is available).
+- Create Cloud Object Storage bucket for artifacts.
+- Create a Service ID (or IAM role) for operator tasks (assign minimal roles).
+
+3) Vault integration
+- Ensure Vault is reachable from your network (staging cluster).
+- Configure Vault auto-unseal using Key Protect/HSM per your environment (see runbooks/ibm_vault_keyprotect_runbook.md).
+- Run scripts/vault/setup_vault_for_ibm.sh to enable transit and create a signing key (aegis-signing-key).
+- Configure Vault JWT auth (auth/jwt) to accept GitHub OIDC tokens and create a role 'github-actions' mapping to the aetgis-transit-sign policy.
+
+4) CI / GitHub Actions
+- Add repository secrets:
+  - VAULT_ADDR (Vault URL)
+  - REKOR_SERVER (your Rekor server, or https://rekor.sigstore.dev for testing)
+  - GHCR_PAT (to push images)
+  - (Optional) any provider-specific exchange secrets if you plan to use provider-specific flows
+- Use .github/workflows/ibm_vault_cosign_sign.yml to build, push and sign images via Vault Transit (OIDC login)
+
+5) Deploy Rekor & webhook verifier
+- Deploy Rekor server (or use public Rekor for testing).
+- Deploy image-verifier (use the GHCR image published by .github/workflows/build_image_verifier.yml) and configure aegis-rekor secret with rekor_server.
+- Create TLS secret for webhook and apply webhook configuration (security/image-verifier/webhook-configuration.yaml).
+
+6) Validate
+- Use scripts/validate/ibm_end_to_end.sh --image <image:tag> to verify Rekor entry and webhook admission.
+
+7) Audit & rotate
+- Ensure Vault audit logs are enabled and forwarded to your SIEM.
+- Periodically rotate keys and test the rotation with signed artifacts.
+
*** End Patch
*** End Patch
