*** Begin Patch
*** Add File:ops/k8s/namespaces_and_rbac.yaml
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: aegis-core
+
+---
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: aegis-integrations
+
+---
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: core-registry-sa
+  namespace: aegis-core
+
+---
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: integrations-sa
+  namespace: aegis-integrations
+
+---
+# Read/write RBAC for core registry service (only in aegis-core)
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: core-registry-role
+  namespace: aegis-core
+rules:
+  - apiGroups: [""] 
+    resources: ["pods","services","configmaps","secrets"]
+    verbs: ["get","list","create","update","patch","watch"]
+
+---
+# Bind core-registry-sa to core registry role
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: core-registry-rb
+  namespace: aegis-core
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: Role
+  name: core-registry-role
+subjects:
+  - kind: ServiceAccount
+    name: core-registry-sa
+    namespace: aegis-core
+
+---
+# Minimal read-only Role for integrations namespace so connectors can only read artifacts via the registry API (not write)
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: integrations-readonly
+  namespace: aegis-integrations
+rules:
+  - apiGroups: [""]
+    resources: ["pods","services"]
+    verbs: ["get","list"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: integrations-readonly-rb
+  namespace: aegis-integrations
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: Role
+  name: integrations-readonly
+subjects:
+  - kind: ServiceAccount
+    name: integrations-sa
+    namespace: aegis-integrations
+
*** End Patch
*** Begin Patch
*** Add File:ops/k8s/networkpolicy-core.yaml
+apiVersion: networking.k8s.io/v1
+kind: NetworkPolicy
+metadata:
+  name: deny-from-integrations
+  namespace: aegis-core
+spec:
+  podSelector: {}
+  policyTypes:
+    - Ingress
+  ingress:
+    - from:
+        - namespaceSelector:
+            matchLabels:
+              name: aegis-core
+      ports:
+        - protocol: TCP
+          port: 27017 # allow Mongo from core
+    - from:
+        - podSelector:
+            matchLabels:
+              allow-to-core: "true"
+      ports:
+        - protocol: TCP
+          port: 8080 # allow specific integrations only via labeled pods
+
+# This policy enforces that only pods in aegis-core or pods with label allow-to-core=true can access core namespace pods.
+
*** End Patch
*** Begin Patch
*** Add File:registry/authoritative_api.py
+#!/usr/bin/env python3
+"""
+Authoritative Artifact Registry API (aegis-core)
+
+Responsibilities:
+ - Serve artifact metadata from MongoDB (source-of-truth)
+ - Validate Rekor attestation presence (optional) and surface signed evidence S3 links
+ - Only runs in aegis-core namespace and accepts connections from integrations via service
+
+Endpoints:
+ - GET /api/artifacts -> list recent artifacts
+ - GET /api/artifacts/<artifact_id> -> artifact metadata & attestations
+ - GET /api/health
+
+Env:
+ - MONGO_URI
+ - REKOR_URL
+"""
+from flask import Flask, jsonify, request
+from pymongo import MongoClient
+import os, requests
+
+app = Flask("aegis-registry")
+MONGO = os.environ.get("MONGO_URI","mongodb://mongo.aegis.svc:27017")
+REKOR_URL = os.environ.get("REKOR_URL","")
+client = MongoClient(MONGO)
+db = client['aegis']
+
+@app.route("/api/health")
+def health():
+    return jsonify({"status":"ok"})
+
+@app.route("/api/artifacts")
+def list_artifacts():
+    docs = list(db.artifacts.find().sort("registered_at",-1).limit(100))
+    for d in docs:
+        d["_id"] = str(d["_id"])
+    return jsonify(docs)
+
+@app.route("/api/artifacts/<artifact_id>")
+def get_artifact(artifact_id):
+    doc = db.artifacts.find_one({"artifact_id": artifact_id})
+    if not doc:
+        return jsonify({"error":"not found"}), 404
+    # Verify Rekor attestation if Rekor URL configured
+    attestation = doc.get("rekor_entry")
+    verified = False
+    if attestation and REKOR_URL:
+        try:
+            r = requests.get(f"{REKOR_URL}/api/v1/log/entries/{attestation}", timeout=10)
+            verified = r.status_code == 200
+        except Exception:
+            verified = False
+    doc["_id"] = str(doc["_id"])
+    doc["rekor_verified"] = verified
+    return jsonify(doc)
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("PORT","8080")))
+
*** End Patch
*** Begin Patch
*** Add File:ops/onboarding/onboard_team.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Onboard team into Aegis platform:
+# - create team entry in Mongo registry
+# - create Vault policy & role for the team
+# - create minimal evidence template and owner binding
+#
+# Usage: ./onboard_team.sh <team-name> <owner-email>
+
+TEAM=${1:?team required}
+OWNER=${2:?owner email required}
+MONGO_URI=${MONGO_URI:-"mongodb://mongo.aegis.svc:27017"}
+VAULT_ADDR=${VAULT_ADDR:-"https://vault.vault.svc:8200"}
+
+echo "Registering team ${TEAM} in Mongo registry"
+python3 - <<PY
+from pymongo import MongoClient
+import os, time, sys
+client = MongoClient(os.environ.get("MONGO_URI","mongodb://mongo.aegis.svc:27017"))
+db = client['aegis']
+team = {"team": os.environ.get("TEAM"), "owner": os.environ.get("OWNER"), "created_at": time.time()}
+db.teams.update_one({"team":team["team"]}, {"$set":team}, upsert=True)
+print("Done")
+PY
+
+echo "Creating Vault policy and role for team ${TEAM} (requires VAULT_TOKEN and kubernetes config)"
+cat > /tmp/${TEAM}_policy.hcl <<HCL
+path "secret/data/aegis/${TEAM}/*" {
+  capabilities = ["read","list"]
+}
+HCL
+vault policy write aegis-team-${TEAM} /tmp/${TEAM}_policy.hcl || true
+vault write auth/kubernetes/role/aegis-${TEAM} bound_service_account_names=langgraph-runtime bound_service_account_namespaces=aegis policies="aegis-team-${TEAM}" ttl=24h || true
+
+echo "Onboard complete. Team policy 'aegis-team-${TEAM}' created in Vault and team record added to Mongo."
+
*** End Patch
*** Begin Patch
*** Add File:monitoring/metrics/exporter.py
+#!/usr/bin/env python3
+"""
+Prometheus exporter for Aegis core KPIs:
+ - aegis_evidence_coverage (0..1)
+ - aegis_model_drift_rate (count)
+ - aegis_model_perf (gauge e.g., accuracy)
+ - aegis_token_cost_total (counter, approximate)
+
+This exporter reads the Mongo registry and token budget DB to compute metrics.
+"""
+from prometheus_client import start_http_server, Gauge, Counter
+from pymongo import MongoClient
+import time, os
+
+MONGO_URI = os.environ.get("MONGO_URI","mongodb://mongo.aegis.svc:27017")
+client = MongoClient(MONGO_URI)
+db = client['aegis']
+
+EVIDENCE_COVERAGE = Gauge("aegis_evidence_coverage", "Fraction of artifacts with signed evidence")
+DRIFT_RATE = Gauge("aegis_model_drift_rate", "Model drift events in last window")
+MODEL_PERF = Gauge("aegis_model_performance", "Representative model performance (accuracy or other)")
+TOKEN_COST = Counter("aegis_token_cost_total", "Cumulative token cost observed (units arbitrary)")
+
+def compute_metrics():
+    artifacts = list(db.artifacts.find({}))
+    total = len(artifacts)
+    if total == 0:
+        EVIDENCE_COVERAGE.set(1)
+    else:
+        signed = sum(1 for a in artifacts if a.get("evidence_s3"))
+        EVIDENCE_COVERAGE.set(signed/total)
+    # drift rate: count recent drift documents
+    drift_count = db.drift.count_documents({"ts": {"$gt": time.time() - 3600}})
+    DRIFT_RATE.set(drift_count)
+    # model perf: compute mean of latest reported performance if available
+    perf_docs = list(db.model_metrics.find().sort("ts",-1).limit(10))
+    if perf_docs:
+        MODEL_PERF.set(sum(d.get("value",0) for d in perf_docs)/len(perf_docs))
+    # token cost: sum from token_usage collection
+    token_usage = db.token_usage.aggregate([{"$group":{"_id":None,"sum":{"$sum":"$cost"}}}])
+    total_cost = 0
+    for r in token_usage:
+        total_cost = r.get("sum",0)
+    TOKEN_COST.inc(total_cost)
+
+if __name__ == "__main__":
+    port = int(os.environ.get("METRICS_PORT","9110"))
+    start_http_server(port)
+    print("Aegis KPI exporter listening on", port)
+    while True:
+        try:
+            compute_metrics()
+        except Exception as e:
+            print("metrics compute error", e)
+        time.sleep(30)
+
*** End Patch
*** Begin Patch
*** Add File:ops/checks/evidence_coverage_cronjob.yaml
+apiVersion: batch/v1
+kind: CronJob
+metadata:
+  name: evidence-coverage-check
+  namespace: aegis-core
+spec:
+  schedule: "*/15 * * * *"
+  jobTemplate:
+    spec:
+      template:
+        spec:
+          serviceAccountName: core-registry-sa
+          containers:
+            - name: coverage
+              image: python:3.10-slim
+              command: ["/bin/sh","-c"]
+              args:
+                - pip install pymongo prometheus_client boto3 || true; python3 - <<PY
+from pymongo import MongoClient
+import os, time, json, boto3
+client = MongoClient(os.environ.get("MONGO_URI","mongodb://mongo.aegis.svc:27017"))
+db = client['aegis']
+total = db.artifacts.count_documents({})
+signed = db.artifacts.count_documents({"evidence_s3":{"$exists":True}})
+report = {"total": total, "signed": signed, "timestamp": time.time()}
+print("Evidence coverage:", report)
+if os.environ.get("EVIDENCE_BUCKET"):
+    s3 = boto3.client("s3")
+    s3.put_object(Bucket=os.environ.get("EVIDENCE_BUCKET"), Key=f"platform-reports/evidence-coverage-{int(time.time())}.json", Body=json.dumps(report))
+PY
+          restartPolicy: OnFailure
+
*** End Patch
*** Begin Patch
*** Add File:docs/SERVICE_BOUNDARIES.md
+# Aegis â€” Service Boundary & Ownership Guidelines
+
+Purpose
+- Keep strict separation between platform core and integrations. Core services are the source of truth and own artifact metadata, evidence, attestation and safety flows.
+
+Namespaces
+- aegis-core: model registry, evidence store writers, Triton/Seldon serving, safety-monitor, Vault integrations.
+- aegis-integrations: webhook receivers, PM connectors (Monday/Zoho), dashboard frontends/backends, external connectors.
+
+Ownership
+- Core team: owns aegis-core services, RBAC, backup & restore, SLOs.
+- Integrations team: owns aegis-integrations services, connectors and UI; may request new read APIs from core.
+
+Rules
+- Integrations may read artifact metadata only via the authoritative registry API (aegis-core registry).
+- Integrations must not write or mutate artifact metadata directly in Mongo or Rekor.
+- NetworkPolicy and RBAC enforce these boundaries. See ops/k8s/namespaces_and_rbac.yaml and ops/k8s/networkpolicy-core.yaml.
+
*** End Patch
*** Begin Patch
*** Add File:docs/API_CONTRACTS.md
+# Aegis API Contracts (authoritative registry)
+
+Registry API (Authoritative)
+- GET /api/artifacts -> list artifacts (core)
+- GET /api/artifacts/<artifact_id> -> artifact metadata, evidence links, Rekor verification
+
+Contract rules
+- Responses must include:
+  - artifact_id
+  - manifest (object)
+  - evidence_s3 (optional)
+  - rekor_entry (optional)
+  - rekor_verified (bool)
+  - registered_at (unix ts)
+- Integrations must use these endpoints; they are the source of truth for promotion state.
+
+Security
+- Registry API is hosted in aegis-core and only accepts authorized requests from integrations via authenticated service accounts.
+
*** End Patch
*** Begin Patch
*** Add File:docs/ONBOARDING_RUNBOOK.md
+# Automated Onboarding Runbook (summary)
+
+1) Add team to registry:
+   ./ops/onboarding/onboard_team.sh <team> <owner@example.com>
+
+2) Vault policy & role will be created for team. Ensure Vault operator reviews created policies:
+   vault policy read aegis-team-<team>
+
+3) Provide team with onboarding checklist & least-privilege Vault role binding.
+
+4) Add team to SLO and monitoring dashboards by creating entries in Mongo:
+   mongo: db.teams.insertOne({team:"team",owner:"owner",slos:{latency:1.0,accuracy:0.9}})
+
+5) All onboarding actions produce signed evidence entries uploaded to EVIDENCE_BUCKET by the core operator.
+
*** End Patch
*** Begin Patch
*** Add File:docs/KPI_AND_SLO_GUIDE.md
+# KPI & SLO Guide (Aegis)
+
+Primary KPIs
+- Evidence coverage: fraction of artifacts with evidence_s3 present in registry.
+- Model performance: representative metric (accuracy/mAP/ROUGE) per model family.
+- Drift rate: number of drift events per hour/day.
+- Token cost: cumulative HF token spend per team.
+
+SLO examples
+- Inference latency: 95th percentile < 1.0s (alert: page)
+- Evidence coverage: >= 95% for promoted artifacts (alert: ticket)
+- Model error rate: < 1% (alert: ticket)
+- Token budget: per-team weekly budget not exceeded (alert: page if > 110%)
+
+Monitoring
+- Exporter: monitoring/metrics/exporter.py provides Prometheus metrics.
+- Alerts: monitoring/slo/prometheus_slo_rules.yaml defines alerts and severities.
+
*** End Patch
*** Begin Patch
*** Add File:docs/UI_SCOPE.md
+# Dashboard & UI Scope Guidance
+
+- Keep UI surface minimal and ML-specific:
+  - Artifact registry view (evidence links, manifests, promotion status)
+  - Promotion actions & approvals (links that open external PM system for workflow)
+  - Health & KPI dashboards (drift, evidence coverage, SLOs)
+
+- Do NOT implement general task management (use Monday/Zoho/Jira/GitHub Issues).
+- Integrations should surface links back to authoritative artifacts, not duplicate or own metadata.
+
*** End Patch
*** End Patch
