*** Begin Patch
*** Add File:tenant-wiring/README.md
+# Tenant wiring helpers — Azure, OCI, Alibaba
+
+This directory contains scripts, templates and runbooks to help operators perform the one‑time tenant wiring required to enable OIDC federation, least‑privilege IAM, and CI-driven KMS signing for Azure, OCI and Alibaba Cloud.
+
+Purpose
+- Provide safe, operator-run scripts to:
+  - Create Azure AD App registration + federated credential (GitHub Actions) + user-assigned managed identity + Key Vault access policy.
+  - Generate OCI Dynamic Group rule + sample policy and helper text to create an Identity Provider and dynamic group.
+  - Generate Alibaba RAM role trust policy + sample RAM policy and helper text to create an OIDC trust and role.
+- Produce example EXCHANGE_CMD and repo secret values you must store (OCI_EXCHANGE_CMD, ALICLOUD_EXCHANGE_CMD, AZURE_KEY_URI, OCI_KEY_URI, ALICLOUD_KEY_URI).
+- All scripts are intentionally operator-interactive or generate artifacts for operator review — they do NOT modify tenancy without you running them.
+
+Important notes
+- These scripts require CLI tools (az, oci, aliyun) and appropriate operator permissions. They do not contain tenancy secrets.
+- Always run in a staging account/compartment first.
+- Review runbooks/tenant-wiring-runbook.md for manual steps and validation.
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/runbooks/tenant-wiring-runbook.md
+# Tenant wiring runbook (Azure, OCI, Alibaba)
+
+Overview
+- This runbook guides you through the tenant wiring steps required to enable GitHub Actions OIDC federation and least‑privilege KMS signing for Azure, OCI and Alibaba Cloud.
+- After performing these steps you will:
+  - Have federated identities (or instructions) that allow GitHub Actions to obtain short-lived provider credentials without long-lived secrets.
+  - Have example repository secrets and EXCHANGE_CMD values to be stored in GitHub.
+  - Be able to run our CI workflows that sign images using provider KMS and log to Rekor.
+
+Prereqs (one per cloud)
+- Azure: az CLI logged in as a user with permission to create app registrations, managed identities, and set Key Vault policies.
+- OCI: oci CLI configured with an administrator profile to create an Identity Provider and Dynamic Group (or create these in Console).
+- Alibaba: aliyun CLI configured with an account that can create RAM roles and OIDC providers (or create these in Console).
+- GitHub repo admin permissions (to create repo secrets and enable Actions id-token).
+
+High level steps
+1) Run the provider scripts in this directory to create artifacts or to generate payloads for manual creation.
+2) Create federation/identity in the provider console if scripts generate an artifact for manual paste.
+3) Create least-privilege IAM bindings/policies (script outputs provide recommended policies).
+4) Store produced values in GitHub repository secrets:
+   - AZURE_OIDC_CLIENT_ID, AZURE_TENANT_ID, AZURE_KEY_URI
+   - OCI_EXCHANGE_CMD, OCI_KEY_URI
+   - ALICLOUD_EXCHANGE_CMD, ALICLOUD_KEY_URI
+   - REKOR_SERVER
+5) Run the cloud-specific CI workflow we provided (azure_oidc_cosign_sign.yml, oci_oidc_cosign_sign.yml, alibaba_oidc_cosign_sign.yml).
+6) Validate using scripts/validate/* and the webhook (we provide validation automation elsewhere).
+
+Validation checklist
+- Confirm GitHub Actions 'id-token: write' permission is enabled in workflows.
+- Trigger the provider CI workflow and confirm it completes without errors.
+- Confirm cosign created Rekor entries: cosign verify --rekor-server <rekor> <image>
+- Deploy a Pod using the signed image; webhook should admit; unsigned images should be denied.
+
+Support & Troubleshooting
+- If the provider CLI fails, check tenancy permissions and whether identity provider creation needs manual console approval.
+- For Azure, ensure Graph permissions are available to create federated credentials (you may need to be a Global Admin or have Application Administrator roles).
+- For OCI/Alibaba, sometimes console steps are required; scripts generate JSON/policy text to paste in console.
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/azure/create_azure_oidc_federation.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# create_azure_oidc_federation.sh
+# Creates an Azure AD App Registration and adds a federated credential for GitHub Actions.
+# Also creates a user-assigned managed identity and outputs sample az keyvault set-policy command to grant key permissions.
+#
+# IMPORTANT:
+# - Must be run by a user with rights to create app registrations and managed identities (Global Administrator or Application Administrator + Resource Group contributor).
+# - This script uses the Azure CLI and Microsoft Graph REST API (via az rest). Newer az versions include 'az ad app federated-credential' command; we attempt to use it if available.
+#
+set -o pipefail
+
+usage() {
+  cat <<EOF
+Usage: $0 --org <github-org> --repo <github-repo> --vault-name <keyvault-name> --resource-group <rg> --location <location>
+
+Outputs:
+ - AZURE_AD_APP_ID
+ - AZURE_OIDC_CLIENT_ID (same as app id)
+ - Managed Identity client id and principal id (for Key Vault policy grant)
+
+Example:
+  ./create_azure_oidc_federation.sh --org myorg --repo myrepo --vault-name mykv --resource-group my-rg --location eastus
+EOF
+  exit 1
+}
+
+ORG=""
+REPO=""
+VAULT_NAME=""
+RESOURCE_GROUP=""
+LOCATION="eastus"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --org) ORG="$2"; shift 2;;
+    --repo) REPO="$2"; shift 2;;
+    --vault-name) VAULT_NAME="$2"; shift 2;;
+    --resource-group) RESOURCE_GROUP="$2"; shift 2;;
+    --location) LOCATION="$2"; shift 2;;
+    -h|--help) usage;;
+    *) echo "Unknown arg: $1"; usage;;
+  esac
+done
+
+if [ -z "$ORG" ] || [ -z "$REPO" ] || [ -z "$VAULT_NAME" ] || [ -z "$RESOURCE_GROUP" ]; then
+  usage
+fi
+
+if ! command -v az >/dev/null 2>&1; then
+  echo "az CLI required. Install from https://docs.microsoft.com/cli/azure/install-azure-cli"
+  exit 2
+fi
+
+echo "Creating Azure AD application registration..."
+APP_JSON=$(az ad app create --display-name "aegis-github-federation-${ORG}-${REPO}" --available-to-other-tenants false --query "{appId:appId,id:id}" -o json)
+APP_ID=$(echo "$APP_JSON" | jq -r .appId)
+APP_OBJ_ID=$(echo "$APP_JSON" | jq -r .id)
+echo "Created app registration. appId=$APP_ID, objectId=$APP_OBJ_ID"
+
+FED_NAME="gha-federation-${ORG}-${REPO}"
+ISSUER="https://token.actions.githubusercontent.com"
+SUBJECT="repo:${ORG}/${REPO}:ref:refs/heads/main"   # adjust branch/ref as needed
+AUDIENCES='["api://AzureADTokenExchange","api://AzureADTokenExchange"]'
+
+echo "Creating federated credential for GitHub Actions..."
+# Try to use az ad app federated-credential create if available (az >= appropriate version)
+if az ad app federated-credential create -h >/dev/null 2>&1; then
+  az ad app federated-credential create --id "$APP_ID" --display-name "$FED_NAME" --parameters "{\"name\":\"$FED_NAME\",\"issuer\":\"$ISSUER\",\"subject\":\"$SUBJECT\",\"audiences\":[\"api://AzureADTokenExchange\"]}"
+else
+  # fallback using Microsoft Graph via az rest (requires appropriate RBAC)
+  echo "az ad app federated-credential not available. Using az rest to call MS Graph (requires rights)."
+  BODY=$(jq -n --arg n "$FED_NAME" --arg iss "$ISSUER" --arg sub "$SUBJECT" '{name:$n,issuer:$iss,subject:$sub,audiences:["api://AzureADTokenExchange"]}')
+  az rest --method POST --uri "https://graph.microsoft.com/v1.0/applications/${APP_OBJ_ID}/federatedIdentityCredentials" --body "$BODY"
+fi
+
+echo "Creating user-assigned managed identity in resource group $RESOURCE_GROUP..."
+IDENTITY_JSON=$(az identity create --resource-group "$RESOURCE_GROUP" --name "aegis-ci-identity" --location "$LOCATION" -o json)
+MI_CLIENT_ID=$(echo "$IDENTITY_JSON" | jq -r .clientId)
+MI_PRINCIPAL_ID=$(echo "$IDENTITY_JSON" | jq -r .principalId)
+echo "Managed identity created: clientId=$MI_CLIENT_ID principalId=$MI_PRINCIPAL_ID"
+
+echo
+echo "Grant Key Vault permissions to the managed identity (wrapKey, unwrapKey, get)."
+echo "Run (operator):"
+echo "  az keyvault set-policy --name $VAULT_NAME --object-id $MI_PRINCIPAL_ID --key-permissions wrapKey unwrapKey get"
+
+echo
+echo "Outputs (store these as GitHub repo secrets):"
+echo "  AZURE_OIDC_CLIENT_ID=$APP_ID"
+echo "  AZURE_OIDC_APP_OBJECT_ID=$APP_OBJ_ID"
+echo "  AZURE_MANAGED_IDENTITY_CLIENT_ID=$MI_CLIENT_ID"
+echo "  AZURE_MANAGED_IDENTITY_PRINCIPAL_ID=$MI_PRINCIPAL_ID"
+
+echo
+echo "Next:"
+echo " - Configure your Key Vault key (create key, note key URI azurekms://<vault>.vault.azure.net/keys/<keyname>) and store that in AZURE_KEY_URI repo secret."
+echo " - Create Vault or CI policies following runbooks/tenant-wiring-runbook.md"
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/oci/generate_oci_oidc_dynamic_group_and_policy.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# generate_oci_oidc_dynamic_group_and_policy.sh
+# Generates example OCI dynamic group rule and IAM policy text for GitHub OIDC federation.
+#
+# This script assists by emitting the JSON and policy statements you can paste into the OCI Console or pass to the oci CLI.
+#
+# Usage:
+#   ./generate_oci_oidc_dynamic_group_and_policy.sh --org <github-org> --repo <github-repo> --compartment-ocid <compartment_ocid>
+#
+usage() {
+  cat <<EOF
+Usage: $0 --org <github-org> --repo <github-repo> --compartment-ocid <compartment_ocid>
+
+The script outputs:
+ - Example Identity Provider metadata to create an OIDC identity provider in OCI Console
+ - Dynamic Group rule to match GitHub Actions OIDC tokens for the given repo and branch (main)
+ - Example policy statements to allow the dynamic group to use KMS keys in the compartment
+EOF
+  exit 1
+}
+
+ORG=""
+REPO=""
+COMPARTMENT=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --org) ORG="$2"; shift 2;;
+    --repo) REPO="$2"; shift 2;;
+    --compartment-ocid) COMPARTMENT="$2"; shift 2;;
+    -h|--help) usage;;
+    *) echo "Unknown arg: $1"; usage;;
+  esac
+done
+
+if [ -z "$ORG" ] || [ -z "$REPO" ] || [ -z "$COMPARTMENT" ]; then
+  usage
+fi
+
+ISSUER="https://token.actions.githubusercontent.com"
+SUBJECT="repo:${ORG}/${REPO}:ref:refs/heads/main"
+
+cat <<EOF
+=== OCI Identity Provider (manual console/API step) ===
+Provider Type: OIDC
+Issuer URL: $ISSUER
+(In OCI Console: Identity -> Identity Providers -> Add Identity Provider -> OIDC -> provide issuer URL)
+
+After creating the Identity Provider, note its OCID (IDENTITY_PROVIDER_OCID).
+
+=== OCI Dynamic Group Rule (create dynamic group) ===
+Rule (example):
+  ALL {request.principal.claims["iss"] = "$ISSUER" && request.principal.claims["sub"] = "$SUBJECT"}
+
+Create a dynamic group in OCI Console: Identity -> Dynamic Groups -> Create
+Paste the rule above. Name it: aegis-github-oidc-${ORG}-${REPO}
+
+=== Example OCI Policy Statements (apply in your tenancy) ===
+Replace <dynamic-group-name> with the name you used and <compartment> with your compartment OCID or name.
+
+  Allow dynamic-group aegis-github-oidc-${ORG}-${REPO} to use keys in compartment $COMPARTMENT
+  Allow dynamic-group aegis-github-oidc-${ORG}-${REPO} to inspect keys in compartment $COMPARTMENT
+
+Alternatively, to limit more specifically:
+  Allow dynamic-group aegis-github-oidc-${ORG}-${REPO} to use keys in compartment <compartment> where target.key.id = '<key_ocid>'
+
+=== EXCHANGE_CMD example for GitHub secret OCI_EXCHANGE_CMD ===
+When configuring CI, you will supply a secret OCI_EXCHANGE_CMD that will be executed by the runner with the GitHub OIDC token substituted for <<TOKEN>>.
+
+Example placeholder (operator must adapt and ensure OCI CLI is configured to consume STS):
+  OCI_EXCHANGE_CMD=\"oci sts create-sessions --assume-role-with-web-identity --web-identity-token '<<TOKEN>>' --duration-seconds 3600 --role-arn <role-arn>\"
+
+Note: OCI's exact STS/assume command depends on your tenancy; often you will configure an Identity Provider and a policy that maps OIDC tokens to a dynamic group; you may use the OCI CLI or a short-living session approach. Validate in a staging tenancy.
+
+=== Next steps ===
+1) Create the OIDC Identity Provider in OCI Console (use Issuer URL above).
+2) Create the Dynamic Group using the rule above.
+3) Create the policy statements in your tenancy to allow the dynamic group to use the KMS key.
+4) Provide OCI_EXCHANGE_CMD and OCI_KEY_URI as GitHub repo secrets (see the example above).
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/alibaba/generate_alibaba_oidc_role_policy.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# generate_alibaba_oidc_role_policy.sh
+# Generates RAM trust policy and RAM policy examples for Alibaba Cloud OIDC federation for GitHub Actions.
+#
+# Usage:
+#  ./generate_alibaba_oidc_role_policy.sh --org <github-org> --repo <github-repo> --role-name <role-name>
+#
+echo_usage() {
+  cat <<EOF
+Usage: $0 --org <github-org> --repo <github-repo> --role-name <role-name>
+
+Outputs:
+ - JSON trust policy to create an OIDC-linked RAM role (manual creation in console if desired)
+ - RAM policy example granting kms:Sign to the role
+ - Example EXCHANGE_CMD to place in GitHub secret ALICLOUD_EXCHANGE_CMD
+EOF
+  exit 1
+}
+
+ORG=""
+REPO=""
+ROLE_NAME=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --org) ORG="$2"; shift 2;;
+    --repo) REPO="$2"; shift 2;;
+    --role-name) ROLE_NAME="$2"; shift 2;;
+    -h|--help) echo_usage;;
+    *) echo "Unknown arg: $1"; echo_usage;;
+  esac
+done
+
+if [ -z "$ORG" ] || [ -z "$REPO" ] || [ -z "$ROLE_NAME" ]; then
+  echo_usage
+fi
+
+OIDC_ISSUER="https://token.actions.githubusercontent.com"
+SUBJECT="repo:${ORG}/${REPO}:ref:refs/heads/main"
+
+cat <<EOF
+=== Alibaba RAM OIDC Trust Policy (example) ===
+Use the Alibaba Console or aliyun CLI to create a RAM role that trusts OIDC tokens with provider 'https://token.actions.githubusercontent.com'
+Example trust policy (JSON):
+{
+  "Statement": [
+    {
+      "Action": "sts:AssumeRoleWithWebIdentity",
+      "Effect": "Allow",
+      "Principal": { "Federated": ["https://token.actions.githubusercontent.com"] },
+      "Condition": {
+        "StringEquals": { "token.actions.githubusercontent.com:sub": "$SUBJECT" }
+      }
+    }
+  ],
+  "Version": "1"
+}
+
+Create role name: $ROLE_NAME
+
+=== RAM Policy Example to grant KMS Sign permission ===
+Attach this policy to the role:
+{
+  "Statement": [
+    {
+      "Action": [
+        "kms:Sign",
+        "kms:GetPublicKey"
+      ],
+      "Effect": "Allow",
+      "Resource": [
+        "acs:kms:*:*:key/<your-key-id>"
+      ]
+    }
+  ],
+  "Version": "1"
+}
+
+=== EXCHANGE_CMD example (to store in GitHub secret ALICLOUD_EXCHANGE_CMD) ===
+Example (placeholder; operator must adapt to aliyun CLI usage and your environment):
+  ALICLOUD_EXCHANGE_CMD=\"aliyun sts AssumeRoleWithWebIdentity --WebIdentityToken '<<TOKEN>>' --RoleArn 'acs:ram::1234567890123456:role/$ROLE_NAME' --RoleSessionName gha-oidc --Output json\"
+
+=== Next steps ===
+1) Create OIDC-trusting RAM role in Alibaba using the trust policy above.
+2) Attach the RAM policy granting kms:Sign & kms:GetPublicKey to the role.
+3) Provide ALICLOUD_EXCHANGE_CMD and ALICLOUD_KEY_URI as GitHub repo secrets, then run the CI workflow to sign images.
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/ci_example_exchange_cmds.md
+# Example EXCHANGE_CMD strings for GitHub repo secrets
+
+These are example templates for the secrets OCI_EXCHANGE_CMD and ALICLOUD_EXCHANGE_CMD that the CI scripts in this repo expect. They contain the placeholder <<TOKEN>> which will be replaced by the GitHub Actions OIDC token by our exchange wrapper scripts.
+
+OCI example (placeholder — adapt to your OCI STS approach):
+  OCI_EXCHANGE_CMD="oci sts create-session-token --assume-role-with-web-identity --web-identity-token '<<TOKEN>>' --duration-seconds 3600 --role-arn ocid1.role.oc1..example"
+
+Alibaba example (placeholder — adapt to aliyun CLI):
+  ALICLOUD_EXCHANGE_CMD=\"aliyun sts AssumeRoleWithWebIdentity --WebIdentityToken '<<TOKEN>>' --RoleArn 'acs:ram::123456789:role/YourRole' --RoleSessionName gha-oidc --output json\"
+
+Notes
+- These are templates. Your tenancy's exact commands and arguments will vary. Use the provider console docs and tenancy-specific identifiers.
+- After storing the EXCHANGE_CMD secret, the CI exchange scripts (scripts/ci/oci_oidc_exchange.sh and scripts/ci/alibaba_oidc_exchange.sh) will run the command with the GitHub-provided OIDC token substituted in place of <<TOKEN>> and capture the provider response for downstream steps.
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/azure/README_MANUAL_STEPS.md
+# Azure manual steps (if automated CLI cannot be used)
+
+If your environment restricts automated creation of federated credentials via the CLI, follow these manual steps:
+
+1) Go to Azure AD > App registrations > New registration
+   - Name: aegis-github-federation-<org>-<repo>
+   - Supported account types: Single tenant
+2) Note the Application (client) ID — set it as AZURE_OIDC_CLIENT_ID repo secret.
+3) Under the App Registration > Federated credentials (or Certificates & secrets > Federated credentials), add:
+   - Name: gha-federation-<org>-<repo>
+   - Issuer: https://token.actions.githubusercontent.com
+   - Subject: repo:<org>/<repo>:ref:refs/heads/main
+   - Audience: api://AzureADTokenExchange
+4) Create a User Assigned Managed Identity in your resource group and grant it Key Vault key permissions (wrapKey, unwrapKey, get) for the Key Vault that holds your signing key.
+5) Create or note your Key Vault key URI (azurekms://<vaultname>.vault.azure.net/keys/<keyname>) and store it as AZURE_KEY_URI in GitHub secrets.
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/oci/README_MANUAL_STEPS.md
+# OCI manual steps (if console is preferred)
+
+1) In OCI Console: Identity -> Identity Providers -> Add Identity Provider
+   - Provider type: OpenID Connect
+   - Issuer: https://token.actions.githubusercontent.com
+   - Give it a name (e.g., aegis-github-oidc)
+2) Note Identity Provider OCID
+3) Create a Dynamic Group: Identity -> Dynamic Groups -> Create
+   - Name: aegis-github-oidc-<org>-<repo>
+   - Matching rule:
+       ALL {request.principal.claims["iss"] = "https://token.actions.githubusercontent.com" && request.principal.claims["sub"] = "repo:<org>/<repo>:ref:refs/heads/main"}
+4) Create an IAM Policy (Identity -> Policies) in your tenancy:
+   - Example:
+       Allow dynamic-group aegis-github-oidc-<org>-<repo> to use keys in compartment <compartment-name-or-ocid>
+5) Note your KMS key OCID and set OCI_KEY_URI in GitHub secrets (format depends on your usage; you can use cosign's oci KMS URI if applicable).
+
*** End Patch
*** Begin Patch
*** Add File:tenant-wiring/alibaba/README_MANUAL_STEPS.md
+# Alibaba manual steps (if console is preferred)
+
+1) In Alibaba Cloud Console, go to RAM -> Roles -> Create Role
+   - Choose "Web Identity Federation" or similar option (depends on account/console)
+   - Trust provider: https://token.actions.githubusercontent.com
+   - Trust condition: token.actions.githubusercontent.com:sub = repo:<org>/<repo>:ref:refs/heads/main
+2) Note the Role ARN
+3) Attach RAM policy to the role granting kms:Sign for your KMS key.
+4) Store ALICLOUD_KEY_URI (provider-specific key identifier) in GitHub secrets.
+5) Provide ALICLOUD_EXCHANGE_CMD in GitHub secrets (example in tenant-wiring/ci_example_exchange_cmds.md) which will be executed by the CI-run exchange wrapper to assume the role using the OIDC token.
+
*** End Patch
*** End Patch
