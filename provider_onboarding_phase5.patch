*** Begin Patch
*** Add File: credentials/encrypt_credentials.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Hybrid encryptor for provider credentials (operator-friendly)
+# - Encrypts a provider credentials JSON/YAML using AES-256-CBC with a random key
+# - Encrypts the AES key with an RSA public key (PEM) using OAEP
+# - Outputs:
+#     <in>.enc        => base64 AES-encrypted payload
+#     <in>.key.enc    => base64 RSA-encrypted AES key
+#
+# Usage:
+#   ./credentials/encrypt_credentials.sh --in provider_ibm.json --pubkey operator_pub.pem --out-dir ./secure_creds
+
+print_usage() {
+  cat <<EOF
+Usage: $0 --in <file> --pubkey <rsa_pub_pem> [--out-dir <dir>]
+
+Generates two files in out-dir:
+  - <basename>.enc       : base64 AES-encrypted payload
+  - <basename>.key.enc   : base64 RSA-OAEP-encrypted AES key (use operator private key to decrypt)
+
+Encryptor intended to securely hand credentials to an operator. Operator must decrypt
+the AES key using their RSA private key and then decrypt the payload.
+EOF
+}
+
+IN=""
+PUBKEY=""
+OUTDIR="./secure_creds"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --in) IN="$2"; shift 2;;
+    --pubkey) PUBKEY="$2"; shift 2;;
+    --out-dir) OUTDIR="$2"; shift 2;;
+    -h|--help) print_usage; exit 0;;
+    *) echo "Unknown arg: $1"; print_usage; exit 2;;
+  esac
+done
+
+if [ -z "$IN" ] || [ -z "$PUBKEY" ]; then
+  echo "Missing required args" >&2
+  print_usage
+  exit 2
+fi
+
+basename="$(basename "$IN")"
+name="${basename%.*}"
+mkdir -p "$OUTDIR"
+
+# generate random AES key
+aes_key_file="$(mktemp)"
+openssl rand -hex 32 > "$aes_key_file"
+AES_KEY_HEX="$(cat "$aes_key_file")"
+
+payload_enc="$OUTDIR/${name}.enc"
+key_enc="$OUTDIR/${name}.key.enc"
+
+# encrypt payload with AES-256-CBC using the hex key
+# openssl expects a passphrase; convert hex key to binary password via -K and -iv
+IV_HEX=$(openssl rand -hex 16)
+openssl enc -aes-256-cbc -K "$AES_KEY_HEX" -iv "$IV_HEX" -in "$IN" -out "${payload_enc}.bin"
+# store IV prefix so decryptor knows it; prepend IV to ciphertext
+cat <(echo -n "$IV_HEX") "${payload_enc}.bin" > "${payload_enc}.withiv"
+base64 "${payload_enc}.withiv" > "$payload_enc"
+rm -f "${payload_enc}.bin" "${payload_enc}.withiv"
+
+# encrypt AES key (hex) with RSA public key (OAEP)
+echo -n "$AES_KEY_HEX" > "${aes_key_file}.txt"
+openssl pkeyutl -encrypt -pubin -inkey "$PUBKEY" -in "${aes_key_file}.txt" -pkeyopt rsa_padding_mode:oaep -out "${key_enc}.bin"
+base64 "${key_enc}.bin" > "$key_enc"
+rm -f "${key_enc}.bin" "${aes_key_file}.txt" "$aes_key_file"
+
+echo "Encrypted payload -> $payload_enc"
+echo "Encrypted AES key -> $key_enc"
+echo "Deliver both to operator. Operator must decrypt key with RSA private key and then decrypt payload (IV+ciphertext)."
+
*** End Patch
*** Begin Patch
*** Add File: operator/bootstrap_from_tf_outputs.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# One-click operator bootstrap:
+#  - consumes terraform outputs JSON (or runs `terraform output -json`)
+#  - creates k8s secret vault-credentials (role_id / secret_id / addr)
+#  - optionally deploys the vault-token-rotator CronJob (k8s/cronjobs/vault-token-rotator-cronjob.yaml)
+#  - optionally waits for vault-credentials.secret to be updated
+#
+# Usage:
+#  ./operator/bootstrap_from_tf_outputs.sh --tf-json tf_out.json --vault-addr https://vault.example.com --deploy-rotator
+
+TF_JSON=""
+VAULT_ADDR=""
+NAMESPACE="aegis"
+SECRET_NAME="vault-credentials"
+DEPLOY_ROTATOR="false"
+WAIT_SEC=60
+
+usage() {
+  cat <<EOF
+Usage: $0 --tf-json <file> --vault-addr <addr> [--namespace <ns>] [--secret-name <name>] [--deploy-rotator] [--wait-sec N]
+EOF
+}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --tf-json) TF_JSON="$2"; shift 2;;
+    --vault-addr) VAULT_ADDR="$2"; shift 2;;
+    --namespace) NAMESPACE="$2"; shift 2;;
+    --secret-name) SECRET_NAME="$2"; shift 2;;
+    --deploy-rotator) DEPLOY_ROTATOR="true"; shift;;
+    --wait-sec) WAIT_SEC="$2"; shift 2;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$TF_JSON" ] || [ -z "$VAULT_ADDR" ]; then
+  echo "tf-json and vault-addr are required" >&2
+  usage
+  exit 2
+fi
+
+if [ ! -f "$TF_JSON" ]; then
+  echo "TF JSON file not found: $TF_JSON" >&2
+  exit 3
+fi
+
+ROLE_ID=$(jq -r '."approle_role_id".value' "$TF_JSON")
+SECRET_ID=$(jq -r '."approle_secret_id".value' "$TF_JSON")
+
+if [ -z "$ROLE_ID" ] || [ -z "$SECRET_ID" ] || [ "$ROLE_ID" = "null" ] || [ "$SECRET_ID" = "null" ]; then
+  echo "Terraform outputs missing approle_role_id/approle_secret_id" >&2
+  exit 4
+fi
+
+echo "Creating namespace $NAMESPACE if not exists..."
+kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "Creating kubernetes secret $SECRET_NAME in namespace $NAMESPACE..."
+kubectl delete secret "$SECRET_NAME" -n "$NAMESPACE" --ignore-not-found || true
+kubectl create secret generic "$SECRET_NAME" -n "$NAMESPACE" \
+  --from-literal=role_id="$ROLE_ID" \
+  --from-literal=secret_id="$SECRET_ID" \
+  --from-literal=addr="$VAULT_ADDR"
+
+echo "Secret created. If you prefer the rotator model, deploy the rotator CronJob next."
+
+if [ "$DEPLOY_ROTATOR" = "true" ]; then
+  echo "Applying vault-token-rotator CronJob manifest..."
+  kubectl apply -f k8s/cronjobs/vault-token-rotator-cronjob.yaml
+  echo "Waiting up to $WAIT_SEC seconds for vault-credentials to be updated with token..."
+  n=0
+  while [ $n -lt $((WAIT_SEC / 5)) ]; do
+    if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.token}' >/dev/null 2>&1; then
+      echo "Secret contains token (base64). Rotator likely executed."
+      break
+    fi
+    echo -n "."
+    sleep 5
+    n=$((n+1))
+  done
+  echo ""
+fi
+
+echo "Bootstrap complete. Provide the `vault-credentials` secret to the controller (mount environment or use secretKeyRef)."
+
*** End Patch
*** Begin Patch
*** Add File: staging/argo_sync_and_run_tests_wrapper.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Wrapper to:
+#  - log into ArgoCD (if ARGOCD_SERVER & ARGOCD_TOKEN are set)
+#  - sync all apps in argo/apps/*.yaml
+#  - call scripts/argo_sync_and_test.sh to run Redis failover & provider tests
+# Usage:
+#   ARGOCD_SERVER=... ARGOCD_TOKEN=... ./staging/argo_sync_and_run_tests_wrapper.sh
+
+ARGOCD_SERVER="${ARGOCD_SERVER:-}"
+ARGOCD_TOKEN="${ARGOCD_TOKEN:-}"
+RESULTS_DIR="${1:-./provider_staging_results}"
+
+if [ -n "$ARGOCD_SERVER" ] && [ -n "$ARGOCD_TOKEN" ]; then
+  if ! command -v argocd >/dev/null 2>&1; then
+    echo "argocd CLI not found; attempting to download..."
+    TMP_BIN="/tmp/argocd"
+    curl -sS -L "https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64" -o "$TMP_BIN"
+    chmod +x "$TMP_BIN"
+    sudo mv "$TMP_BIN" /usr/local/bin/argocd
+  fi
+  echo "Logging into ArgoCD server $ARGOCD_SERVER"
+  argocd login "$ARGOCD_SERVER" --token "$ARGOCD_TOKEN" --insecure
+fi
+
+echo "Syncing Argo apps from argo/apps/..."
+for f in argo/apps/*.yaml; do
+  appname="$(basename "$f" .yaml)"
+  echo "Attempting to sync app $appname..."
+  if command -v argocd >/dev/null 2>&1; then
+    argocd app sync "$appname" || echo "argocd sync failed for $appname"
+  else
+    echo "No argocd CLI; ensure ArgoCD auto-sync is enabled or use UI to sync $appname"
+  fi
+done
+
+echo "Calling existing argo_sync_and_test.sh to run infra checks and provider tests..."
+chmod +x scripts/argo_sync_and_test.sh
+./scripts/argo_sync_and_test.sh "$RESULTS_DIR"
+
+echo "Wrapper complete. Results in $RESULTS_DIR"
+
*** End Patch
*** Begin Patch
*** Add File: docs/credential_delivery_and_operator_instructions.md
+Credential delivery and operator instructions
+===========================================
+
+This document explains secure ways to deliver sandbox credentials and how an operator should
+bootstrap the Vault AppRole secret into Kubernetes and run the rotator / sync Argo apps.
+
+1) Encrypt credentials for operator handoff
+------------------------------------------
+ - Use credentials/encrypt_credentials.sh to encrypt provider credentials before sending to operator.
+ - Example:
+     ./credentials/encrypt_credentials.sh --in provider_ibm.json --pubkey operator_pub.pem --out-dir ./secure_creds
+ - Deliver both .enc and .key.enc files to operator out-of-band (e.g., secure SFTP).
+ - Operator decrypts AES key with their private RSA key and then decrypts the payload.
+
+2) Operator bootstrap (one-click)
+--------------------------------
+ - Operator receives terraform outputs from Vault admin (tf_out.json) or runs terraform.
+ - Run:
+     ./operator/bootstrap_from_tf_outputs.sh --tf-json tf_out.json --vault-addr https://vault.example.com --deploy-rotator
+ - This creates the `vault-credentials` k8s secret and deploys the token rotator CronJob which will generate short-lived tokens for controller runtime.
+
+3) Sync Argo apps and run staging tests
+---------------------------------------
+ - Ensure ArgoCD is configured and the apps in argo/apps/* are valid.
+ - Option A (ArgoCD UI): sync apps using UI.
+ - Option B (CLI & wrapper): provide ARGOCD_SERVER & ARGOCD_TOKEN and run:
+     ARGOCD_SERVER=... ARGOCD_TOKEN=... ./staging/argo_sync_and_run_tests_wrapper.sh
+ - The wrapper will sync apps and then run Redis failover and provider stress tests. Results will be in provider_staging_results.
+
+Security notes
+--------------
+ - Do not commit secrets to git. Use vault and the encryptor for secure handoff.
+ - Use sandbox/limited accounts for provider testing to avoid billing surprises.
+ - Remove any admin tokens after bootstrap; prefer the token rotator pattern.
+
*** End Patch
*** End Patch
