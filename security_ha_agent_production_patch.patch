*** Begin Patch
*** Add File: .github/workflows/ci_cosign_kms_rekor.yml
+name: CI: Build, SBOM, SCA, Sign with KMS (AWS example) & Rekor
+on:
+  push:
+    branches: [ main ]
+  pull_request:
+    branches: [ main ]
+
+permissions:
+  contents: read
+  id-token: write
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    env:
+      IMAGE: ${{ secrets.REGISTRY_HOST }}/aegis-model:${{ github.sha }}
+      REKOR_URL: ${{ secrets.REKOR_URL }}
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}    # set up OIDC IAM role that has access to KMS key
+          aws-region: ${{ secrets.AWS_REGION }}
+
+      - name: Build image
+        run: |
+          docker build -t "$IMAGE" -f services/serving/Dockerfile .
+
+      - name: Generate SBOM (syft)
+        run: |
+          syft "$IMAGE" -o json > sbom.json
+
+      - name: Scan (trivy)
+        run: |
+          trivy image --format json --output trivy.json "$IMAGE" || true
+
+      - name: Fail on critical CVEs
+        run: |
+          if jq '.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")' trivy.json >/dev/null 2>&1; then (echo "Critical CVE found"; jq . trivy.json; exit 1); else echo "No critical CVEs"; fi
+
+      - name: Login to registry
+        uses: docker/login-action@v2
+        with:
+          registry: ${{ secrets.REGISTRY_HOST }}
+          username: ${{ secrets.REGISTRY_USER }}
+          password: ${{ secrets.REGISTRY_TOKEN }}
+
+      - name: Push image
+        run: docker push "$IMAGE"
+
+      - name: Get image digest
+        id: digest
+        run: |
+          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" | awk -F@ '{print $2}')
+          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
+
+      - name: Sign image with AWS KMS (cosign)
+        env:
+          COSIGN_REKOR: ${{ secrets.REKOR_URL }}
+        run: |
+          # Using AWS KMS. The GitHub Actions OIDC -> IAM role must be able to use the KMS key.
+          # Set COSIGN_EXPERIMENTAL=1 if necessary for your cosign version.
+          cosign sign --key awskms://arn:aws:kms:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:key/${{ secrets.AWS_KMS_KEY_ID }} "${IMAGE}@${{ steps.digest.outputs.digest }}"
+
+      - name: Verify cosign signature & Rekor entry
+        run: |
+          cosign verify --policy /dev/null --rekor-url "$REKOR_URL" "${IMAGE}@${{ steps.digest.outputs.digest }}"
+
+      - name: Record manifest & SBOM artifact
+        run: |
+          mkdir -p artifacts
+          echo "${{ steps.digest.outputs.digest }}" > artifacts/image.digest
+          mv sbom.json artifacts/sbom.json || true
+          mv trivy.json artifacts/trivy.json || true
+          tar -czf artifacts.tar.gz artifacts || true
+          # optionally upload to COMPLIANCE_BUCKET via AWS CLI if configured
+          if [ -n "${{ secrets.COMPLIANCE_BUCKET }}" ]; then
+            aws s3 cp artifacts.tar.gz "${{ secrets.COMPLIANCE_BUCKET }}/ci-artifacts/${GITHUB_RUN_ID}.tar.gz"
+          fi
+
*** End Patch
*** Begin Patch
*** Add File: services/attestation/verify_service.py
+"""
+Attestation/Admission helper service.
+- Exposes a simple HTTP endpoint that validates container image attestation using cosign + Rekor.
+- Intended to be used by a ValidatingAdmissionWebhook which forwards admission requests here.
+"""
+import os
+import json
+import subprocess
+from flask import Flask, request, jsonify
+
+app = Flask("attestation")
+
+COSIGN_BIN = os.environ.get("COSIGN_BIN", "cosign")
+REKOR_URL = os.environ.get("REKOR_URL", "")
+
+def verify_image(image_ref):
+    cmd = [COSIGN_BIN, "verify", "--output", "json"]
+    if REKOR_URL:
+        cmd.extend(["--rekor-url", REKOR_URL])
+    cmd.append(image_ref)
+    try:
+        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
+        return True, json.loads(out)
+    except subprocess.CalledProcessError as e:
+        return False, {"error": e.output.decode()}
+
+@app.post("/verify")
+def verify():
+    body = request.get_json()
+    image = body.get("image")
+    if not image:
+        return jsonify({"ok": False, "error": "image required"}), 400
+    ok, info = verify_image(image)
+    return jsonify({"ok": ok, "info": info})
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 8443)))
+
*** End Patch
*** Begin Patch
*** Add File: k8s/webhook/attestation_webhook.yaml
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-attestation-webhook
+webhooks:
+  - name: attestation.aegis.local
+    sideEffects: None
+    admissionReviewVersions: ["v1","v1beta1"]
+    clientConfig:
+      service:
+        name: attestation
+        namespace: ops
+        path: /verify
+      caBundle: "" # fill with CA bundle of webhook server TLS cert if using TLS
+    rules:
+      - operations: ["CREATE","UPDATE"]
+        apiGroups: [""]
+        apiVersions: ["v1"]
+        resources: ["pods","deployments"]
+    failurePolicy: Fail
+    timeoutSeconds: 5
+
*** End Patch
*** Begin Patch
*** Add File: services/model_registry/db_postgres.py
+"""
+SQLAlchemy-based Postgres integration for model registry (production-ready replacement for sqlite).
+"""
+from sqlalchemy import create_engine, Column, String, Text, Integer
+from sqlalchemy.ext.declarative import declarative_base
+from sqlalchemy.orm import sessionmaker
+import os
+
+DATABASE_URL = os.environ.get("MODEL_REGISTRY_DATABASE_URL", "postgresql://aegis:aegis@postgres.aegis.svc.cluster.local:5432/aegis")
+
+Base = declarative_base()
+
+class Model(Base):
+    __tablename__ = "models"
+    id = Column(String, primary_key=True)
+    name = Column(String)
+    digest = Column(String)
+    metadata = Column(Text)
+    created_ts = Column(Integer)
+
+class Promotion(Base):
+    __tablename__ = "promotions"
+    id = Column(String, primary_key=True)
+    model_id = Column(String)
+    env = Column(String)
+    approvers = Column(Text)
+    ts = Column(Integer)
+
+engine = create_engine(DATABASE_URL, pool_size=20,
î€€
