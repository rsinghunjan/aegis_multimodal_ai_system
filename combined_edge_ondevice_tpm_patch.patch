*** Begin Patch
*** Add File: device/tpm2_pytss_impl.py
+#!/usr/bin/env python3
+"""
+TPM2 implementation using tpm2-pytss (scaffold).
+This implements a minimal device-side key generation and attestation production.
+On real hardware, adapt PCR selection and quote generation to your attestation policy.
+"""
+import os, json, base64, hashlib
+try:
+    from tpm2_pytss import *
+    HAVE_PYTSS = True
+except Exception:
+    HAVE_PYTSS = False
+
+def _sha256(s: str) -> str:
+    import hashlib
+    return hashlib.sha256(s.encode()).hexdigest()
+
+class TPM2PytssClient:
+    def __init__(self, device_id=None):
+        if not HAVE_PYTSS:
+            raise RuntimeError("tpm2-pytss not available on this host")
+        self.device_id = device_id or f"dev-{int(__import__('time').time())}"
+
+    def generate_key_and_attestation(self):
+        """
+        Minimal stub:
+        - generate or reference a key in TPM
+        - produce an attestation payload (quote)
+        Return (public_pem, attestation_blob_base64)
+        """
+        # TODO: implement using tpm2_pytss ESAPI calls to create persistent key and TPM2_Quote
+        pub_pem = "TPM2_PUBKEY_PLACEHOLDER"
+        payload = {"device_id": self.device_id, "pub_fingerprint": _sha256(pub_pem), "ts": int(__import__("time").time()), "note": "replace-with-real-quote"}
+        att = base64.b64encode(json.dumps(payload).encode()).decode()
+        return pub_pem, att
+
+    def verify_attestation(self, att_blob):
+        try:
+            payload = json.loads(base64.b64decode(att_blob).decode())
+            return {"ok": True, "payload": payload}
+        except Exception as e:
+            return {"ok": False, "error": str(e)}
+
*** End Patch
*** Begin Patch
*** Add File: device/enroll_device.py
+#!/usr/bin/env python3
+"""
+Device enrollment wrapper: prefer TPM2 implementation if available, fall back to emulator.
+"""
+import os, json, requests
+
+SIGNER_URL = os.environ.get("SIGNER_URL", "http://device-hsm-signer.operator.svc:8111/sign_device")
+OP_APPROVAL_HEADER = os.environ.get("OPERATOR_APPROVAL_HEADER", "1")
+OUT_DIR = os.environ.get("OUT_DIR", "/data")
+
+def _use_tpm2_client():
+    try:
+        from device.tpm2_pytss_impl import TPM2PytssClient
+        return TPM2PytssClient
+    except Exception:
+        return None
+
+def _use_emulator_client():
+    try:
+        from device.tpm_client import TPMClient
+        return TPMClient
+    except Exception:
+        return None
+
+def enroll(device_id=None):
+    ClientCls = _use_tpm2_client() or _use_emulator_client()
+    if ClientCls is None:
+        raise RuntimeError("No TPM client available")
+    client = ClientCls(device_id=device_id) if ClientCls is not None else None
+    # Support both method names used by emulator and tpm2 implementation
+    if hasattr(client, "generate_keypair_in_tpm"):
+        pub, att = client.generate_keypair_in_tpm()
+    else:
+        pub, att = client.generate_key_and_attestation()
+    payload = {"device_id": client.device_id, "public_key": pub, "attestation": att}
+    headers = {"X-Operator-Approved": OP_APPROVAL_HEADER}
+    r = requests.post(SIGNER_URL, json=payload, headers=headers, timeout=10)
+    if not r.ok:
+        raise RuntimeError(f"Sign request failed: {r.status_code} {r.text}")
+    resp = r.json()
+    signed_cert = resp.get("signature") or resp.get("cert")
+    os.makedirs(OUT_DIR, exist_ok=True)
+    with open(os.path.join(OUT_DIR, f"{client.device_id}.pub.pem"), "w") as f:
+        f.write(pub)
+    with open(os.path.join(OUT_DIR, f"{client.device_id}.signed.pem"), "w") as f:
+        f.write(signed_cert)
+    print("Enrollment successful:", client.device_id)
+    return client.device_id
+
+if __name__=="__main__":
+    import sys
+    device = enroll(sys.argv[1] if len(sys.argv) > 1 else None)
+    print("Device enrolled:", device)
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/edge_rotation_drill_ci.yml
+name: Edge Rotation Drill CI (staging run)
+on:
+  workflow_dispatch:
+    inputs:
+      total_devices:
+        required: false
+        default: "300"
+
+jobs:
+  rotation-drill:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup python
+        run: python -m pip install --upgrade pip && pip install requests boto3
+      - name: Trigger HSM rotation job in cluster
+        env:
+          KUBECONFIG: ${{ secrets.KUBECONFIG_STAGING }}
+          COMPLIANCE_BUCKET: ${{ secrets.COMPLIANCE_BUCKET }}
+        run: |
+          kubectl --kubeconfig="$KUBECONFIG" -n operator create job --from=cronjob/rotate-hsm-signing-key rotate-hsm-run-$(date +%s) || true
+          # wait a short time for job to start
+          sleep 5
+          echo "Rotation job triggered; check cluster for progress."
+      - name: Run fleet rotation simulator (invoke staging endpoints)
+        env:
+          SIGNER_URL: ${{ secrets.SIGNER_URL }}
+          ROTATION_CHECK_URL: ${{ secrets.ROTATION_CHECK_URL }}
+        run: |
+          python3 edge/fleet_rotation_simulator.py --total ${{ github.event.inputs.total_devices }} --signer_url "${SIGNER_URL}" --rotation_check_url "${ROTATION_CHECK_URL}"
+      - name: Collect evidence and upload
+        env:
+          COMPLIANCE_BUCKET: ${{ secrets.COMPLIANCE_BUCKET }}
+        run: |
+          python3 scripts/evidence_collector.py || true
+          python3 scripts/evidence_parser.py --s3-bucket "${COMPLIANCE_BUCKET}" --prefix "hsm/" || true
+
*** End Patch
