*** Begin Patch
*** Add File: scripts/aws_attach_strict_policies.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# aws_attach_strict_policies.sh
+# Create (if missing) least-privilege managed IAM policies for S3 backup and KMS usage,
+# attach them to an existing IAM role (IRSA role), and create a KMS grant for the role so
+# it can use the CMK for backups.
+#
+# Usage:
+#   ./scripts/aws_attach_strict_policies.sh --bucket my-bucket --kms-arn arn:aws:kms:... --role my-irsa-role --region us-west-2
+#
+BUCKET=""
+KMS_ARN=""
+ROLE_NAME=""
+AWS_REGION="${AWS_REGION:-}"
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --bucket) BUCKET="$2"; shift 2;;
+    --kms-arn) KMS_ARN="$2"; shift 2;;
+    --role) ROLE_NAME="$2"; shift 2;;
+    --region) AWS_REGION="$2"; shift 2;;
+    -h|--help) sed -n '1,200p' "$0"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$BUCKET" ] || [ -z "$KMS_ARN" ] || [ -z "$ROLE_NAME" ]; then
+  echo "Missing required args. See --help"
+  exit 2
+fi
+
+if [ -n "$AWS_REGION" ]; then
+  export AWS_REGION
+fi
+
+echo "[aws] Preparing policy documents"
+TMP_DIR=$(mktemp -d)
+S3_POLICY_TEMPLATE="infra/iam/aws/managed_policies/s3_backup_policy_prod_strict.json"
+KMS_POLICY_TEMPLATE="infra/iam/aws/managed_policies/kms_policy_prod_strict.json"
+S3_POLICY="$TMP_DIR/s3_policy.json"
+KMS_POLICY="$TMP_DIR/kms_policy.json"
+
+sed "s|YOUR_MILVUS_BACKUP_BUCKET|${BUCKET}|g; s|arn:aws:kms:REGION:ACCOUNT_ID:key/REPLACE_ME_KEY_ID|${KMS_ARN}|g" "$S3_POLICY_TEMPLATE" > "$S3_POLICY"
+sed "s|arn:aws:kms:REGION:ACCOUNT_ID:key/REPLACE_ME_KEY_ID|${KMS_ARN}|g" "$KMS_POLICY_TEMPLATE" > "$KMS_POLICY"
+
+echo "[aws] Create or reuse S3 managed policy"
+S3_NAME="AegisS3BackupPolicy-${BUCKET}"
+S3_POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='${S3_NAME}'].Arn | [0]" --output text 2>/dev/null || echo "")
+if [ -z "$S3_POLICY_ARN" ] || [ "$S3_POLICY_ARN" = "None" ]; then
+  S3_POLICY_ARN=$(aws iam create-policy --policy-name "$S3_NAME" --policy-document file://"$S3_POLICY" --query Policy.Arn --output text)
+  echo "[aws] Created S3 policy: $S3_POLICY_ARN"
+else
+  echo "[aws] Reusing existing S3 policy: $S3_POLICY_ARN"
+fi
+
+echo "[aws] Create or reuse KMS managed policy"
+KMS_NAME="AegisKMSBackupPolicy-${ROLE_NAME}"
+KMS_POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='${KMS_NAME}'].Arn | [0]" --output text 2>/dev/null || echo "")
+if [ -z "$KMS_POLICY_ARN" ] || [ "$KMS_POLICY_ARN" = "None" ]; then
+  KMS_POLICY_ARN=$(aws iam create-policy --policy-name "$KMS_NAME" --policy-document file://"$KMS_POLICY" --query Policy.Arn --output text)
+  echo "[aws] Created KMS policy: $KMS_POLICY_ARN"
+else
+  echo "[aws] Reusing existing KMS policy: $KMS_POLICY_ARN"
+fi
+
+echo "[aws] Attaching policies to IAM role ${ROLE_NAME}"
+aws iam attach-role-policy --role-name "$ROLE_NAME" --policy-arn "$S3_POLICY_ARN" || echo "[aws] attach-role-policy S3 failed or already attached"
+aws iam attach-role-policy --role-name "$ROLE_NAME" --policy-arn "$KMS_POLICY_ARN" || echo "[aws] attach-role-policy KMS failed or already attached"
+
+# Create a KMS grant so the role principal can use the key (idempotent-ish: grants are opaque; script will not duplicate)
+echo "[aws] Creating a KMS grant for role principal (so backups can use the CMK)"
+# Extract key-id from KMS ARN (last segment)
+KMS_KEY_ID="${KMS_ARN##*/}"
+ACCOUNT_ID=$(echo "$KMS_ARN" | awk -F: '{print $5}')
+ROLE_ARN="arn:aws:iam::${ACCOUNT_ID}:role/${ROLE_NAME}"
+
+if [ -n "$KMS_KEY_ID" ]; then
+  set +e
+  GRANT_JSON=$(aws kms create-grant --key-id "$KMS_KEY_ID" --grantee-principal "$ROLE_ARN" --operations Encrypt Decrypt GenerateDataKey ReEncryptFrom ReEncryptTo --name "AegisBackupGrant" 2>/dev/null)
+  if [ $? -eq 0 ]; then
+    echo "[aws] Created KMS grant for role $ROLE_ARN"
+  else
+    echo "[aws] KMS grant creation returned non-zero. It may already exist or permissions are missing. Please verify manually."
+  fi
+  set -e
+else
+  echo "[aws] Unable to determine KMS key id from ARN: $KMS_ARN"
+fi
+
+echo "[aws] Cleanup tmp files"
+rm -rf "$TMP_DIR"
+echo "[aws] Policy attachment complete. Review IAM console to confirm attachments and KMS grants."
+
*** End Patch
*** Add File: scripts/aws_verify_restore_integrity.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# aws_verify_restore_integrity.sh
+# Given an S3 bucket and prefix, list objects uploaded by backup, verify each object's size > 0,
+# and confirm encryption metadata (SSE-KMS) points to the expected KMS key. Download a sample file and
+# report checksums to help validate restore integrity.
+#
+# Usage:
+#   ./scripts/aws_verify_restore_integrity.sh --bucket my-bucket --prefix backups/2025... --expected-kms-arn arn:aws:kms:...
+#
+BUCKET=""
+PREFIX=""
+EXPECTED_KMS_ARN=""
+SAMPLE_COUNT=3
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --bucket) BUCKET="$2"; shift 2;;
+    --prefix) PREFIX="$2"; shift 2;;
+    --expected-kms-arn) EXPECTED_KMS_ARN="$2"; shift 2;;
+    --sample-count) SAMPLE_COUNT="$2"; shift 2;;
+    -h|--help) sed -n '1,200p' "$0"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$BUCKET" ] || [ -z "$PREFIX" ]; then
+  echo "Missing --bucket or --prefix"
+  exit 2
+fi
+
+echo "[aws-verify] Listing objects under s3://${BUCKET}/${PREFIX}"
+OBJ_LIST=$(aws s3api list-objects-v2 --bucket "$BUCKET" --prefix "$PREFIX" --query "Contents[].Key" --output text)
+if [ -z "$OBJ_LIST" ]; then
+  echo "[aws-verify] No objects found under prefix. Backup may have failed."
+  exit 1
+fi
+
+echo "[aws-verify] Verifying object metadata and sizes"
+OK=0
+TOTAL=0
+SAMPLE_TMP_DIR=$(mktemp -d)
+for key in $OBJ_LIST; do
+  TOTAL=$((TOTAL+1))
+  meta=$(aws s3api head-object --bucket "$BUCKET" --key "$key" --output json)
+  size=$(echo "$meta" | jq -r '.ContentLength // 0')
+  enc=$(echo "$meta" | jq -r '.SSEKMSKeyId // empty')
+  if [ "$size" -le 0 ]; then
+    echo "[aws-verify] ERROR: object ${key} size is ${size}"
+  else
+    echo "[aws-verify] OK: ${key} size=${size}"
+    OK=$((OK+1))
+  fi
+  if [ -n "$EXPECTED_KMS_ARN" ]; then
+    if [[ "$enc" == *"${EXPECTED_KMS_ARN##*/}"* || "$enc" == *"${EXPECTED_KMS_ARN}"* || "$enc" == "${EXPECTED_KMS_ARN}"* ]]; then
+      echo "[aws-verify] encryption: object ${key} uses expected KMS (SSEKMSKeyId=${enc})"
+    else
+      echo "[aws-verify] WARNING: object ${key} encryption KMS id (${enc:-none}) does not match expected (${EXPECTED_KMS_ARN})"
+    fi
+  fi
+done
+
+echo "[aws-verify] Verified $OK / $TOTAL objects for basic size checks"
+
+echo "[aws-verify] Downloading up to $SAMPLE_COUNT sample objects for checksum"
+i=0
+for key in $OBJ_LIST; do
+  if [ "$i" -ge "$SAMPLE_COUNT" ]; then break; fi
+  local_path="$SAMPLE_TMP_DIR/$(basename "$key")"
+  aws s3 cp "s3://${BUCKET}/${key}" "$local_path"
+  sha256sum "$local_path" || true
+  i=$((i+1))
+done
+
+echo "[aws-verify] Sample files downloaded to $SAMPLE_TMP_DIR. Use these artifacts to run Milvus restore in staging and validate application-level integrity."
+
*** End Patch
*** Add File: scripts/aws_tag_backup_objects.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# aws_tag_backup_objects.sh
+# Tag S3 objects under a prefix (e.g., backups/) with a key=value tag to enable chargeback/accounting.
+#
+# Usage:
+#   ./scripts/aws_tag_backup_objects.sh --bucket my-bucket --prefix backups/2025 --tag cost-center=test
+#
+BUCKET=""
+PREFIX=""
+TAG=""
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --bucket) BUCKET="$2"; shift 2;;
+    --prefix) PREFIX="$2"; shift 2;;
+    --tag) TAG="$2"; shift 2;;
+    -h|--help) sed -n '1,200p' "$0"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$BUCKET" ] || [ -z "$PREFIX" ] || [ -z "$TAG" ]; then
+  echo "Missing args"
+  exit 2
+fi
+
+KEY="${TAG%=*}"
+VALUE="${TAG#*=}"
+
+echo "[aws-tag] Listing objects under s3://${BUCKET}/${PREFIX}"
+OBJ_KEYS=$(aws s3api list-objects-v2 --bucket "$BUCKET" --prefix "$PREFIX" --query "Contents[].Key" --output text)
+if [ -z "$OBJ_KEYS" ]; then
+  echo "[aws-tag] No objects found under prefix"
+  exit 0
+fi
+
+for key in $OBJ_KEYS; do
+  echo "[aws-tag] Tagging object $key with $KEY=$VALUE"
+  aws s3api put-object-tagging --bucket "$BUCKET" --key "$key" --tagging "TagSet=[{Key=${KEY},Value=${VALUE}}]" || echo "[aws-tag] failed to tag $key"
+done
+
+echo "[aws-tag] Completed tagging objects"
+
*** End Patch
*** Add File: .github/workflows/aws_finalize_and_verify.yml
+name: AWS Finalize & Verify (attach policies, drill, verify)
+
+on:
+  workflow_dispatch:
+    inputs:
+      run_drill:
+        description: "Run the staging drill after attaching policies"
+        required: false
+        default: "true"
+
+permissions:
+  contents: read
+
+jobs:
+  aws-finalize:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Configure AWS credentials
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
+          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
+          aws-region: ${{ secrets.AWS_REGION }}
+
+      - name: Attach strict S3+KMS policies to IRSA role
+        env:
+          AWS_IRSA_ROLE_NAME: ${{ secrets.AWS_IRSA_ROLE_NAME }}
+          AWS_BACKUP_BUCKET: ${{ secrets.AWS_BACKUP_BUCKET }}
+          AWS_KMS_ARN: ${{ secrets.AWS_KMS_ARN }}
+        run: |
+          chmod +x scripts/aws_attach_strict_policies.sh
+          ./scripts/aws_attach_strict_policies.sh --bucket "${AWS_BACKUP_BUCKET}" --kms-arn "${AWS_KMS_ARN}" --role "${AWS_IRSA_ROLE_NAME}" --region "${{ secrets.AWS_REGION }}"
+
+      - name: Optionally run staging backup->restore drill
+        if: ${{ github.event.inputs.run_drill == 'true' }}
+        env:
+          STAGING_NAMESPACE: ${{ secrets.STAGING_NAMESPACE }}
+          AWS_BACKUP_CRONJOB: ${{ secrets.AWS_BACKUP_CRONJOB }}
+          AWS_BACKUP_BUCKET: ${{ secrets.AWS_BACKUP_BUCKET }}
+        run: |
+          chmod +x scripts/aws_backup_restore_drill.sh scripts/aws_verify_restore_integrity.sh scripts/aws_tag_backup_objects.sh
+          ./scripts/aws_backup_restore_drill.sh --namespace "${STAGING_NAMESPACE}" --backup-job "${AWS_BACKUP_CRONJOB}" --s3-bucket "${AWS_BACKUP_BUCKET}"
+          # Identify latest backup prefix (guarded)
+          LATEST_PREFIX=$(aws s3 ls "s3://${AWS_BACKUP_BUCKET}/backups/" --recursive | sort | tail -n 1 | awk '{print $4}' || true)
+          if [ -z "$LATEST_PREFIX" ]; then
+            echo "No backup object prefix discovered; aborting verification steps"
+            exit 1
+          fi
+          # Determine prefix directory containing the latest objects
+          PREFIX_DIR=$(dirname "$LATEST_PREFIX")
+          echo "Using detected prefix dir: ${PREFIX_DIR}"
+          ./scripts/aws_verify_restore_integrity.sh --bucket "${AWS_BACKUP_BUCKET}" --prefix "${PREFIX_DIR}" --expected-kms-arn "${{ secrets.AWS_KMS_ARN }}"
+          ./scripts/aws_tag_backup_objects.sh --bucket "${AWS_BACKUP_BUCKET}" --prefix "${PREFIX_DIR}" --tag "cost-center=${{ secrets.TEST_COST_CENTER }}"
+
+      - name: Report
+        run: echo "AWS finalize & verify workflow completed. Review logs/artifacts and perform Milvus restore in staging for application-level verification."
+
*** End Patch
*** Add File: docs/aws_finish_readme.md
+AWS Finalize to "Fully Supported" — README
+=========================================
+
+Purpose
+-------
+This README explains how to finish AWS support to "fully supported" status:
+- Attach least-privilege S3 + KMS policies to IRSA role
+- Create KMS grant so role can use CMK
+- Run a staging backup→restore drill
+- Verify object presence, sizes and encryption metadata
+- Tag backup objects for chargeback
+
+Quick start (manual)
+--------------------
+1. Ensure you have AWS credentials with permissions to create IAM policies, attach policies, create KMS grants, and access S3.
+2. Ensure KUBECONFIG is set and staging namespace + backup CronJob exist.
+3. Run:
+   ./scripts/aws_attach_strict_policies.sh --bucket my-milvus-backups --kms-arn arn:aws:kms:us-west-2:123... --role aegis-backup-irsa-role --region us-west-2
+4. Trigger a staging drill (locally):
+   ./scripts/aws_backup_restore_drill.sh --namespace aegis --backup-job aegis-milvus-backup --s3-bucket my-milvus-backups
+5. After drill completes, run verification:
+   # detect a prefix under backups/ (example)
+   ./scripts/aws_verify_restore_integrity.sh --bucket my-milvus-backups --prefix backups/20251201T... --expected-kms-arn arn:aws:kms:us-west-2:123...
+6. Tag backup objects for chargeback:
+   ./scripts/aws_tag_backup_objects.sh --bucket my-milvus-backups --prefix backups/20251201T... --tag cost-center=test
+
+Notes on verification
+---------------------
+- The scripts run basic checks: object listing, size > 0, SSE-KMS metadata presence and downloading sample objects to compute checksums.
+- Application-level restore tests (Milvus restore) must be executed manually using downloaded artifacts from the drill to fully validate data integrity.
+- Inspect KMS usage via KMS CloudTrail logs and S3 object metadata for encryption.
+
+CI Automation
+-------------
+- The included GitHub Actions workflow .github/workflows/aws_finalize_and_verify.yml performs the attach + drill + verify steps (when secrets are set).
+- Required repository secrets:
+  - AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY / AWS_REGION
+  - AWS_BACKUP_BUCKET
+  - AWS_KMS_ARN
+  - AWS_IRSA_ROLE_NAME
+  - AWS_BACKUP_CRONJOB
+  - STAGING_NAMESPACE
+  - TEST_COST_CENTER
+
+Security & safety
+-----------------
+- Creating KMS grants and IAM policies are sensitive operations. Review generated policy JSONs in infra/iam/aws/managed_policies before running scripts in production.
+- Run all steps in staging. Do NOT lock or delete keys until you have full signoff.
+
*** End Patch
*** End Patch
