*** Begin Patch
*** Add File:.github/workflows/image_build_cosign_oidc.yml
+name: Build, Push & Sign Image (OIDC + KMS)
+
+on:
+  push:
+    branches:
+      - main
+      - 'release/*'
+  workflow_dispatch:
+
+env:
+  IMAGE_REGISTRY: REPLACE_GHCR_ORG
+  IMAGE_NAME: aegis-quantum
+
+jobs:
+  build-push-sign:
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+      packages: write
+      id-token: write
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up QEMU
+        uses: docker/setup-qemu-action@v2
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v2
+
+      - name: Login to registry
+        uses: docker/login-action@v2
+        with:
+          registry: REPLACE_GHCR_HOST
+          username: ${{ github.actor }}
+          password: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Build and push image
+        uses: docker/build-push-action@v4
+        id: build
+        with:
+          context: .
+          file: docker/quantum/Dockerfile
+          push: true
+          tags: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
+
+      - name: Configure AWS credentials using OIDC (assume role)
+        if: ${{ secrets.AWS_ROLE_TO_ASSUME != '' }}
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+          aws-region: REPLACE_AWS_REGION
+          role-duration-seconds: 1200
+
+      - name: Install cosign
+        run: |
+          COSIGN_VERSION="v2.1.0"
+          curl -sSL -o /tmp/cosign.tar.gz "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-${COSIGN_VERSION}-linux-amd64.tar.gz"
+          tar -xzf /tmp/cosign.tar.gz -C /usr/local/bin cosign
+          cosign version
+
+      - name: Sign image with cosign using AWS KMS
+        id: cosign_sign
+        env:
+          COSIGN_KMS_ARN: ${{ secrets.COSIGN_KMS_ARN }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          IMAGE=${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
+          if [ -z "${COSIGN_KMS_ARN}" ]; then
+            echo "COSIGN_KMS_ARN not set; skipping signing"
+            exit 1
+          fi
+          cosign sign --key "awskms://${COSIGN_KMS_ARN}" --rekor-server "${REKOR_URL}" "${IMAGE}"
+
+      - name: Verify signature and Rekor entry
+        env:
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          IMAGE=${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
+          cosign verify --rekor-server "${REKOR_URL}" "${IMAGE}"
+          echo "Image signed and Rekor entry created/verified."
+
+      - name: Upload image tag as artifact
+        uses: actions/upload-artifact@v4
+        with:
+          name: pushed-image
+          path: |
+            <<<'${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}'
+
*** End Patch
*** Begin Patch
*** Add File:ops/gitops-promoter-configmap.yaml
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: gitops-promoter-scripts
+  namespace: aegis
+data:
+  promote_to_gitops.sh: |
+    #!/usr/bin/env bash
+    set -euo pipefail
+    # promote_to_gitops.sh: update kustomize overlay in GitOps repo and open a PR
+    # Usage: promote_to_gitops.sh <gitops_repo> <branch> <image> <base_branch>
+    REPO=${1:?gitops repo required}
+    BRANCH=${2:-"promote-$(date +%s)"}
+    IMAGE=${3:?image required}
+    BASE=${4:-main}
+
+    if [ -z "${GITHUB_TOKEN:-}" ]; then
+      echo "GITHUB_TOKEN missing; cannot push or create PR"
+      exit 2
+    fi
+
+    TMPDIR=$(mktemp -d)
+    git clone "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}" "${TMPDIR}"
+    cd "${TMPDIR}"
+    git checkout -b "${BRANCH}"
+    KUSTOMIZE_PATH="overlays/staging/kustomization.yaml"
+    if [ -f "${KUSTOMIZE_PATH}" ]; then
+      sed -i "s|newTag: .*|newTag: \"${IMAGE##*:}\"|g" "${KUSTOMIZE_PATH}" || true
+      sed -i "s|newName: .*|newName: \"${IMAGE%%:*}\"|g" "${KUSTOMIZE_PATH}" || true
+    else
+      echo "Kustomize overlay not found at ${KUSTOMIZE_PATH}; aborting"
+      exit 3
+    fi
+    git add "${KUSTOMIZE_PATH}"
+    git commit -m "chore: promote image ${IMAGE} to staging"
+    git push origin "${BRANCH}"
+    gh pr create --repo "${REPO}" --title "Promote image ${IMAGE} to staging" --body "Automated promotion PR" --head "${BRANCH}" --base "${BASE}"
+    echo "Promotion PR created"
+
*** End Patch
*** Begin Patch
*** Add File:ops/gitops-promoter-deployment.yaml
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: gitops-promoter
+  namespace: aegis
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: gitops-promoter
+  namespace: aegis
+rules:
+  - apiGroups: [""]
+    resources: ["pods", "pods/log", "configmaps"]
+    verbs: ["get", "create", "list", "watch"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: gitops-promoter-binding
+  namespace: aegis
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: Role
+  name: gitops-promoter
+subjects:
+  - kind: ServiceAccount
+    name: gitops-promoter
+    namespace: aegis
+
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: gitops-promoter
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: gitops-promoter
+  template:
+    metadata:
+      labels:
+        app: gitops-promoter
+    spec:
+      serviceAccountName: gitops-promoter
+      containers:
+        - name: promoter
+          image: ghcr.io/cli/cli:latest
+          command: ["/bin/sh","-c"]
+          env:
+            - name: GITHUB_TOKEN
+              valueFrom:
+                secretKeyRef:
+                  name: gitops-promoter-secret
+                  key: github_token
+            - name: GITOPS_REPO
+              value: "REPLACE_GITOPS_REPO"
+          volumeMounts:
+            - name: scripts
+              mountPath: /opt/promoter
+          workingDir: /opt/promoter
+          args:
+            - |
+              chmod +x /opt/promoter/promote_to_gitops.sh
+              # Example loop: watch a ConfigMap or trigger via API (placeholder)
+              while true; do
+                sleep 300
+              done
+      volumes:
+        - name: scripts
+          configMap:
+            name: gitops-promoter-scripts
+
+---
+# Secret must be created by operator (do not commit)
+# kubectl -n aegis create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}"
+
*** End Patch
*** Begin Patch
*** Add File:ops/metric-proxy-configmap.yaml
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: metric-proxy-scripts
+  namespace: aegis
+data:
+  proxy.py: |
+    #!/usr/bin/env python3
+    # Simple Prometheus proxy for internal use by Argo workflows.
+    # Exposes /api/v1/query?query=... and forwards to PROMETHEUS_URL.
+    from flask import Flask, request, Response, abort
+    import os, requests
+
+    PROM_URL = os.environ.get("PROMETHEUS_URL", "http://prometheus-operated.monitoring.svc:9090")
+    app = Flask(__name__)
+
+    @app.route("/api/v1/query")
+    def query():
+        q = request.args.get("query")
+        if not q:
+            abort(400, "query param required")
+        r = requests.get(f"{PROM_URL}/api/v1/query", params={"query": q}, timeout=10)
+        return Response(r.content, status=r.status_code, content_type=r.headers.get('Content-Type','application/json'))
+
+    @app.route("/health")
+    def health():
+        return "ok", 200
+
+    if __name__ == "__main__":
+        app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))
+
*** End Patch
*** Begin Patch
*** Add File:ops/metric-proxy-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: metric-proxy
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: metric-proxy
+  template:
+    metadata:
+      labels:
+        app: metric-proxy
+    spec:
+      containers:
+        - name: proxy
+          image: python:3.10-slim
+          command: ["/bin/sh","-c"]
+          args:
+            - |
+              apt-get update && apt-get install -y gcc libpq-dev curl && pip install flask requests && \
+              chmod +x /opt/proxy/proxy.py && python /opt/proxy/proxy.py
+          env:
+            - name: PROMETHEUS_URL
+              value: "REPLACE_PROMETHEUS_INTERNAL_URL" # e.g. http://prometheus-operated.monitoring.svc:9090
+          volumeMounts:
+            - name: scripts
+              mountPath: /opt/proxy
+          ports:
+            - containerPort: 8080
+      volumes:
+        - name: scripts
+          configMap:
+            name: metric-proxy-scripts
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: metric-proxy
+  namespace: aegis
+spec:
+  selector:
+    app: metric-proxy
+  ports:
+    - port: 8080
+      targetPort: 8080
+      protocol: TCP
+  type: ClusterIP
+
*** End Patch
*** Begin Patch
*** Add File:argo/rollout_promote_workflow_metricproxy.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Workflow
+metadata:
+  generateName: canary-monitor-promote-
+  namespace: aegis
+spec:
+  entrypoint: monitor-and-promote
+  arguments:
+    parameters:
+      - name: metric-proxy-url
+        value: "http://metric-proxy.aegis.svc.cluster.local:8080"
+      - name: query-latency
+        value: 'histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+      - name: latency-threshold
+        value: "0.5"
+      - name: gitops-repo
+        value: "REPLACE_GITOPS_REPO"
+      - name: image
+        value: "REPLACE_GHCR_ORG/aegis-quantum:REPLACE_IMAGE_TAG"
+
+  templates:
+    - name: monitor-and-promote
+      steps:
+        - - name: query-metrics
+            template: metric-proxy-query
+            arguments:
+              parameters:
+                - name: proxy-url
+                  value: "{{workflow.parameters.metric-proxy-url}}"
+                - name: query
+                  value: "{{workflow.parameters.query-latency}}"
+        - - name: decide
+            template: decide-and-promote
+
+    - name: metric-proxy-query
+      inputs:
+        parameters:
+          - name: proxy-url
+          - name: query
+      container:
+        image: curlimages/curl:7.86.0
+        command: ["/bin/sh","-c"]
+        args:
+          - |
+            q=$(printf "%s" "{{inputs.parameters.query}}" | sed 's/ /%20/g')
+            url="{{inputs.parameters.proxy-url}}/api/v1/query?query=${q}"
+            echo "Querying metric-proxy: ${url}"
+            curl -s "${url}" | jq '.' > /tmp/prom_res.json
+            cat /tmp/prom_res.json
+            val=$(cat /tmp/prom_res.json | jq -r '.data.result[0].value[1] // "9999"')
+            echo "latency=${val}" > /tmp/metrics.txt
+            cp /tmp/metrics.txt /tmp/output_metrics.txt
+      outputs:
+        artifacts:
+          - name: metrics
+            path: /tmp/output_metrics.txt
+
+    - name: decide-and-promote
+      container:
+        image: bitnami/kubectl:1.28
+        command: ["/bin/sh","-c"]
+        args:
+          - |
+            set -e
+            if [ ! -f /tmp/metrics.txt ]; then
+              echo "Metrics file missing; aborting"
+              exit 2
+            fi
+            latency=$(cat /tmp/metrics.txt | sed 's/latency=//')
+            echo "Latency read: ${latency}"
+            thr={{workflow.parameters.latency-threshold}}
+            awk -v l="${latency}" -v t="${thr}" 'BEGIN{ if (l+0 <= t+0) exit 0; else exit 1 }'
+            if [ $? -eq 0 ]; then
+              echo "Latency OK; promoting canary to stable"
+              /opt/promote/promote_to_gitops.sh "{{workflow.parameters.gitops-repo}}" "promote-$(date +%s)" "{{workflow.parameters.image}}" "main"
+            else
+              echo "Latency too high; not promoting. Consider rollback."
+              exit 1
+            fi
+      volumeMounts:
+        - name: promote-scripts
+          mountPath: /opt/promote
+
+  volumes:
+    - name: promote-scripts
+      configMap:
+        name: gitops-promoter-scripts
+
*** End Patch
*** Begin Patch
*** Add File:docs/operator_automation_final.md
+# Aegis — Final Automation Runbook (one-page)
+
+Goal
+- Enable fully automated CI → build → sign → Argo training → GitOps promotion → Canary monitor → auto-promote flows for Aegis, in a secure and auditable way.
+
+Prerequisites (operator)
+- Kubernetes cluster with Argo Workflows and ArgoCD installed.
+- GitHub repo: owner/repo and a GitOps repo (overlays) accessible via GITHUB_TOKEN.
+- Container registry (GHCR or other) where Actions can push images.
+- Prometheus deployed in cluster and reachable via cluster DNS.
+- Secrets / Permissions:
+  - GitHub repo secrets:
+    - COSIGN_KMS_ARN (awskms key id for cosign signing)
+    - REKOR_URL (if using Rekor)
+    - AWS_ROLE_TO_ASSUME (optional; for OIDC-based signing in Actions)
+    - EVIDENCE_BUCKET (S3)
+    - MLFLOW_TRACKING_URI
+    - GITHUB_TOKEN (for promoter; store in k8s secret)
+
+Quick operator steps
+1) Create local tfvars and apply IRSA:
+   cp terraform/irsa/placeholder.tfvars.example terraform/irsa/my.tfvars
+   # edit my.tfvars (do not commit)
+   cd terraform/irsa
+   terraform init && terraform apply -var-file=my.tfvars
+
+2) Create GitHub secrets (example using gh):
+   gh secret set COSIGN_KMS_ARN --repo owner/repo --body "<KMS_ARN>"
+   gh secret set REKOR_URL --repo owner/repo --body "https://rekor.example.com"
+   gh secret set AWS_ROLE_TO_ASSUME --repo owner/repo --body "arn:aws:iam::123:role/ci-cosign-role"
+   gh secret set EVIDENCE_BUCKET --repo owner/repo --body "aegis-evidence-12345"
+   gh secret set MLFLOW_TRACKING_URI --repo owner/repo --body "https://mlflow.example.com"
+
+3) Deploy metric-proxy and promoter components in cluster:
+   kubectl apply -f ops/metric-proxy-configmap.yaml
+   kubectl apply -f ops/metric-proxy-deployment.yaml
+   kubectl apply -f ops/gitops-promoter-configmap.yaml
+   kubectl apply -f ops/gitops-promoter-deployment.yaml
+   # Create k8s secret for promoter with GitHub token:
+   kubectl -n aegis create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}"
+
+4) Install ArgoCD application for GitOps (edit placeholders):
+   kubectl apply -f gitops/argocd/application-staging.yaml
+
+5) Enable CI image build & sign:
+   - The Actions workflow .github/workflows/image_build_cosign_oidc.yml will build, push and sign images using COSIGN_KMS_ARN (awskms).
+   - If using OIDC/assume role, set AWS_ROLE_TO_ASSUME secret to allow Actions to assume a role that can use the KMS key.
+
+6) Test full flow (dry run)
+   - Push code to main or dispatch workflow; check Actions builds & cosign sign.
+   - Run Argo demo workflow:
+       argo submit -n aegis demo/e2e_auto_workflow.yaml
+   - Manually run promote script (operator) to create a promotion PR:
+       ./ops/promote_to_gitops.sh <gitops-repo> promote-branch <IMAGE> main
+   - Merge PR and confirm ArgoCD auto-sync deploys to cluster.
+   - Start canary monitor:
+       argo submit -n aegis argo/rollout_promote_workflow_metricproxy.yaml
+
+Acceptance criteria
+- CI builds images, pushes and cosign signs automatically; cosign verify succeeds.
+- Promotion PRs are created and when merged, ArgoCD auto-sync deploys updated overlay to staging.
+- Canary monitor reads metrics via metric-proxy and promotes image automatically if SLOs met.
+- All automated runs produce audit artifacts in S3 (MLflow run + signed model tar + audit JSON).
+
+Security reminders
+- Never store secrets in git; use GitHub Secrets and k8s ExternalSecrets when possible.
+- Restrict AWS KMS key usage to the minimal role and require CMK key policy to restrict signing principals.
+- Limit who can merge promotion PRs via branch protection rules.
+
*** End Patch
*** End Patch
