*** Begin Patch
*** Add File:ops/run_full_apply_irsa.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run Terraform IRSA apply and annotate ServiceAccounts with role ARNs.
+# Usage:
+#   cd repo-root
+#   cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars
+#   # edit terraform/irsa/my.tfvars locally (do NOT commit)
+#   ./ops/run_full_apply_irsa.sh terraform/irsa/my.tfvars
+
+TFVARS=${1:-terraform/irsa/my.tfvars}
+
+if [ ! -f "${TFVARS}" ]; then
+  echo "Missing tfvars: ${TFVARS}"
+  exit 2
+fi
+
+echo "Running Terraform IRSA apply..."
+bash terraform/irsa/apply_irsa.sh "${TFVARS}"
+
+echo "Annotating service accounts (IRSA)..."
+if [ -f /tmp/irsa_outputs.json ]; then
+  bash terraform/irsa/irsa_annotate_sa.sh /tmp/irsa_outputs.json
+else
+  echo "/tmp/irsa_outputs.json not found - ensure terraform produced outputs and rerun annotation manually."
+fi
+
+echo "IRSA apply and SA annotation complete."
+
*** End Patch
*** Begin Patch
*** Add File:ops/provision_secrets_and_externalsecrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Provision GitHub repository secrets (via gh) and apply ExternalSecrets manifests to Kubernetes.
+# You must export required environment variables before running:
+#   export REPO="owner/repo"
+#   export COSIGN_KMS_ARN="arn:aws:kms:..."
+#   export REKOR_URL="https://rekor.example.com"
+#   export EVIDENCE_BUCKET="aegis-evidence-123"
+#   export MLFLOW_TRACKING_URI="https://mlflow.example.com"
+#   export AWS_ROLE_TO_ASSUME="arn:aws:iam::123:role/ci-oidc-role"    # optional
+#   export PROVIDER_API_KEYS_JSON='{"ibm_api_key":"...","azure_client_id":"..."}'  # optional, do NOT commit
+#   export NAMESPACE=${NAMESPACE:-aegis}
+
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+NAMESPACE=${NAMESPACE:-aegis}
+
+required=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI)
+for v in "${required[@]}"; do
+  if [ -z "${!v:-}" ]; then
+    echo "Environment variable ${v} not set. Please export it before running."
+    exit 2
+  fi
+done
+
+echo "Creating GitHub secrets in ${REPO}..."
+gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+gh secret set EVIDENCE_BUCKET --repo "${REPO}" --body "${EVIDENCE_BUCKET}"
+gh secret set MLFLOW_TRACKING_URI --repo "${REPO}" --body "${MLFLOW_TRACKING_URI}"
+if [ -n "${AWS_ROLE_TO_ASSUME:-}" ]; then
+  gh secret set AWS_ROLE_TO_ASSUME --repo "${REPO}" --body "${AWS_ROLE_TO_ASSUME}"
+fi
+
+echo "Creating optional provider keys secret in GitHub (if provided)"
+if [ -n "${PROVIDER_API_KEYS_JSON:-}" ]; then
+  gh secret set PROVIDER_API_KEYS_JSON --repo "${REPO}" --body "${PROVIDER_API_KEYS_JSON}"
+fi
+
+echo "Applying ExternalSecrets SecretStore and ExternalSecret manifests (ensure ExternalSecrets operator is installed)"
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/secretstore.aws.yaml
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/externalsecret_runtime_values.yaml
+
+echo "Provisioning complete. Verify GitHub secrets and ExternalSecrets resources."
+echo "GitHub secrets: https://github.com/${REPO}/settings/secrets/actions"
+echo "Kubernetes ExternalSecrets: kubectl -n ${NAMESPACE} get externalsecret"
+
*** End Patch
*** Begin Patch
*** Add File:ops/validate_ci_registry_permissions.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Validate that CI role (AWS_ROLE_TO_ASSUME) can push to ECR and use KMS for cosign signing.
+# Requires awscli and jq installed on operator machine and proper permissions to assume the role via STS.
+#
+# Usage:
+#   export AWS_ROLE_TO_ASSUME="arn:aws:iam::123:role/ci-oidc-role"
+#   export ECR_REGISTRY="123456789012.dkr.ecr.us-east-1.amazonaws.com"
+#   export KMS_KEY_ARN="arn:aws:kms:us-east-1:123456789012:key/abcd..."
+#   ./ops/validate_ci_registry_permissions.sh
+
+ROLE=${AWS_ROLE_TO_ASSUME:-}
+ECR_REGISTRY=${ECR_REGISTRY:-}
+KMS_KEY_ARN=${KMS_KEY_ARN:-}
+
+if [ -z "${ROLE}" ]; then
+  echo "AWS_ROLE_TO_ASSUME must be set for validation (export AWS_ROLE_TO_ASSUME=...)"
+  exit 2
+fi
+
+echo "Attempting assume-role (requires operator AWS creds configured)"
+CREDS_JSON=$(aws sts assume-role --role-arn "${ROLE}" --role-session-name aegis-ci-test --duration-seconds 900 2>/dev/null) || { echo "AssumeRole failed; ensure your caller can assume ${ROLE}"; exit 3; }
+ACCESS_KEY=$(echo "${CREDS_JSON}" | jq -r '.Credentials.AccessKeyId')
+SECRET_KEY=$(echo "${CREDS_JSON}" | jq -r '.Credentials.SecretAccessKey')
+SESSION_TOKEN=$(echo "${CREDS_JSON}" | jq -r '.Credentials.SessionToken')
+
+export AWS_ACCESS_KEY_ID="${ACCESS_KEY}"
+export AWS_SECRET_ACCESS_KEY="${SECRET_KEY}"
+export AWS_SESSION_TOKEN="${SESSION_TOKEN}"
+
+if [ -n "${ECR_REGISTRY}" ]; then
+  echo "Validating ECR push permissions (attempt to get authorization token)"
+  aws ecr get-authorization-token --registry-ids "$(echo ${ECR_REGISTRY} | cut -d. -f1)" >/dev/null && echo "ECR auth success" || echo "ECR auth failed (check role permissions)"
+fi
+
+if [ -n "${KMS_KEY_ARN}" ]; then
+  echo "Validating KMS describe & sign-like permissions (kms:DescribeKey)"
+  aws kms describe-key --key-id "${KMS_KEY_ARN}" >/dev/null && echo "KMS DescribeKey OK" || echo "KMS DescribeKey failed (check key policy)"
+fi
+
+echo "Permission validation complete. Clear temporary AWS env credentials now."
+unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_runtime_services.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install runtime services required by Aegis:
+# - Argo Workflows
+# - ArgoCD
+# - Prometheus (kube-prometheus-stack via Helm)
+# - ExternalSecrets operator (via Helm)
+# - Istio/Knative (service mesh)
+#
+# Usage:
+#   ./ops/install_runtime_services.sh
+
+echo "Install Argo Workflows (manifest)..."
+kubectl create namespace argo --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/stable/manifests/install.yaml
+
+echo "Install ArgoCD (Helm wrapper)"
+bash ops/install_argocd_helm.sh
+
+echo "Install Prometheus (kube-prometheus-stack via Helm)"
+helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
+helm repo update
+kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install prometheus prometheus-community/kube-prometheus-stack -n monitoring --wait
+
+echo "Install ExternalSecrets operator (Helm)"
+helm repo add external-secrets https://external-secrets.github.io/kubernetes-external-secrets/ || true
+helm repo update
+kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install external-secrets external-secrets/kubernetes-external-secrets -n external-secrets --wait
+
+echo "Install Istio (demo) and/or Knative if desired"
+echo "Running Istio install (demo profile)..."
+bash istio/install_istio.sh || true
+echo "Installing Knative (optional) ..."
+bash knative/install_knative.sh || true
+
+echo "Runtime services installation complete."
+
*** End Patch
*** Begin Patch
*** Add File:ops/deploy_metric_proxy_and_promoter.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Deploy metric-proxy (ConfigMap + Deployment + Service) and promoter (ConfigMap + Deployment + SA).
+# Create in-cluster GitHub secret for promoter if GITHUB_TOKEN env var present.
+#
+# Usage:
+#   export GITHUB_TOKEN="ghp_..."
+#   ./ops/deploy_metric_proxy_and_promoter.sh
+
+NAMESPACE=${NAMESPACE:-aegis}
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "Applying metric-proxy config and deployment..."
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-deployment.yaml
+
+echo "Applying gitops-promoter config and deployment..."
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-deployment.yaml
+
+if [ -n "${GITHUB_TOKEN:-}" ]; then
+  echo "Creating gitops-promoter secret in cluster..."
+  kubectl -n "${NAMESPACE}" create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}" --dry-run=client -o yaml | kubectl apply -f -
+  echo "Promoter secret created."
+else
+  echo "GITHUB_TOKEN not set. Create the gitops-promoter-secret in namespace ${NAMESPACE} manually before promoter can create PRs."
+fi
+
+echo "Metric-proxy and promoter deployed."
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_gatekeeper_and_protect_branch.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Gatekeeper and apply constraints then configure GitHub branch protection.
+#
+# Usage:
+#   export REPO="owner/repo"
+#   export TARGET_BRANCH="main"
+#   export GITHUB_TOKEN="ghp_..."
+#   ./ops/install_gatekeeper_and_protect_branch.sh
+
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${TARGET_BRANCH:-main}
+
+echo "Installing Gatekeeper..."
+kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+sleep 5
+kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml || true
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping branch protection configuration. Set GITHUB_TOKEN and re-run to apply branch protection."
+  exit 0
+fi
+
+echo "Configuring branch protection for ${REPO}:${BRANCH}"
+required_contexts='["sanitizer","ci_train_validate_register","image_build_cosign"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Gatekeeper installed and branch protection configured."
+
*** End Patch
*** Begin Patch
*** Add File:ops/upload_legal_signoff_and_enforce_checks.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Upload a legal signoff file to the evidence S3 bucket and configure CI checks to block merges until sanitizer passes.
+#
+# Usage:
+#   export EVIDENCE_BUCKET="aegis-evidence-123"
+#   export REPO="owner/repo"
+#   export BRANCH="main"
+#   export GITHUB_TOKEN="ghp_..."
+#   ./ops/upload_legal_signoff_and_enforce_checks.sh path/to/legal_signoff.md
+
+FILE=${1:?path to legal signoff file required}
+EVIDENCE_BUCKET=${EVIDENCE_BUCKET:-REPLACE_EVIDENCE_BUCKET}
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+if [ ! -f "${FILE}" ]; then
+  echo "Legal signoff file not found: ${FILE}"
+  exit 2
+fi
+
+echo "Uploading ${FILE} to s3://${EVIDENCE_BUCKET}/legal_signoff/"
+aws s3 cp "${FILE}" "s3://${EVIDENCE_BUCKET}/legal_signoff/$(basename "${FILE}")"
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping GitHub branch protection modification. Set GITHUB_TOKEN and re-run to enforce CI checks."
+  exit 0
+fi
+
+echo "Enforcing sanitizer and CI checks on branch ${BRANCH} in ${REPO}"
+required_contexts='["sanitizer","ci_train_validate_register","secret-and-deploy-preflight"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Legal signoff uploaded and CI checks enforced on ${REPO}:${BRANCH}."
+
*** End Patch
*** Begin Patch
*** Add File:ops/tune_slos_and_validate_budget.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Tune SLO thresholds in the aegis-slo-config ConfigMap and run simple validations.
+#
+# Usage:
+#   ./ops/tune_slos_and_validate_budget.sh 0.5 0.02 60
+#   args: p95_threshold_seconds error_rate_threshold success_window_minutes
+
+P95=${1:-0.5}
+ERROR_RATE=${2:-0.02}
+WINDOW=${3:-60}
+
+echo "Patching SLO ConfigMap with p95=${P95}, error_rate=${ERROR_RATE}, window=${WINDOW}m"
+kubectl -n aegis create configmap aegis-slo-config --from-literal=p95_latency_threshold_seconds="${P95}" --from-literal=canary_error_rate_threshold="${ERROR_RATE}" --from-literal=canary_success_window_minutes="${WINDOW}" -o yaml --dry-run=client | kubectl apply -f -
+
+echo "Running sanity metric query via metric-proxy (if available)"
+METRIC_PROXY_URL=${METRIC_PROXY_URL:-http://metric-proxy.aegis.svc.cluster.local:8080}
+QUERY='histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+ENCODED_QUERY=$(python3 - <<PY
+import urllib.parse, sys
+print(urllib.parse.quote('''${QUERY}'''))
+PY
+)
+curl -s "${METRIC_PROXY_URL}/api/v1/query?query=${ENCODED_QUERY}" | jq .
+
+echo "Run cost/budget validation (placeholder): ensure cost estimator returns acceptable estimate before launching expensive jobs."
+echo "If you have a cost-estimator script, run it now and ensure the estimate is below sandbox budget."
+
*** End Patch
*** Begin Patch
*** Add File:docs/ops_platform_final_steps.md
+# Aegis â€” Final Operator Steps (summary)
+
+This document summarizes the final operational steps (scripts added under ops/) to finalize Aegis platform automation.
+
+Key scripts (run from repo root):
+- ./ops/run_full_apply_irsa.sh terraform/irsa/my.tfvars
+- ./ops/provision_secrets_and_externalsecrets.sh   # requires environment variables (REPO, COSIGN_KMS_ARN, etc.)
+- ./ops/validate_ci_registry_permissions.sh        # validate AWS role can push/sign
+- ./ops/install_runtime_services.sh                # installs Argo Workflows, ArgoCD, Prometheus, ExternalSecrets, Istio/Knative
+- ./ops/deploy_metric_proxy_and_promoter.sh        # deploy metric-proxy and promoter and create in-cluster secret
+- ./ops/install_gatekeeper_and_protect_branch.sh   # install Gatekeeper and set branch protection
+- ./ops/upload_legal_signoff_and_enforce_checks.sh # upload legal signoff and require sanitizer + CI checks
+- ./ops/tune_slos_and_validate_budget.sh           # tune SLOs and run validation queries
+- ./ops/verify_full_setup.sh                       # quick verification of installed components
+
+Security reminders
+- Do NOT commit my.tfvars or any secret values to git.
+- Use ExternalSecrets to inject runtime secrets from AWS Secrets Manager or Vault.
+- Limit who can edit COSIGN_KMS_ARN, REKOR_URL and GITHUB_TOKEN in GitHub repository settings.
+
+Troubleshooting tips
+- If ArgoCD Application fails to sync, inspect ArgoCD UI (port-forward) and review Application events.
+- If promoter cannot create PRs, ensure gitops-promoter-secret contains a valid token with repo:status, repo permissions.
+- If metric-proxy cannot reach Prometheus, confirm internal DNS and service names, and ensure network policies allow traffic.
+
*** End Patch
*** End Patch
