diff --git a/k8s/manifests/staging-deploy.sh b/k8s/manifests/staging-deploy.sh
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/k8s/manifests/staging-deploy.sh
@@ -0,0 +1,144 @@
+#!/usr/bin/env bash
+#
+# Deploy Aegis staging components and helper steps.
+# This script is intended for staging only. It wires Postgres, Redis (optional),
+# Orchestrator, Argo Events (EventSource + Sensor), Gatekeeper (optional), OPA policy/data load,
+# and creates k8s secrets from a secrets directory or via Vault helper script.
+#
+# Security: Do NOT check secrets into git. Use Vault or SealedSecrets in production.
+#
+# Usage:
+#   ./k8s/manifests/staging-deploy.sh --namespace aegis-ml --secrets-dir ./secrets --opa-url http://opa:8181
+#
+set -euo pipefail
+
+NAMESPACE="aegis-ml"
+SECRETS_DIR="${PWD}/secrets"
+OPA_URL="${OPA_URL:-http://opa:8181}"
+GATEKEEPER_INSTALL="${GATEKEEPER_INSTALL:-false}"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --namespace) NAMESPACE="$2"; shift 2;;
+    --secrets-dir) SECRETS_DIR="$2"; shift 2;;
+    --opa-url) OPA_URL="$2"; shift 2;;
+    --install-gatekeeper) GATEKEEPER_INSTALL="true"; shift 1;;
+    *) echo "Unknown arg $1"; exit 1;;
+  esac
+done
+
+echo "Namespace: $NAMESPACE"
+echo "Secrets dir: $SECRETS_DIR"
+echo "OPA URL: $OPA_URL"
+echo "Gatekeeper install: $GATEKEEPER_INSTALL"
+
+kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "--- Applying infra & agent manifests ---"
+kubectl apply -n "$NAMESPACE" -f k8s/postgres/postgres-deployment.yaml
+kubectl apply -n "$NAMESPACE" -f k8s/redis/redis-deployment.yaml || true
+kubectl apply -n "$NAMESPACE" -f k8s/manifests/agent-serviceaccount.yaml
+kubectl apply -n "$NAMESPACE" -f k8s/manifests/kill-switch-configmap.yaml
+kubectl apply -n "$NAMESPACE" -f k8s/manifests/orchestrator-deployment.yaml
+kubectl apply -n "$NAMESPACE" -f argo-events/eventsource-webhook.yaml
+kubectl apply -n "$NAMESPACE" -f argo-events/sensor-retrain.yaml
+
+if [ "$GATEKEEPER_INSTALL" = "true" ]; then
+  echo "--- Installing Gatekeeper (helm) and applying constraints ---"
+  ./k8s/manifests/gatekeeper-install.sh || true
+  kubectl apply -n "$NAMESPACE" -f gatekeeper/constraint_auto_promote.yaml || true
+else
+  echo "Gatekeeper installation skipped (pass --install-gatekeeper to enable)."
+fi
+
+echo "--- Create Kubernetes secrets from $SECRETS_DIR (if present) ---"
+if [ -d "$SECRETS_DIR" ]; then
+  if [ -f "$SECRETS_DIR/github_app.pem" ]; then
+    kubectl -n "$NAMESPACE" create secret generic aegis-github-app-key --from-file=github_app.pem="$SECRETS_DIR/github_app.pem" --dry-run=client -o yaml | kubectl apply -f -
+    echo "Created secret aegis-github-app-key"
+  fi
+  if [ -f "$SECRETS_DIR/db_password" ]; then
+    kubectl -n "$NAMESPACE" create secret generic aegis-postgres-secret --from-file=password="$SECRETS_DIR/db_password" --dry-run=client -o yaml | kubectl apply -f -
+    echo "Created secret aegis-postgres-secret"
+  fi
+  if [ -f "$SECRETS_DIR/vault_token" ]; then
+    kubectl -n "$NAMESPACE" create secret generic aegis-vault-token --from-file=token="$SECRETS_DIR/vault_token" --dry-run=client -o yaml | kubectl apply -f -
+    echo "Created secret aegis-vault-token"
+  fi
+else
+  echo "No secrets dir found. Use Vault / SealedSecrets to provision secrets securely."
+fi
+
+echo "--- Wait for basic pods to be ready (Postgres, Orchestrator, Argo Events) ---"
+kubectl -n "$NAMESPACE" wait --for=condition=available deploy/aegis-postgres --timeout=120s || true
+kubectl -n "$NAMESPACE" wait --for=condition=available deploy/aegis-orchestrator --timeout=120s || true
+
+echo "--- Load OPA policy and model data into OPA at $OPA_URL (if reachable) ---"
+if curl -sSf "$OPA_URL" > /dev/null 2>&1; then
+  echo "OPA reachable; running opa-load helper"
+  ./k8s/manifests/opa-load.sh --opa-url "$OPA_URL" --policy-file policy/opa/agent_policies_extended.rego --data-file policy/opa/data/models.json || true
+else
+  echo "OPA not reachable at $OPA_URL; skip OPA load (ensure you load policy with your OPA deployment method)"
+fi
+
+echo "Staging deployment applied. Next: initialize decision_log schema (see k8s/manifests/init_db_and_migrate.sh)"
+echo "Follow docs/staging_runbook.md for verification steps (end-to-end synthetic drift test)."
+
diff --git a/k8s/manifests/opa-load.sh b/k8s/manifests/opa-load.sh
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/k8s/manifests/opa-load.sh
@@ -0,0 +1,122 @@
+#!/usr/bin/env bash
+#
+# Load a Rego policy and JSON data into an OPA server via its REST API.
+# Usage:
+#   ./k8s/manifests/opa-load.sh --opa-url http://opa:8181 --policy-file policy.rego --data-file data.json
+#
+set -euo pipefail
+
+OPA_URL="http://localhost:8181"
+POLICY_FILE=""
+DATA_FILE=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --opa-url) OPA_URL="$2"; shift 2;;
+    --policy-file) POLICY_FILE="$2"; shift 2;;
+    --data-file) DATA_FILE="$2"; shift 2;;
+    *) echo "Unknown arg $1"; exit 1;;
+  esac
+done
+
+if [ -z "$POLICY_FILE" ] && [ -z "$DATA_FILE" ]; then
+  echo "Provide --policy-file and/or --data-file"
+  exit 1
+fi
+
+OPA_POLICY_ENDPOINT="$OPA_URL/v1/policies/aegis_agent_policy"
+OPA_DATA_ENDPOINT="$OPA_URL/v1/data/aegis"
+
+if [ -n "$POLICY_FILE" ]; then
+  echo "Uploading policy $POLICY_FILE to $OPA_POLICY_ENDPOINT"
+  curl -sS -X PUT "$OPA_POLICY_ENDPOINT" --data-binary @"$POLICY_FILE" -H "Content-Type: text/plain"
+  echo "Policy upload complete."
+fi
+
+if [ -n "$DATA_FILE" ]; then
+  echo "Uploading data $DATA_FILE to $OPA_DATA_ENDPOINT"
+  # POST to /v1/data/aegis with body {"models": ...} or use /v1/data/<path>
+  # This script assumes the JSON file shape matches `data` content; adjust path if needed.
+  curl -sS -X PUT "$OPA_DATA_ENDPOINT" --data-binary @"$DATA_FILE" -H "Content-Type: application/json"
+  echo "Data upload complete."
+fi
+
+echo "OPA load finished."
+
diff --git a/vault/upload_to_vault.sh b/vault/upload_to_vault.sh
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/vault/upload_to_vault.sh
@@ -0,0 +1,140 @@
+#!/usr/bin/env bash
+#
+# Helper to upload GitHub App private key and Postgres credentials to Vault (KV v2).
+# Requires VAULT_ADDR and VAULT_TOKEN in the environment and appropriate policies.
+#
+# Usage:
+#   ./vault/upload_to_vault.sh --github-pem ./github_app.pem --app-id 12345 --installation-id 67890 \
+#      --pg-user aegis --pg-pass-file ./pg_pass --pg-host aegis-postgres.aegis-ml.svc.cluster.local
+#
+set -euo pipefail
+
+GITHUB_PEM=""
+GITHUB_APP_ID=""
+GITHUB_INSTALLATION_ID=""
+PG_USER="aegis"
+PG_PASS_FILE=""
+PG_HOST=""
+VAULT_PATH="${VAULT_PATH:-secret/data/aegis}"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --github-pem) GITHUB_PEM="$2"; shift 2;;
+    --app-id) GITHUB_APP_ID="$2"; shift 2;;
+    --installation-id) GITHUB_INSTALLATION_ID="$2"; shift 2;;
+    --pg-user) PG_USER="$2"; shift 2;;
+    --pg-pass-file) PG_PASS_FILE="$2"; shift 2;;
+    --pg-host) PG_HOST="$2"; shift 2;;
+    --vault-path) VAULT_PATH="$2"; shift 2;;
+    *) echo "Unknown arg $1"; exit 1;;
+  esac
+done
+
+if [ -z "$GITHUB_PEM" ] || [ -z "$GITHUB_APP_ID" ] || [ -z "$GITHUB_INSTALLATION_ID" ]; then
+  echo "Provide --github-pem, --app-id and --installation-id"
+  exit 1
+fi
+
+if [ -n "$PG_PASS_FILE" ] && [ ! -f "$PG_PASS_FILE" ]; then
+  echo "PG password file $PG_PASS_FILE not found"
+  exit 1
+fi
+
+if [ -z "${VAULT_ADDR:-}" ] || [ -z "${VAULT_TOKEN:-}" ]; then
+  echo "Set VAULT_ADDR and VAULT_TOKEN in environment (use CI service principal or operator token)"
+  exit 1
+fi
+
+echo "Uploading GitHub App key to Vault at $VAULT_PATH/github_app"
+curl --silent --fail --header "X-Vault-Token: $VAULT_TOKEN" \
+  --request POST \
+  --data "{\"data\": {\"private_key\": \"$(sed -e ':a' -e 'N' -e '$!ba' -e 's/\\/n/\\\\n/g' "$GITHUB_PEM")\", \"app_id\": \"$GITHUB_APP_ID\", \"installation_id\": \"$GITHUB_INSTALLATION_ID\" }}" \
+  "$VAULT_ADDR/v1/$VAULT_PATH/github_app"
+
+if [ -n "$PG_PASS_FILE" ]; then
+  PG_PASS="$(cat "$PG_PASS_FILE")"
+  echo "Uploading Postgres creds to Vault at $VAULT_PATH/postgres"
+  curl --silent --fail --header "X-Vault-Token: $VAULT_TOKEN" \
+    --request POST \
+    --data "{\"data\": {\"username\": \"$PG_USER\", \"password\": \"$PG_PASS\", \"host\": \"$PG_HOST\"}}" \
+    "$VAULT_ADDR/v1/$VAULT_PATH/postgres"
+fi
+
+echo "Vault upload complete. Ensure Kubernetes Vault Injector or agents fetch these secrets at runtime."
+
diff --git a/k8s/manifests/init_db_and_migrate.sh b/k8s/manifests/init_db_and_migrate.sh
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/k8s/manifests/init_db_and_migrate.sh
@@ -0,0 +1,68 @@
+#!/usr/bin/env bash
+#
+# Initialize Postgres schema for decision_log inside the aegis-postgres deployment.
+# Usage:
+#   ./k8s/manifests/init_db_and_migrate.sh --namespace aegis-ml
+#
+set -euo pipefail
+
+NAMESPACE="aegis-ml"
+SQL_FILE="${PWD}/sql/001_create_decision_log.sql"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --namespace) NAMESPACE="$2"; shift 2;;
+    --sql-file) SQL_FILE="$2"; shift 2;;
+    *) echo "Unknown arg $1"; exit 1;;
+  esac
+done
+
+if [ ! -f "$SQL_FILE" ]; then
+  echo "SQL file $SQL_FILE not found"
+  exit 1
+fi
+
+POD=$(kubectl -n "$NAMESPACE" get pods -l app=aegis-postgres -o jsonpath='{.items[0].metadata.name}')
+if [ -z "$POD" ]; then
+  echo "No aegis-postgres pod found in namespace $NAMESPACE"
+  exit 1
+fi
+
+echo "Copying SQL to pod $POD..."
+kubectl -n "$NAMESPACE" cp "$SQL_FILE" "$POD":/tmp/001_create_decision_log.sql
+
+echo "Executing SQL inside pod..."
+kubectl -n "$NAMESPACE" exec -it "$POD" -- bash -lc "psql -U aegis -d aegis -f /tmp/001_create_decision_log.sql"
+
+echo "Schema initialization complete."
+
diff --git a/k8s/manifests/gatekeeper-install.sh b/k8s/manifests/gatekeeper-install.sh
new file mode 100644
index 0000000..5555555
--- /dev/null
+++ b/k8s/manifests/gatekeeper-install.sh
@@ -0,0 +1,64 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+echo "Installing Gatekeeper via Helm (requires Helm 3 and internet access)"
+helm repo add gatekeeper https://open-policy-agent.github.io/gatekeeper/charts
+helm repo update
+helm upgrade --install gatekeeper gatekeeper/gatekeeper --namespace gatekeeper-system --create-namespace
+
+echo "Waiting for Gatekeeper pods to be ready..."
+kubectl -n gatekeeper-system wait --for=condition=available deployment/gatekeeper-controller-manager --timeout=120s || true
+
+echo "Applying ConstraintTemplate(s)..."
+kubectl apply -f gatekeeper/constraint_auto_promote.yaml || true
+
+echo "Gatekeeper installation complete (if errors occurred, check pod logs)."
+
diff --git a/monitoring/prometheus/aegis_alerts.yaml b/monitoring/prometheus/aegis_alerts.yaml
new file mode 100644
index 0000000..6666666
--- /dev/null
+++ b/monitoring/prometheus/aegis_alerts.yaml
@@ -0,0 +1,88 @@
+apiVersion: monitoring.coreos.com/v1
+kind: PrometheusRule
+metadata:
+  name: aegis-orchestrator-rules
+  namespace: aegis-ml
+spec:
+  groups:
+    - name: aegis-orchestrator.rules
+      rules:
+        - alert: AegisHighDenyRate
+          expr: rate(aegis_decisions_total{result="deny"}[5m]) > 0.5
+          for: 5m
+          labels:
+            severity: warning
+          annotations:
+            summary: "Aegis orchestrator high deny rate"
+            description: "More than 0.5 denies per second on average in the last 5m."
+
+        - alert: AegisRateLimitRejects
+          expr: increase(aegis_rate_limit_rejects_total[10m]) > 5
+          for: 5m
+          labels:
+            severity: warning
+          annotations:
+            summary: "Aegis rate limiter has rejected >5 requests in 10m"
+            description: "Investigate spike in incoming events or lower rate limit."
+
+        - alert: AegisBudgetRejects
+          expr: increase(aegis_budget_rejects_total[10m]) > 0
+          for: 5m
+          labels:
+            severity: info
+          annotations:
+            summary: "Aegis budget guard triggered"
+            description: "A budget guard prevented an action. Check billing adapter."
+
+        - alert: AegisDecisionLatencyHigh
+          expr: avg_over_time(aegis_decision_latency_seconds[5m]) > 2
+          for: 5m
+          labels:
+            severity: warning
+          annotations:
+            summary: "High decision latency in orchestrator"
+            description: "Average decision latency over 5m is > 2s; investigate OPA or DB slowness."
+
diff --git a/grafana/dashboards/aegis_orchestrator_dashboard.json b/grafana/dashboards/aegis_orchestrator_dashboard.json
new file mode 100644
index 0000000..7777777
--- /dev/null
+++ b/grafana/dashboards/aegis_orchestrator_dashboard.json
@@ -0,0 +1,104 @@
+{
+  "dashboard": {
+    "id": null,
+    "uid": "aegis-orch",
+    "title": "Aegis Orchestrator - Agent Metrics",
+    "tags": ["aegis","orchestrator"],
+    "panels": [
+      {
+        "type": "timeseries",
+        "title": "Decisions (allow/deny)",
+        "targets": [
+          {
+            "expr": "sum by (result) (aegis_decisions_total)",
+            "legendFormat": "{{result}}"
+          }
+        ],
+        "gridPos": {"x":0,"y":0,"w":12,"h":6}
+      },
+      {
+        "type": "timeseries",
+        "title": "Rate limit rejects",
+        "targets": [
+          {
+            "expr": "increase(aegis_rate_limit_rejects_total[5m])",
+            "legendFormat": "rate_limit_rejects"
+          }
+        ],
+        "gridPos": {"x":12,"y":0,"w":12,"h":4}
+      },
+      {
+        "type": "timeseries",
+        "title": "Budget rejects",
+        "targets": [
+          {
+            "expr": "increase(aegis_budget_rejects_total[5m])",
+            "legendFormat": "budget_rejects"
+          }
+        ],
+        "gridPos": {"x":12,"y":4,"w":12,"h":4}
+      },
+      {
+        "type": "timeseries",
+        "title": "Actions executed",
+        "targets": [
+          {
+            "expr": "sum by (action) (aegis_actions_executed_total)",
+            "legendFormat": "{{action}}"
+          }
+        ],
+        "gridPos": {"x":0,"y":6,"w":24,"h":6}
+      }
+    ],
+    "schemaVersion": 27,
+    "version": 1
+  }
+}
+
diff --git a/.github/workflows/ci-e2e.yml b/.github/workflows/ci-e2e.yml
new file mode 100644
index 0000000..8888888
--- /dev/null
+++ b/.github/workflows/ci-e2e.yml
@@ -0,0 +1,132 @@
+name: CI - Agent Unit + Optional E2E
+
+on:
+  push:
+    paths:
+      - "agents/**"
+      - "tests/**"
+      - "policy/**"
+  pull_request:
+
+jobs:
+  unit-tests:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: "3.10"
+      - name: Install test deps
+        run: |
+          pip install -r agents/orchestrator/requirements.txt
+          pip install -r tests/requirements-tests.txt || true
+      - name: Run pytest
+        run: pytest -q
+
+  e2e-staging (optional):
+    runs-on: ubuntu-latest
+    needs: unit-tests
+    if: github.event_name == 'push' && env.KUBECONFIG != ''
+    env:
+      KUBECONFIG: ${{ secrets.KUBECONFIG }}  # Provide a staging kubeconfig via repo secrets if desired
+    steps:
+      - uses: actions/checkout@v4
+      - name: Deploy staging manifests
+        run: |
+          echo "$KUBECONFIG" > /tmp/kubeconfig
+          export KUBECONFIG=/tmp/kubeconfig
+          ./k8s/manifests/staging-deploy.sh --namespace aegis-ml --secrets-dir ./secrets --opa-url http://opa:8181 || true
+      - name: Initialize DB schema
+        run: |
+          export KUBECONFIG=/tmp/kubeconfig
+          ./k8s/manifests/init_db_and_migrate.sh --namespace aegis-ml
+      - name: Run synthetic drift test
+        run: |
+          export KUBECONFIG=/tmp/kubeconfig
+          kubectl -n aegis-ml port-forward svc/aegis-webhook-es 12000:12000 & pid=$!
+          sleep 2
+          python tests/send_synthetic_drift.py --model low-demo-model
+          kill $pid || true
+      - name: Collect artifacts
+        run: |
+          export KUBECONFIG=/tmp/kubeconfig
+          kubectl -n aegis-ml get pods -o wide
+
diff --git a/docs/staging_runbook.md b/docs/staging_runbook.md
index 0000000..9999999
--- /dev/null
+++ b/docs/staging_runbook.md
@@ -0,0 +1,152 @@
+# Aegis Staging Runbook (full)
+
+This runbook documents the steps to deploy Aegis into staging, validate agent flows, and perform chaos/drill tests.
+
+Prereqs
+- kubectl configured to target a staging cluster (do NOT run in production).
+- Vault available (recommended) or a secure way to provide secrets (SealedSecrets).
+- Helm (for Gatekeeper install) and network access to install charts.
+
+Deploy (staging)
+1. Provision secrets securely:
+   - Prefer Vault. Use `vault/upload_to_vault.sh` to upload GitHub App key and DB creds.
+   - Alternatively provide a local `./secrets` dir with `github_app.pem` and `db_password` for staging only.
+
+2. Deploy Aegis core + agents:
+   ./k8s/manifests/staging-deploy.sh --namespace aegis-ml --secrets-dir ./secrets --opa-url http://opa:8181 [--install-gatekeeper]
+
+3. Initialize decision_log schema:
+   ./k8s/manifests/init_db_and_migrate.sh --namespace aegis-ml
+
+4. Load OPA policy & model data (if not loaded by staging-deploy):
+   ./k8s/manifests/opa-load.sh --opa-url http://opa:8181 --policy-file policy/opa/agent_policies_extended.rego --data-file policy/opa/data/models.json
+
+Validation & E2E test
+- Port-forward the Argo EventSource locally:
+  kubectl -n aegis-ml port-forward svc/aegis-webhook-es 12000:12000 &
+
+- Run synthetic drift:
+  python tests/send_synthetic_drift.py --model low-demo-model
+
+- Verify:
+  - Orchestrator logs: kubectl -n aegis-ml logs deploy/aegis-orchestrator -f
+  - Decision log: kubectl exec -n aegis-ml deploy/aegis-postgres -- psql -U aegis -d aegis -c "select * from decision_log order by created_at desc limit 10;"
+  - Argo UI: confirm retrain workflow submitted
+  - MLflow: confirm new runs/artifacts if retrain executed
+  - GitHub: confirm promotion PR created (if DRY_RUN=false and GitHub App configured)
+
+DRY_RUN workflow
+- Start with DRY_RUN=true (orchestrator env). Agents will log decisions but not execute side effects.
+- After multiple successful dry-run cycles, set DRY_RUN=false in the orchestrator deployment env var in staging and re-run the synthetic tests.
+
+Gatekeeper & admission control
+- If Gatekeeper is installed (recommended), test that a Deployment labeled `aegis.auto=true` without `aegis.run_id` is rejected.
+  kubectl apply -f test/deployment-without-provenance.yaml --namespace aegis-ml
+
+Observability
+- Import grafana/dashboards/aegis_orchestrator_dashboard.json into your Grafana instance.
+- Apply monitoring/prometheus/aegis_alerts.yaml to your PrometheusOperator.
+- Create alerts for deny-rate, rate-limit rejects, budget rejects, decision latency.
+
+Human-in-the-loop & approvals
+- Configure CODEOWNERS (file in repo) and branch protection rules on promotion branches so SRE & Security are required reviewers.
+- Optionally wire Slack or GitHub approvals via Actions or a bot; ensure approvals are recorded in decision_log by adding the approver to `params.approved_by` during promo.
+
+Chaos & DR drills
+- Simulate worker preemption:
+  ./k8s/chaos/worker_preempt.sh aegis-ml "app=gpu-worker"
+  Verify trainer resumes from S3 checkpoints and orchestrator logs decisions.
+
+- Flip kill-switch:
+  kubectl -n aegis-ml patch configmap aegis-orchestrator-config --type merge -p '{"data":{"kill_switch":"true"}}'
+  Verify orchestrator declines actions and logs decisions.
+
+Signoff
+- Collect artifacts:
+  - decision_log rows (SQL export)
+  - Argo workflow JSON (argo get -o yaml)
+  - Promotion PR links and approvals
+  - Grafana screenshots and alert history
+
+- SRE & Security must review artifacts and approve production enablement of auto-actions.
+
+Security & best practices
+- Never commit secrets. Use Vault + K8s Injector or SealedSecrets.
+- Use GitHub App installation tokens (see agents/common/github_app.py).
+- Use least-privilege service accounts (agent-serviceaccount manifest).
+
+Troubleshooting
+- If OPA policy rejects unexpectedly, use OPA REST API to evaluate inputs and debug.
+- If Gatekeeper denies valid manifests, inspect constraint status: kubectl get constraints --all-namespaces
+
+End of runbook.
+
diff --git a/k8s/chaos/worker_preempt.sh b/k8s/chaos/worker_preempt.sh
new file mode 100644
index 0000000..aaaaaaaa
--- /dev/null
+++ b/k8s/chaos/worker_preempt.sh
@@ -0,0 +1,45 @@
+#!/usr/bin/env bash
+# Simple chaos script for staging: evict or delete a GPU worker pod to simulate preemption.
+# WARNING: Run only in staging namespace.
+#
+# Usage: ./k8s/chaos/worker_preempt.sh aegis-ml "app=gpu-worker"
+set -euo pipefail
+
+NAMESPACE="${1:-aegis-ml}"
+LABEL="${2:-app=gpu-worker}"
+
+echo "Listing candidate worker pods with label $LABEL in namespace $NAMESPACE"
+kubectl -n "$NAMESPACE" get pods -l "$LABEL" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
+
+POD=$(kubectl -n "$NAMESPACE" get pods -l "$LABEL" -o jsonpath='{.items[0].metadata.name}')
+if [ -z "$POD" ]; then
+  echo "No pod found"
+  exit 1
+fi
+
+echo "Deleting pod $POD to simulate preemption"
+kubectl -n "$NAMESPACE" delete pod "$POD" --grace-period=0 --force
+echo "Deleted pod $POD"
+echo "Observe orchestrator behavior and trainer checkpoint/resume logic"
+
diff --git a/billing/budget_guard_adapter.py b/billing/budget_guard_adapter.py
index 0000000..bbbbbbbb
--- /dev/null
+++ b/billing/budget_guard_adapter.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python3
+"""
+Simple adapter example to integrate cloud billing/chargeback data into the orchestrator's budget guard.
+
+- In production, this should query your cloud billing export (BigQuery / Athena / Cost API) or internal chargeback DB.
+- This adapter exposes a small HTTP endpoint that returns current usage for a model or team.
+
+Usage (example):
+  python billing/budget_guard_adapter.py --port 8085
+"""
+import argparse
+import json
+from flask import Flask, request, jsonify
+
+app = Flask(__name__)
+
+# Example in-memory sample usage data; replace with real billing lookups
+USAGE = {
+  "low-demo-model": 25.0,
+  "fraud-detector-v1": 900.0
+}
+
+@app.route("/usage", methods=["GET"])
+def get_usage():
+  model = request.args.get("model")
+  if not model:
+    return jsonify({"error":"missing model param"}), 400
+  usage = USAGE.get(model, 0.0)
+  return jsonify({"model": model, "usage_usd": usage})
+
+if __name__ == "__main__":
+  parser = argparse.ArgumentParser()
+  parser.add_argument("--port", type=int, default=8085)
+  args = parser.parse_args()
+  app.run(host="0.0.0.0", port=args.port)
+
diff --git a/policy/opa/data/models.json b/policy/opa/data/models.json
index 0000000..cccccccc
--- /dev/null
+++ b/policy/opa/data/models.json
@@ -0,0 +1,22 @@
+{
+  "models": {
+    "low-demo-model": {
+      "risk": "low",
+      "team": "ads",
+      "budget_usd_per_month": 200.0,
+      "owners": ["alice","bob"]
+    },
+    "fraud-detector-v1": {
+      "risk": "high",
+      "team": "fraud",
+      "budget_usd_per_month": 1000.0,
+      "owners": ["sre","security"]
+    },
+    "default": {
+      "risk": "medium",
+      "team": "ml",
+      "budget_usd_per_month": 500.0,
+      "owners": ["ml-team"]
+    }
+  }
+}
+
