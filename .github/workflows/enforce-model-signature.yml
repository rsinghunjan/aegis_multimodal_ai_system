  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
name: Model artifact signature verification

on:
  workflow_dispatch:
    inputs:
      artifact_url:
        description: 'URL to download the model artifact (S3 presigned URL or http(s))'
        required: true
      sig_url:
        description: 'URL to download the signature file for the artifact (required if not using COSIGN)'
        required: false
      use_cosign:
        description: 'If true, use cosign to verify the artifact instead of python RSA verify'
        required: false
        default: 'false'
      cosign_key:
        description: 'Optional cosign public key (PEM) content or path (if using cosign)'
        required: false
  push:
    tags:
      - 'models/*' # optionally verify when model artifacts are published as tags

jobs:
  verify-model:
    runs-on: ubuntu-latest
    env:
      # When using the python verifier, provide the public key via secret MODEL_SIGNING_PUBKEY (PEM text)
      MODEL_SIGNING_PUBKEY: ${{ secrets.MODEL_SIGNING_PUBKEY }}
      # If verifying artifacts stored in S3, provide AWS creds in secrets or rely on runner role
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install cryptography boto3

      - name: Download artifact
        run: |
          mkdir -p /tmp/model_verify
          ARTIFACT_URL="${{ github.event.inputs.artifact_url || '' }}"
          if [ -z "$ARTIFACT_URL" ]; then
            echo "No artifact_url provided" >&2
            exit 1
          fi
          echo "Downloading artifact from $ARTIFACT_URL"
          curl -sSfL "$ARTIFACT_URL" -o /tmp/model_verify/artifact.bin

      - name: Download signature (if provided)
        if: ${{ github.event.inputs.use_cosign != 'true' }}
        run: |
          SIG_URL="${{ github.event.inputs.sig_url || '' }}"
          if [ -z "$SIG_URL" ]; then
            echo "Signature URL is required when not using cosign" >&2
            exit 1
          fi
          curl -sSfL "$SIG_URL" -o /tmp/model_verify/artifact.sig

      - name: Verify with cosign (optional)
        if: ${{ github.event.inputs.use_cosign == 'true' }}
        run: |
          echo "Verifying using cosign"
          # install cosign
          curl -sSfL https://raw.githubusercontent.com/sigstore/cosign/main/install.sh | sh -s -- -b /usr/local/bin
          COSIGN_KEY="${{ github.event.inputs.cosign_key || '' }}"
          if [ -n "$COSIGN_KEY" ]; then
            echo "$COSIGN_KEY" > /tmp/model_verify/cosign.pub
            cosign verify --key /tmp/model_verify/cosign.pub /tmp/model_verify/artifact.bin
          else
            # Use Fulcio transparency with keyless verify (optional). Fallback to verifying signatures stored alongside.
            echo "No cosign public key provided; attempting keyless verification (requires transparency logs)."
            cosign verify /tmp/model_verify/artifact.bin || (echo "cosign verification failed" >&2; exit 2)
          fi

      - name: Verify with python RSA verifier (fallback)
        if: ${{ github.event.inputs.use_cosign != 'true' }}
        run: |
          echo "Verifying signature using python verifier"
          python scripts/verify_model.py --artifact /tmp/model_verify/artifact.bin --sig /tmp/model_verify/artifact.sig --pubkey /tmp/model_verify/pub.pem || (
            echo "Falling back to environment-provided MODEL_SIGNING_PUBKEY"
            python - <<'PY'
import os, sys, tempfile
from pathlib import Path
pem = os.environ.get("MODEL_SIGNING_PUBKEY", "")
if not pem:
    print("MODEL_SIGNING_PUBKEY not set", file=sys.stderr); sys.exit(2)
p = Path("/tmp/model_verify/pub.pem")
p.write_text(pem)
import subprocess
r = subprocess.call(["python","scripts/verify_model.py","--artifact","/tmp/model_verify/artifact.bin","--sig","/tmp/model_verify/artifact.sig","--pubkey",str(p)])
sys.exit(r)
PY
          )

      - name: Success
        run: echo "Model artifact verified successfully."
.github/workflows/enforce-model-signature.yml
