*** Begin Patch
*** Add File:terraform/irsa/github_actions_oidc_role.tf
+/*
+Create an IAM role which GitHub Actions can assume using OIDC to allow Actions to
+perform KMS signing (cosign) and push images. This is a template â€” replace variables
+and integrate with your existing terraform state.
+*/
+variable "github_org" { type = string }
+variable "kms_key_arn" { type = string }
+variable "aws_region" { type = string }
+variable "account_id" { type = string }
+variable "github_oidc_provider_arn" { type = string } # e.g. arn:aws:iam::123:oidc-provider/token.actions.githubusercontent.com
+
+data "aws_iam_policy_document" "github_oidc_trust" {
+  statement {
+    effect = "Allow"
+    principals {
+      type        = "Federated"
+      identifiers = [var.github_oidc_provider_arn]
+    }
+    actions = ["sts:AssumeRoleWithWebIdentity"]
+    condition {
+      test     = "StringLike"
+      variable = "token.actions.githubusercontent.com:sub"
+      values   = ["repo:${var.github_org}/*"]
+    }
+  }
+}
+
+resource "aws_iam_role" "github_actions_oidc" {
+  name               = "github-actions-oidc-role"
+  assume_role_policy = data.aws_iam_policy_document.github_oidc_trust.json
+}
+
+data "aws_iam_policy_document" "github_actions_kms" {
+  statement {
+    effect = "Allow"
+    actions = [
+      "kms:Sign",
+      "kms:GetPublicKey",
+      "kms:DescribeKey",
+      "kms:CreateGrant",
+      "kms:Decrypt",
+      "kms:Encrypt",
+      "kms:GenerateDataKey"
+    ]
+    resources = [var.kms_key_arn]
+  }
+  statement {
+    effect = "Allow"
+    actions = [
+      "ecr:GetAuthorizationToken",
+      "ecr:BatchCheckLayerAvailability",
+      "ecr:GetDownloadUrlForLayer",
+      "ecr:BatchGetImage",
+      "ecr:PutImage",
+      "ecr:InitiateLayerUpload",
+      "ecr:UploadLayerPart",
+      "ecr:CompleteLayerUpload"
+    ]
+    resources = ["*"]
+  }
+  statement {
+    effect = "Allow"
+    actions = [
+      "sts:GetCallerIdentity"
+    ]
+    resources = ["*"]
+  }
+}
+
+resource "aws_iam_policy" "github_actions_kms_policy" {
+  name   = "github-actions-kms-policy"
+  policy = data.aws_iam_policy_document.github_actions_kms.json
+}
+
+resource "aws_iam_role_policy_attachment" "attach_github_actions_kms" {
+  role       = aws_iam_role.github_actions_oidc.name
+  policy_arn = aws_iam_policy.github_actions_kms_policy.arn
+}
+
+output "github_actions_oidc_role_arn" {
+  value = aws_iam_role.github_actions_oidc.arn
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/irsa/irsa_annotate_sa.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Use terraform outputs to annotate k8s ServiceAccounts with IAM role ARNs (IRSA).
+# Usage:
+#   ./irsa_annotate_sa.sh /path/to/terraform/output.json
+
+OUTFILE=${1:-/tmp/irsa_outputs.json}
+if [ ! -f "${OUTFILE}" ]; then
+  echo "Terraform output JSON not found: ${OUTFILE}"
+  exit 2
+fi
+
+BRACKET_ROLE=$(jq -r '.irsa_braket_role_arn.value // empty' "${OUTFILE}")
+IBM_ROLE=$(jq -r '.irsa_ibm_role_arn.value // empty' "${OUTFILE}")
+AZURE_ROLE=$(jq -r '.irsa_azure_role_arn.value // empty' "${OUTFILE}")
+RIGETTI_ROLE=$(jq -r '.irsa_rigetti_role_arn.value // empty' "${OUTFILE}")
+
+if [ -n "${BRACKET_ROLE}" ]; then
+  kubectl -n aegis annotate serviceaccount braket-sa eks.amazonaws.com/role-arn="${BRACKET_ROLE}" --overwrite
+  echo "Annotated braket-sa with ${BRACKET_ROLE}"
+fi
+if [ -n "${IBM_ROLE}" ]; then
+  kubectl -n aegis annotate serviceaccount ibm-quantum-sa eks.amazonaws.com/role-arn="${IBM_ROLE}" --overwrite
+  echo "Annotated ibm-quantum-sa with ${IBM_ROLE}"
+fi
+if [ -n "${AZURE_ROLE}" ]; then
+  kubectl -n aegis annotate serviceaccount azure-quantum-sa eks.amazonaws.com/role-arn="${AZURE_ROLE}" --overwrite
+  echo "Annotated azure-quantum-sa with ${AZURE_ROLE}"
+fi
+if [ -n "${RIGETTI_ROLE}" ]; then
+  kubectl -n aegis annotate serviceaccount rigetti-quantum-sa eks.amazonaws.com/role-arn="${RIGETTI_ROLE}" --overwrite
+  echo "Annotated rigetti-quantum-sa with ${RIGETTI_ROLE}"
+fi
+
+echo "IRSA annotation complete."
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/externalsecret_github_token.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: gitops-github-token
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: gitops-promoter-secret
+    creationPolicy: Owner
+  data:
+    - secretKey: github_token
+      remoteRef:
+        key: "gitops/github/token" # path in Secrets Manager or parameter store
+        property: "token"
+
+---
+# Example ExternalSecret for cosign/reko/MLflow mapping (do not put secrets here)
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: aegis-runtimes-secrets
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: aegis-runtime-secrets
+    creationPolicy: Owner
+  data:
+    - secretKey: COSIGN_KMS_ARN
+      remoteRef:
+        key: "aegis/cosign"
+        property: "kms_arn"
+    - secretKey: REKOR_URL
+      remoteRef:
+        key: "aegis/rekor"
+        property: "rekor_url"
+    - secretKey: MLFLOW_TRACKING_URI
+      remoteRef:
+        key: "aegis/mlflow"
+        property: "tracking_uri"
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/oidc_registry_push_example.yml
+name: Push image with OIDC-based credentials
+
+on:
+  workflow_dispatch:
+
+jobs:
+  push:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+      packages: write
+    steps:
+      - uses: actions/checkout@v4
+      - name: Configure AWS credentials using OIDC role
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }} # role created for GitHub OIDC
+          aws-region: REPLACE_AWS_REGION
+      - name: Login to ECR
+        run: |
+          aws ecr get-login-password --region REPLACE_AWS_REGION | docker login --username AWS --password-stdin "${{ secrets.ECR_REGISTRY }}"
+      - name: Build & push
+        run: |
+          docker build -t "${{ secrets.ECR_REGISTRY }}/aegis-quantum:tmp" -f docker/quantum/Dockerfile .
+          docker push "${{ secrets.ECR_REGISTRY }}/aegis-quantum:tmp"
+      - name: Sign with cosign (awskms)
+        env:
+          COSIGN_KMS_ARN: ${{ secrets.COSIGN_KMS_ARN }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          IMAGE="${{ secrets.ECR_REGISTRY }}/aegis-quantum:tmp"
+          cosign sign --key "awskms://${COSIGN_KMS_ARN}" --rekor-server "${REKOR_URL}" "${IMAGE}"
+
*** End Patch
*** Begin Patch
*** Add File:argocd/install_argocd.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install ArgoCD into the cluster (quick install). Operators may prefer Helm installations.
+kubectl create namespace argocd || true
+kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
+echo "ArgoCD installed. To access the UI run:"
+echo "  kubectl -n argocd port-forward svc/argocd-server 8080:443"
+echo "Admin password (initial) can be retrieved with:"
+echo "  kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 --decode"
+
*** End Patch
*** Begin Patch
*** Add File:istio/install_istio.sh
+#!/usr/bin/env bash
+set -euo pipefail
+ISTIO_VERSION=${1:-1.19.0}
+curl -L https://istio.io/downloadIstio | ISTIO_VERSION=${ISTIO_VERSION} sh -
+cd istio-${ISTIO_VERSION}
+export PATH=$PWD/bin:$PATH
+istioctl install --set profile=demo -y
+kubectl label namespace aegis istio-injection=enabled --overwrite
+echo "Istio installed with demo profile and sidecar injection enabled for aegis namespace."
+
*** End Patch
*** Begin Patch
*** Add File:k8s/gatekeeper/constraint_qpu_approved.yaml
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: K8sRequiredLabels
+metadata:
+  name: require-qpu-approved
+spec:
+  enforcementAction: deny
+  match:
+    kinds:
+      - apiGroups: ["argoproj.io"]
+        kinds: ["Workflow"]
+    namespaces: ["aegis"]
+  parameters:
+    labels:
+      - key: "quantum.aegis/signed"
+        allowedRegex: "true|TRUE"
+
+---
+# Human-readable Gatekeeper constraint for requiring legal signoff annotation on Jobs targeting QPUs.
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: K8sRequiredLabels
+metadata:
+  name: require-legal-signoff
+spec:
+  enforcementAction: deny
+  match:
+    kinds:
+      - apiGroups: ["batch"]
+        kinds: ["Job"]
+    namespaces: ["aegis"]
+  parameters:
+    labels:
+      - key: "legal.aegis/signoff"
+        allowedRegex: "signed|SIGNED|true"
+
*** End Patch
*** Begin Patch
*** Add File:ops/upload_legal_signoff.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Upload a completed legal signoff to the evidence S3 bucket
+# Usage:
+#   ./ops/upload_legal_signoff.sh ./legal_signoff.md
+
+FILE=${1:?path to legal signoff file is required}
+BUCKET=${EVIDENCE_BUCKET:-"REPLACE_EVIDENCE_BUCKET"}
+DEST="s3://${BUCKET}/legal_signoff/$(basename "${FILE}")"
+aws s3 cp "${FILE}" "${DEST}"
+echo "Uploaded legal signoff to ${DEST}"
+
*** End Patch
*** Begin Patch
*** Add File:config/slo_configmap.yaml
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: aegis-slo-config
+  namespace: aegis
+data:
+  p95_latency_threshold_seconds: "0.5"
+  canary_success_window_minutes: "60"
+  canary_error_rate_threshold: "0.02"
+  promote_latency_query: 'histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+  promote_error_query: 'sum(rate(http_requests_total{job="kserve",env="prod",status!~"2.."}[5m])) / sum(rate(http_requests_total{job="kserve",env="prod"}[5m]))'
+
*** End Patch
*** Begin Patch
*** Add File:ops/tune_slo.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Small script to update SLO values in the configmap. Must run with kubectl access.
+CM=ConfigMap/aegis-slo-config
+NAMESPACE=${1:-aegis}
+P95=${2:-0.5}
+WINDOW_MIN=${3:-60}
+ERROR_RATE=${4:-0.02}
+kubectl -n "${NAMESPACE}" patch ${CM} --type merge -p "{\"data\":{\"p95_latency_threshold_seconds\":\"${P95}\",\"canary_success_window_minutes\":\"${WINDOW_MIN}\",\"canary_error_rate_threshold\":\"${ERROR_RATE}\"}}"
+echo "Updated SLO config: p95=${P95}s window=${WINDOW_MIN}m error_rate=${ERROR_RATE}"
+
*** End Patch
*** Begin Patch
*** Add File:ops/ci_preflight_secrets_check.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Local helper to verify required GitHub secrets are set (using gh)
+REPO=${1:-REPLACE_GITHUB_REPOSITORY}
+required=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI AWS_ROLE_TO_ASSUME)
+missing=()
+for s in "${required[@]}"; do
+  if ! gh secret view "${s}" --repo "${REPO}" >/dev/null 2>&1; then
+    missing+=("${s}")
+  fi
+done
+if [ ${#missing[@]} -gt 0 ]; then
+  echo "Missing required secrets in ${REPO}: ${missing[*]}"
+  exit 2
+fi
+echo "All required secrets are present in ${REPO}."
+
*** End Patch
*** End Patch
