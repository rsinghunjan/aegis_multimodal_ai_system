*** Begin Patch
*** Add File:ops/terraform_apply_and_annotate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run Terraform for IRSA and annotate Kubernetes ServiceAccounts with the created role ARNs.
+# Usage:
+#   cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars
+#   edit terraform/irsa/my.tfvars (do NOT commit)
+#   ./ops/terraform_apply_and_annotate.sh terraform/irsa/my.tfvars
+
+TFVARS=${1:-terraform/irsa/my.tfvars}
+TF_DIR="terraform/irsa"
+
+if [ ! -f "${TFVARS}" ]; then
+  echo "Error: tfvars file not found: ${TFVARS}"
+  exit 2
+fi
+
+echo "Running terraform init/plan/apply in ${TF_DIR} using ${TFVARS}..."
+pushd "${TF_DIR}" >/dev/null
+terraform init -input=false
+terraform plan -input=false -var-file="${TFVARS}" -out=tfplan
+terraform apply -input=false -auto-approve tfplan
+terraform output -json > /tmp/irsa_outputs.json
+popd >/dev/null
+
+echo "Annotating ServiceAccounts (IRSA) using /tmp/irsa_outputs.json..."
+if [ -f /tmp/irsa_outputs.json ]; then
+  ./terraform/irsa/irsa_annotate_sa.sh /tmp/irsa_outputs.json || true
+else
+  echo "Warning: /tmp/irsa_outputs.json not found; annotation skipped."
+fi
+
+echo "Terraform IRSA apply and SA annotation complete."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/terraform_irsa_pipeline.yml
+name: Terraform IRSA Plan & Apply (OIDC)
+
+on:
+  workflow_dispatch:
+    inputs:
+      auto_approve:
+        description: "Set to 'true' to auto-apply - use with caution"
+        required: false
+        default: "false"
+
+jobs:
+  plan:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup Terraform
+        uses: hashicorp/setup-terraform@v2
+        with:
+          terraform_version: 1.5.0
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Terraform Init & Plan
+        working-directory: terraform/irsa
+        run: |
+          terraform init -input=false
+          terraform plan -input=false -var-file=my.tfvars -out=tfplan
+      - name: Upload plan
+        uses: actions/upload-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+
+  apply:
+    needs: plan
+    runs-on: ubuntu-latest
+    if: ${{ github.event.inputs.auto_approve == 'true' }}
+    permissions:
+      id-token: write
+    steps:
+      - uses: actions/checkout@v4
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Download plan
+        uses: actions/download-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+      - name: Terraform Apply
+        working-directory: terraform/irsa
+        run: terraform apply -input=false -auto-approve tfplan
+
*** End Patch
*** Begin Patch
*** Add File:ops/provision_github_secrets_and_externalsecrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Provision GitHub repository secrets and apply Kubernetes ExternalSecrets to the cluster.
+# Required environment variables before running:
+#   REPO (owner/repo)
+#   COSIGN_KMS_ARN, REKOR_URL, EVIDENCE_BUCKET, MLFLOW_TRACKING_URI
+# Optional:
+#   AWS_ROLE_TO_ASSUME, PROVIDER_API_KEYS_JSON (JSON string of provider keys), NAMESPACE (default: aegis)
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+NAMESPACE=${NAMESPACE:-aegis}
+
+required=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI)
+for v in "${required[@]}"; do
+  if [ -z "${!v:-}" ]; then
+    echo "Error: environment variable ${v} must be set"
+    exit 2
+  fi
+done
+
+echo "Creating GitHub secrets in ${REPO}..."
+gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+gh secret set EVIDENCE_BUCKET --repo "${REPO}" --body "${EVIDENCE_BUCKET}"
+gh secret set MLFLOW_TRACKING_URI --repo "${REPO}" --body "${MLFLOW_TRACKING_URI}"
+if [ -n "${AWS_ROLE_TO_ASSUME:-}" ]; then
+  gh secret set AWS_ROLE_TO_ASSUME --repo "${REPO}" --body "${AWS_ROLE_TO_ASSUME}"
+fi
+if [ -n "${PROVIDER_API_KEYS_JSON:-}" ]; then
+  gh secret set PROVIDER_API_KEYS_JSON --repo "${REPO}" --body "${PROVIDER_API_KEYS_JSON}"
+fi
+
+echo "Applying ExternalSecrets manifests to namespace ${NAMESPACE} (requires ExternalSecrets operator installed)"
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/secretstore.aws.yaml || true
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/externalsecret_runtime_values.yaml || true
+
+echo "Provisioning finished. Verify GitHub secrets and kubernetes ExternalSecrets resources."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/ci_registry_permissions_check.yml
+name: CI Registry / KMS Permissions Check
+
+on:
+  workflow_dispatch:
+    inputs:
+      ecr_registry:
+        description: 'ECR registry (optional)'
+        required: false
+
+jobs:
+  validate:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Validate KMS & ECR access
+        run: |
+          # Validate KMS describe
+          if [ -n "${{ secrets.COSIGN_KMS_ARN }}" ]; then
+            echo "Describing KMS key..."
+            aws kms describe-key --key-id "${{ secrets.COSIGN_KMS_ARN }}"
+          else
+            echo "COSIGN_KMS_ARN secret not present - please set"
+            exit 1
+          fi
+          # Validate ECR token retrieval if ECR specified
+          if [ -n "${{ github.event.inputs.ecr_registry }}" ]; then
+            aws ecr get-authorization-token --registry-ids "$(echo ${{ github.event.inputs.ecr_registry }} | cut -d. -f1)"
+            echo "ECR token retrieved"
+          fi
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_runtime_stack.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install core runtime components:
+#  - Argo Workflows
+#  - ArgoCD (Helm)
+#  - Prometheus (kube-prometheus-stack)
+#  - ExternalSecrets operator
+#  - Istio (or Knative) service mesh (demo)
+#
+echo "Installing Argo Workflows..."
+kubectl create namespace argo --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/stable/manifests/install.yaml
+
+echo "Installing ArgoCD (Helm)..."
+bash ops/install_argocd_helm.sh
+
+echo "Installing Prometheus (kube-prometheus-stack via Helm)..."
+helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
+helm repo update
+kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install prometheus prometheus-community/kube-prometheus-stack -n monitoring --wait
+
+echo "Installing ExternalSecrets operator..."
+helm repo add external-secrets https://external-secrets.github.io/kubernetes-external-secrets/ || true
+helm repo update
+kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install external-secrets external-secrets/kubernetes-external-secrets -n external-secrets --wait
+
+echo "Installing Istio (demo) and Knative (optional)..."
+bash istio/install_istio.sh || true
+bash knative/install_knative.sh || true
+
+echo "Runtime stack installation complete."
+
*** End Patch
*** Begin Patch
*** Add File:ops/deploy_metricproxy_and_promoter.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Deploy metric-proxy and promoter into the cluster. Provide GITHUB_TOKEN env var if you want promoter secret created.
+#
+NAMESPACE=${NAMESPACE:-aegis}
+PROM_URL=${PROM_URL:-"REPLACE_PROMETHEUS_INTERNAL_URL"}
+
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "Applying metric-proxy manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-deployment.yaml
+kubectl -n "${NAMESPACE}" patch deployment metric-proxy --patch "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"proxy\",\"env\":[{\"name\":\"PROMETHEUS_URL\",\"value\":\"${PROM_URL}\"}]}]}}}}"
+
+echo "Applying promoter manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-deployment.yaml
+
+if [ -n "${GITHUB_TOKEN:-}" ]; then
+  echo "Creating in-cluster promoter secret..."
+  kubectl -n "${NAMESPACE}" create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}" --dry-run=client -o yaml | kubectl apply -f -
+fi
+
+echo "Metric-proxy and promoter deployment complete."
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_gatekeeper_and_set_protection.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Gatekeeper, apply constraints, and configure GitHub branch protection & PR review rules.
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+echo "Installing Gatekeeper..."
+kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+sleep 5
+kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml || true
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping branch protection configuration. Set GITHUB_TOKEN and re-run to enforce protection."
+  exit 0
+fi
+
+echo "Setting branch protection on ${REPO}:${BRANCH} to require CI checks & approvals..."
+required_contexts='["sanitizer","ci_train_validate_register","image_build_cosign"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Gatekeeper installed and branch protection configured."
+
*** End Patch
*** Begin Patch
*** Add File:ops/upload_legal_signoff_and_require_checks.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Upload legal signoff to S3 evidence bucket and require sanitizer + CI checks on the target branch.
+#
+FILE=${1:-ops/legal_signoff.md}
+EVIDENCE_BUCKET=${EVIDENCE_BUCKET:-REPLACE_EVIDENCE_BUCKET}
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+if [ ! -f "${FILE}" ]; then
+  echo "Legal signoff file missing: ${FILE}"
+  exit 2
+fi
+
+echo "Uploading legal signoff to s3://${EVIDENCE_BUCKET}/legal_signoff/"
+aws s3 cp "${FILE}" "s3://${EVIDENCE_BUCKET}/legal_signoff/$(basename "${FILE}")"
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping branch protection update. Set it to enforce checks."
+  exit 0
+fi
+
+echo "Updating branch protection to require sanitizer and CI checks..."
+required_contexts='["sanitizer","ci_train_validate_register","secret-and-deploy-preflight"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Legal signoff uploaded and CI checks configured."
+
*** End Patch
*** Begin Patch
*** Add File:ops/tune_slos_and_validate_budget.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Tune SLOs in ConfigMap and run sample checks against metric-proxy and cost estimator.
+#
+P95=${1:-0.5}
+ERROR_RATE=${2:-0.02}
+WINDOW=${3:-60}
+METRIC_PROXY_URL=${METRIC_PROXY_URL:-http://metric-proxy.aegis.svc.cluster.local:8080}
+
+echo "Updating ConfigMap aegis-slo-config in namespace 'aegis'..."
+kubectl -n aegis create configmap aegis-slo-config --from-literal=p95_latency_threshold_seconds="${P95}" --from-literal=canary_error_rate_threshold="${ERROR_RATE}" --from-literal=canary_success_window_minutes="${WINDOW}" -o yaml --dry-run=client | kubectl apply -f -
+
+echo "Querying metric-proxy for p95 latency..."
+QUERY='histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+ENCODED_QUERY=$(python3 - <<PY
+import urllib.parse
+print(urllib.parse.quote('''${QUERY}'''))
+PY
+)
+curl -s "${METRIC_PROXY_URL}/api/v1/query?query=${ENCODED_QUERY}" | jq .
+
+echo "Running cost/budget validation (placeholder) - ensure your cost estimator returns below budget before scheduling expensive runs."
+if [ -x ./ops/qpu_cost_estimator_braket_integration.py ]; then
+  echo "Running cost estimator (example):"
+  python3 ./ops/qpu_cost_estimator_braket_integration.py --job-spec sample_job.json || true
+else
+  echo "No cost estimator present or executable; validate costs manually."
+fi
+
+echo "SLO tuning & budget validation complete."
+
*** End Patch
*** Begin Patch
*** Add File:docs/platform_finalize_instructions.md
+# Finalize Aegis Platform â€” Operator Instructions
+
+This document summarizes the new scripts added under ops/ and the recommended order to finalize the platform.
+
+1) Apply IRSA and annotate SAs
+   - Edit terraform/irsa/my.tfvars locally (do NOT commit)
+   - ./ops/terraform_apply_and_annotate.sh terraform/irsa/my.tfvars
+   - or run the GitHub Actions workflow .github/workflows/terraform_irsa_pipeline.yml (use auto_approve carefully)
+
+2) Provision GitHub secrets & ExternalSecrets
+   - Export required env vars: REPO, COSIGN_KMS_ARN, REKOR_URL, EVIDENCE_BUCKET, MLFLOW_TRACKING_URI
+   - Optionally set AWS_ROLE_TO_ASSUME and PROVIDER_API_KEYS_JSON
+   - ./ops/provision_github_secrets_and_externalsecrets.sh
+
+3) Validate CI registry & KMS permissions
+   - Use .github/workflows/ci_registry_permissions_check.yml or run ./ops/validate_ci_registry_permissions.sh locally
+   - Ensure Actions OIDC role (AWS_ROLE_TO_ASSUME) can push to registry and use KMS for cosign
+
+4) Install runtime services
+   - ./ops/install_runtime_stack.sh
+   - Follow logs and ensure Argo Workflows, ArgoCD, Prometheus, ExternalSecrets operator and Istio/Knative are running
+
+5) Deploy metric-proxy & promoter (in-cluster)
+   - export GITHUB_TOKEN (optional, required if promoter should create PRs)
+   - ./ops/deploy_metricproxy_and_promoter.sh
+
+6) Install Gatekeeper and enforce branch protection
+   - ./ops/install_gatekeeper_and_set_protection.sh (requires GITHUB_TOKEN to set protection)
+
+7) Upload legal signoff and require sanitizer & CI checks
+   - ./ops/upload_legal_signoff_and_require_checks.sh path/to/legal_signoff.md
+
+8) Tune SLOs and validate cost/budget guard rails
+   - ./ops/tune_slos_and_validate_budget.sh <p95> <error_rate> <window_minutes>
+
+9) Verify everything
+   - ./ops/verify_full_setup.sh
+
+Security notes:
+- Never commit tfvars or secrets.
+- Use ExternalSecrets to inject secrets into k8s from Secrets Manager or Vault.
+- Restrict permissions on KMS keys and GitHub secrets.
+
*** End Patch
*** End Patch
