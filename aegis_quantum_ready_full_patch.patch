*** Begin Patch
*** Add File:quantum/crypto/hybrid_signer_hsm.py
+#!/usr/bin/env python3
+"""
+Hybrid signer with optional PKCS#11 HSM integration (SoftHSM test support).
+
+Features:
+ - Classical signing via cosign (assumes cosign in PATH)
+ - PQ signing via:
+     * python-oqs if available (software PQ)
+     * PKCS#11 HSM via python-pkcs11 (SoftHSM test flow)
+ - Combined metadata JSON output (classical + PQ signatures)
+ - Optional Rekor submission via rekor-cli (if installed) or using a fallback REST API stub
+
+Usage:
+  python3 hybrid_signer_hsm.py sign --artifact /path/to/file --outdir ./sigs --cosign-key /path/to/key \
+        [--pq-alg Dilithium2] [--use-pkcs11 /usr/lib/softhsm/libsofthsm2.so --slot 0 --pin 1234 --key-label pqkey]
+
+  python3 hybrid_signer_hsm.py verify --artifact /path/to/file --sigdir ./sigs
+
+Notes:
+ - SoftHSM example initialization is provided in quantum/hsm/README.md
+ - For production, replace SoftHSM with vendor HSM and update PKCS#11 config accordingly
+"""
+import argparse
+import base64
+import hashlib
+import json
+import os
+import subprocess
+import sys
+import time
+
+try:
+    import oqs
+    OQS_AVAILABLE = True
+except Exception:
+    OQS_AVAILABLE = False
+
+PKCS11_AVAILABLE = False
+try:
+    from pkcs11 import lib, KeyType, Attribute, ObjectClass, PKCS11Lib, Mechanism
+    PKCS11_AVAILABLE = True
+except Exception:
+    PKCS11_AVAILABLE = False
+
+def sha256_hex(path):
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        for chunk in iter(lambda: f.read(8192), b""):
+            h.update(chunk)
+    return h.hexdigest()
+
+def cosign_sign_blob(artifact_path, out_sig_path=None, key=None):
+    cmd = ["cosign", "sign-blob"]
+    if key:
+        cmd += ["--key", key]
+    if out_sig_path:
+        cmd += ["--output-signature", out_sig_path]
+    cmd += [artifact_path]
+    subprocess.check_call(cmd)
+    return out_sig_path
+
+def pq_sign_software(artifact_path, algo="Dilithium2"):
+    if not OQS_AVAILABLE:
+        return {"algorithm": algo, "signature_b64": None, "note": "python-oqs not installed"}
+    with oqs.Signature(algo) as signer:
+        with open(artifact_path, "rb") as f:
+            data = f.read()
+        sig = signer.sign(data)
+    return {"algorithm": algo, "signature_b64": base64.b64encode(sig).decode("ascii")}
+
+def pq_sign_pkcs11(artifact_path, pkcs11_lib_path, slot, pin, key_label, algo="Dilithium2"):
+    if not PKCS11_AVAILABLE:
+        return {"algorithm": algo, "signature_b64": None, "note": "python-pkcs11 not installed"}
+    # This is a simplified PKCS#11 signing flow. Vendor HSMs will differ.
+    pk = PKCS11Lib(pkcs11_lib_path)
+    token = pk.get_token(slot=int(slot))
+    with token.open(user_pin=pin) as session:
+        # find private key by label
+        privs = list(session.get_objects({Attribute.LABEL: key_label, Attribute.CLASS: ObjectClass.PRIVATE_KEY}))
+        if not privs:
+            return {"algorithm": algo, "signature_b64": None, "note": "key not found in token"}
+        priv = privs[0]
+        # Compute digest and sign using raw mechanism if supported
+        data = open(artifact_path,"rb").read()
+        digest = hashlib.sha256(data).digest()
+        # Choose mechanism based on algorithm; mapping depends on HSM capabilities
+        signature = session.sign(priv, digest, mechanism=Mechanism.SHA256_RSA_PKCS)
+        return {"algorithm": algo, "signature_b64": base64.b64encode(signature).decode("ascii")}
+
+def build_meta(artifact_path, classical_sig_b64=None, pq_meta=None):
+    return {
+        "artifact": os.path.abspath(artifact_path),
+        "sha256": sha256_hex(artifact_path),
+        "timestamp": int(time.time()),
+        "classical": {"tool":"cosign","signature_b64": classical_sig_b64} if classical_sig_b64 else None,
+        "pq": pq_meta or None
+    }
+
+def submit_rekor(hybrid_meta_path, rekor_server="https://rekor.sigstore.dev"):
+    # Prefer calling rekor-cli if present; fallback to a warning
+    try:
+        subprocess.check_call(["rekor-cli", "upload", hybrid_meta_path])
+        print("rekor-cli upload attempted")
+    except FileNotFoundError:
+        print("rekor-cli not found; please install rekor-cli or integrate via cosign/rekor library")
+
+def cmd_sign(args):
+    artifact = args.artifact
+    outdir = os.path.abspath(args.outdir)
+    os.makedirs(outdir, exist_ok=True)
+    classical_sig_path = os.path.join(outdir, "classical.sig")
+    print("[hybrid_signer] Creating classical signature with cosign...")
+    try:
+        cosign_sign_blob(artifact, out_sig_path=classical_sig_path, key=args.cosign_key)
+        classical_b64 = base64.b64encode(open(classical_sig_path,"rb").read()).decode("ascii")
+    except Exception as e:
+        print("classical sign failed:", e)
+        classical_b64 = None
+    print("[hybrid_signer] Creating PQ signature...")
+    pq_meta = None
+    if args.use_pkcs11:
+        pq_meta = pq_sign_pkcs11(artifact, args.pkcs11_lib, args.pkcs11_slot, args.pkcs11_pin, args.pkcs11_keylabel, algo=args.pq_alg)
+    else:
+        pq_meta = pq_sign_software(artifact, algo=args.pq_alg)
+    meta = build_meta(artifact, classical_sig_b64=classical_b64, pq_meta=pq_meta)
+    meta_path = os.path.join(outdir, "hybrid-signature.json")
+    with open(meta_path,"w") as f:
+        json.dump(meta, f, indent=2)
+    print("[hybrid_signer] Wrote hybrid metadata:", meta_path)
+    if args.rekor:
+        submit_rekor(meta_path, args.rekor_server)
+
+def cmd_verify(args):
+    sigdir = args.sigdir
+    meta_path = os.path.join(sigdir, "hybrid-signature.json")
+    if not os.path.exists(meta_path):
+        print("metadata missing:", meta_path); sys.exit(2)
+    meta = json.load(open(meta_path))
+    if sha256_hex(args.artifact) != meta.get("sha256"):
+        print("SHA mismatch! abort"); sys.exit(3)
+    classical_sig_b64 = meta.get("classical",{}).get("signature_b64")
+    if classical_sig_b64:
+        # write to a temp file and use cosign verify-blob
+        tmp = os.path.join(sigdir, "classical.sig.b64.tmp")
+        open(tmp,"wb").write(base64.b64decode(classical_sig_b64))
+        try:
+            subprocess.check_call(["cosign","verify-blob","--signature", tmp, args.artifact])
+            print("classical signature OK")
+        except Exception as e:
+            print("classical verify failed:", e)
+    else:
+        print("No classical signature included")
+    if meta.get("pq",{}).get("signature_b64"):
+        if not OQS_AVAILABLE and not PKCS11_AVAILABLE:
+            print("PQ signature present but no local PQ verifier available")
+        else:
+            print("PQ signature verification should be implemented with vendor or oqs bindings")
+
+def main():
+    p = argparse.ArgumentParser()
+    sub = p.add_subparsers(dest="cmd")
+    s = sub.add_parser("sign")
+    s.add_argument("--artifact", required=True)
+    s.add_argument("--outdir", required=True)
+    s.add_argument("--cosign-key", default=None)
+    s.add_argument("--pq-alg", default="Dilithium2")
+    s.add_argument("--use-pkcs11", action="store_true", help="Use PKCS#11 HSM signer")
+    s.add_argument("--pkcs11-lib", default="/usr/lib/softhsm/libsofthsm2.so")
+    s.add_argument("--pkcs11-slot", default="0")
+    s.add_argument("--pkcs11-pin", default="1234")
+    s.add_argument("--pkcs11-keylabel", default="pqkey")
+    s.add_argument("--rekor", action="store_true")
+    s.add_argument("--rekor-server", default="https://rekor.sigstore.dev")
+    v = sub.add_parser("verify")
+    v.add_argument("--artifact", required=True)
+    v.add_argument("--sigdir", required=True)
+    args = p.parse_args()
+    if args.cmd == "sign":
+        cmd_sign(args)
+    elif args.cmd == "verify":
+        cmd_verify(args)
+    else:
+        p.print_help()
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:quantum/hsm/README.md
+SoftHSM test environment for PKCS#11 PQ signing
+================================================
+
+This folder contains instructions to create a local SoftHSM instance for development/testing.
+
+Quickstart (Linux)
+1. Install SoftHSM2 and pkcs11-tool:
+   sudo apt-get install softhsm2 pkcs11-tool
+
+2. Initialize a token:
+   export SOFTHSM2_CONF=$(pwd)/softhsm2.conf
+   mkdir -p softhsm2
+   export SOFTHSM2_CONF=$(pwd)/softhsm2.conf
+   cat > softhsm2.conf <<EOF
+directories.tokendir = $(pwd)/softhsm2/tokens
+EOF
+   export SOFTHSM2_CONF
+   softhsm2-util --init-token --free --label "pq-token" --so-pin 1234 --pin 1234
+
+3. Create an RSA key (placeholder) for testing:
+   pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so --login --pin 1234 --keypairgen --key-type rsa:2048 --label pqkey
+
+4. Test listing keys:
+   pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so --list-objects --login --pin 1234
+
+Notes:
+- SoftHSM does not implement PQ algorithms; this flow tests PKCS#11 path integration. Replace with vendor HSM for real PQ.
+- Use quantum/crypto/hybrid_signer_hsm.py with --use-pkcs11 to exercise PKCS#11 path.
+
*** End Patch
*** Begin Patch
*** Add File:quantum/crypto/re
*** End Patch
