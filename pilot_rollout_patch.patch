*** Begin Patch
*** Add File: rollout/rollout_manager.py
+#!/usr/bin/env python3
+"""
+Rollout Manager
+
+Usage:
+  python rollout_manager.py --controller https://controller.example.com --manifest manifest.json --release-name pilot-2025-12-13 --threshold 0.05 --monitor-interval 15
+
+Behavior:
+ - Verifies manifest has Rekor entry and cosign signature before creating a release.
+ - Creates a release via Controller API.
+ - Monitors rollout telemetry (error rate, latency) via Controller API / telemetry endpoint.
+ - If error rate or failure metric exceeds thresholds during the staged rollout, triggers a rollback via Controller API.
+ - Emits logs and writes a JSON report of the rollout outcome.
+
+This is a safe orchestrator intended for piloting >= 1k devices. It assumes the Controller exposes:
+ - POST /api/v1/releases  { release_name, manifest }
+ - GET  /api/v1/releases/{release_id}/status -> { rollout_pct, error_rate, healthy }
+ - POST /api/v1/releases/{release_id}/rollback
+
+Adjust endpoints to match your controller.
+"""
+import argparse
+import requests
+import time
+import json
+import subprocess
+import hashlib
+from pathlib import Path
+from datetime import datetime
+
+def verify_rekor(manifest_path):
+    digest = hashlib.sha256(Path(manifest_path).read_bytes()).hexdigest()
+    try:
+        out = subprocess.check_output(["rekor-cli", "search", "hash", digest], stderr=subprocess.STDOUT, timeout=20)
+        return b"UUID" in out
+    except subprocess.CalledProcessError:
+        return False
+    except FileNotFoundError:
+        # Rekor not installed. Fallback: attempt cosign verify.
+        try:
+            subprocess.check_call(["cosign", "verify", manifest_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
+            return True
+        except Exception:
+            return False
+
+def create_release(controller_url, api_key, release_name, manifest_obj):
+    url = f"{controller_url.rstrip('/')}/api/v1/releases"
+    headers = {"Content-Type": "application/json"}
+    if api_key:
+        headers["X-API-Key"] = api_key
+    payload = {"release_name": release_name, "manifest": manifest_obj}
+    r = requests.post(url, json=payload, headers=headers, timeout=20)
+    r.raise_for_status()
+    return r.json().get("release_id") or r.json()
+
+def get_release_status(controller_url, api_key, release_id):
+    url = f"{controller_url.rstrip('/')}/api/v1/releases/{release_id}/status"
+    headers = {}
+    if api_key:
+        headers["X-API-Key"] = api_key
+    r = requests.get(url, headers=headers, timeout=10)
+    r.raise_for_status()
+    return r.json()
+
+def rollback_release(controller_url, api_key, release_id, reason="auto-roll-back"):
+    url = f"{controller_url.rstrip('/')}/api/v1/releases/{release_id}/rollback"
+    headers = {"Content-Type": "application/json"}
+    if api_key:
+        headers["X-API-Key"] = api_key
+    r = requests.post(url, json={"reason": reason}, headers=headers, timeout=10)
+    r.raise_for_status()
+    return r.json()
+
+def parse_args():
+    p = argparse.ArgumentParser()
+    p.add_argument("--controller", required=True)
+    p.add_argument("--api-key", default=None)
+    p.add_argument("--manifest", required=True)
+    p.add_argument("--release-name", required=True)
+    p.add_argument("--threshold", type=float, default=0.05, help="Error rate threshold to trigger rollback")
+    p.add_argument("--monitor-interval", type=int, default=15, help="seconds between checks")
+    p.add_argument("--staged-duration", type=int, default=600, help="seconds to monitor before full rollout")
+    p.add_argument("--report", default="/tmp/rollout_report.json")
+    return p.parse_args()
+
+def main():
+    args = parse_args()
+    manifest_path = Path(args.manifest)
+    if not manifest_path.exists():
+        raise SystemExit("manifest missing")
+    # verify Rekor / cosign
+    ok = verify_rekor(str(manifest_path))
+    if not ok:
+        raise SystemExit("manifest is not attested in Rekor or not verifiable by cosign")
+    manifest_obj = json.loads(manifest_path.read_text())
+    print("Creating release:", args.release_name)
+    release_id = create_release(args.controller, args.api_key, args.release_name, manifest_obj)
+    print("release_id:", release_id)
+    start = time.time()
+    report = {"release_id": release_id, "created_at": datetime.utcnow().isoformat(), "checks": []}
+    try:
+        while time.time() - start < args.staged_duration:
+            status = get_release_status(args.controller, args.api_key, release_id)
+            ts = datetime.utcnow().isoformat()
+            report["checks"].append({"ts": ts, "status": status})
+            err_rate = float(status.get("error_rate", 0.0))
+            rollout_pct = float(status.get("rollout_pct", 0.0))
+            print(f"[{ts}] rollout_pct={rollout_pct} err_rate={err_rate}")
+            if err_rate > args.threshold:
+                print("Error threshold exceeded, initiating rollback")
+                rb = rollback_release(args.controller, args.api_key, release_id, reason=f"err_rate>{args.threshold}")
+                report["rollback"] = {"ts": datetime.utcnow().isoformat(), "response": rb}
+                break
+            time.sleep(args.monitor_interval)
+        else:
+            # staged-duration completed, allow full rollout (Controller handles staging)
+            report["staged_completed_at"] = datetime.utcnow().isoformat()
+    except Exception as e:
+        report["exception"] = str(e)
+        raise
+    finally:
+        Path(args.report).write_text(json.dumps(report, indent=2))
+        print("Wrote report to", args.report)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File: ci/.github/workflows/jetson_validation_and_promote.yml
+name: Jetson TensorRT Validation & Promote
+on:
+  workflow_dispatch:
+
+jobs:
+  validate-and-promote:
+    runs-on: [self-hosted, jetson]
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: "3.9"
+      - name: Install deps
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt || true
+      - name: Run TensorRT validation on device
+        env:
+          MLFLOW_RUN_ID: ${{ secrets.MLFLOW_RUN_ID }}
+          CONTROLLER_URL: ${{ secrets.CONTROLLER_URL }}
+          DEVICE_ID: ${{ secrets.DEVICE_ID }}
+        run: |
+          ./hardware/validation/validate_tensorrt_batch.sh --models ./out --mlflow-run-id $MLFLOW_RUN_ID --controller $CONTROLLER_URL --device-id $DEVICE_ID
+      - name: Verify Rekor entry and sign manifest
+        run: |
+          python ci/verify_rekor_before_promote.py --manifest manifest.json
+      - name: Create release via controller (only if validation passed)
+        run: |
+          python tools/create_release_with_checks.py --run-id ${{ secrets.MLFLOW_RUN_ID }} --manifest manifest.json --controller-url ${{ secrets.CONTROLLER_URL }} --api-key ${{ secrets.CONTROLLER_API_KEY }} --mlflow-uri ${{ secrets.MLFLOW_URI }}
+
*** End Patch
*** Begin Patch
*** Add File: k8s/fleet/controller/deployment_prod.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-fleet-controller
+  namespace: aegis
+  labels:
+    app: aegis-fleet-controller
+spec:
+  replicas: 3
+  selector:
+    matchLabels:
+      app: aegis-fleet-controller
+  strategy:
+    type: RollingUpdate
+    rollingUpdate:
+      maxUnavailable: 1
+      maxSurge: 1
+  template:
+    metadata:
+      labels:
+        app: aegis-fleet-controller
+    spec:
+      serviceAccountName: aegis-fleet-controller
+      containers:
+        - name: controller
+          image: aegis/fleet-controller:latest
+          ports:
+            - containerPort: 8080
+          env:
+            - name: DATABASE_URL
+              valueFrom:
+                secretKeyRef:
+                  name: postgres-secret
+                  key: database_url
+            - name: LEADER_ELECTION_ENABLE
+              value: "true"
+          readinessProbe:
+            httpGet:
+              path: /healthz
+              port: 8080
+            initialDelaySeconds: 10
+            periodSeconds: 5
+            failureThreshold: 3
+          livenessProbe:
+            httpGet:
+              path: /healthz
+              port: 8080
+            initialDelaySeconds: 30
+            periodSeconds: 20
+          resources:
+            requests:
+              cpu: "500m"
+              memory: "512Mi"
+            limits:
+              cpu: "2"
+              memory: "2Gi"
+
*** End Patch
*** Begin Patch
*** Add File: k8s/fleet/controller/hpa_pdb_prod.yaml
+apiVersion: autoscaling/v2
+kind: HorizontalPodAutoscaler
+metadata:
+  name: aegis-fleet-controller
+  namespace: aegis
+spec:
+  scaleTargetRef:
+    apiVersion: apps/v1
+    kind: Deployment
+    name: aegis-fleet-controller
+  minReplicas: 3
+  maxReplicas: 12
+  metrics:
+    - type: Resource
+      resource:
+        name: cpu
+        target:
+          type: Utilization
+          averageUtilization: 60
+
+---
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: aegis-fleet-controller-pdb
+  namespace: aegis
+spec:
+  minAvailable: 2
+  selector:
+    matchLabels:
+      app: aegis-fleet-controller
+
*** End Patch
*** Begin Patch
*** Add File: k8s/opa/admission_signed_images_gatekeeper.yaml
+apiVersion: templates.gatekeeper.sh/v1
+kind: ConstraintTemplate
+metadata:
+  name: k8ssignedimages
+spec:
+  crd:
+    spec:
+      names:
+        kind: K8sSignedImages
+  targets:
+    - target: admission.k8s.gatekeeper.sh
+      rego: |
+        package k8ssignedimages
+        violation[{"msg": msg}] {
+          input.review.object.kind == "Pod"
+          annotations := input.review.object.metadata.annotations
+          not annotations["aegis.cosign.signed"]
+          msg := sprintf("Pod %v does not have aegis.cosign.signed annotation", [input.review.object.metadata.name])
+        }
+
+---
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: K8sSignedImages
+metadata:
+  name: require-signed-images
+spec:
+  match:
+    kinds:
+      - apiGroups: [""]
+        kinds: ["Pod"]
+
*** End Patch
*** Begin Patch
*** Add File: scripts/vault/trigger_rotation_and_crl_publish.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Trigger Vault PKI rotation, generate CRL and publish to S3, then run CRL test against sample device cert.
+ROLE="${1:-aegis-device-role}"
+S3_BUCKET="${2:-my-aegis-crl-bucket}"
+DEVICE_CERT="${3:-/tmp/sample_device_cert.pem}"
+
+echo "Issuing new intermediate rotation (if supported by your Vault PKI)."
+# The exact command depends on Vault setup; we call a placeholder path that should exist in your env
+vault write -format=json pki_int/rotate || true
+
+echo "Exporting CRL from Vault"
+vault write -format=json pki_int/crl > /tmp/_crl.json
+jq -r '.data.certificate' /tmp/_crl.json > /tmp/aegis_crl.pem
+
+echo "Uploading CRL to s3://${S3_BUCKET}"
+aws s3 cp /tmp/aegis_crl.pem s3://${S3_BUCKET}/aegis_crl.pem --acl private
+
+echo "Testing CRL against provided device cert (if provided)"
+if [ -f "${DEVICE_CERT}" ]; then
+  python3 mdm/crl_rotation_test.py "${DEVICE_CERT}"
+else
+  echo "No device cert provided for test. You should fetch a device cert and run mdm/crl_rotation_test.py"
+fi
+
*** End Patch
*** Begin Patch
*** Add File: ci/.github/workflows/pilot_rollout_locust.yml
+name: Pilot Fleet Rollout Load Test
+on:
+  workflow_dispatch:
+
+jobs:
+  pilot-rollout:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup kubectl
+        run: |
+          sudo snap install kubectl --classic || true
+      - name: Deploy Locust master to cluster
+        run: |
+          kubectl apply -f k8s/locust/master-deployment.yaml
+      - name: Launch distributed workers (scale to simulate >=1k devices)
+        run: |
+          ./edge/loadtest/launch_locust_workers.sh 100 locust-master.aegis.svc.cluster.local
+      - name: Trigger release and monitor with Rollout Manager
+        env:
+          CONTROLLER_URL: ${{ secrets.CONTROLLER_URL }}
+          CONTROLLER_API_KEY: ${{ secrets.CONTROLLER_API_KEY }}
+        run: |
+          python rollout/rollout_manager.py --controller $CONTROLLER_URL --api-key $CONTROLLER_API_KEY --manifest manifest.json --release-name "pilot-$(date +%s)" --threshold 0.05 --monitor-interval 15 --staged-duration 900 --report /tmp/pilot_rollout_report.json
+      - name: Upload rollout report
+        uses: actions/upload-artifact@v4
+        with:
+          name: pilot-rollout-report
+          path: /tmp/pilot_rollout_report.json
+
*** End Patch
*** Begin Patch
*** Add File: docs/edge/pilot_rollout_runbook.md
+# Pilot Fleet Rollout Runbook (â‰¥1k devices)
+
+Purpose: validate a signed bundle rollout to a pilot fleet of >=1k devices with automatic rollback on metric thresholds.
+
+Preconditions:
+- manifest.json is cosign-signed using KMS/HSM and Rekor entry exists.
+- Jetson validation CI passed for relevant artifacts.
+- Locust master + workers deployed to generate pilot traffic (simulate fleet).
+- Controller, Postgres HA, and Prometheus monitoring are available.
+
+Steps:
+1. Kick off pilot rollout via Rollout Manager:
+   - python rollout/rollout_manager.py --controller <controller> --manifest manifest.json --release-name pilot-<ts> --threshold 0.05
+2. Rollout Manager will create release, monitor error_rate and rollout_pct and rollback automatically if err_rate > 5%.
+3. Monitor Grafana dashboard for device health and telemetry. If rollout manager triggers rollback, investigate device logs and MLflow artifacts, fix issue, re-sign manifest and re-run.
+
+Jetson Runner CI:
+- Ensure Jetson runners (>=3) execute validation job and upload results. Promotions are blocked if validation job fails.
+
+Post-deployment:
+- Gather acceptance evidence (report produced by rollout_manager) and upload to compliance artifacts store.
+
*** End Patch
*** End Patch
