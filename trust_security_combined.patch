*** Begin Patch
*** Add File: .github/workflows/cosign_verification_gate.yml
+name: Cosign & Rekor Verification Gate
+on:
+  push:
+    paths:
+      - 'models/**'
+      - 'artifacts/**'
+  workflow_dispatch:
+
+env:
+  # Set these in repository/organization secrets or replace with "I will inject later"
+  COSIGN_PUBLIC_KEY: ${{ secrets.COSIGN_PUBLIC_KEY }}     # cosign public key (PEM) to verify signatures
+  REKOR_SERVER: ${{ secrets.REKOR_SERVER }}               # e.g. https://rekor.example
+  # If using PKCS11 (HSM) in CI to sign, you'd use OIDC + short-lived creds; CI verification uses public key
+
+jobs:
+  verify-signature:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout repo
+        uses: actions/checkout@v4
+
+      - name: Install cosign and rekor-cli
+        run: |
+          curl -fsSL -o /usr/local/bin/cosign https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
+          chmod +x /usr/local/bin/cosign
+          curl -fsSL -o /usr/local/bin/rekor-cli https://github.com/sigstore/rekor/releases/latest/download/rekor-cli_$(uname -m)-linux
+          chmod +x /usr/local/bin/rekor-cli
+
+      - name: Find artifacts to verify
+        id: artifacts
+        run: |
+          # adapt paths to your artifact layout
+          ARTIFACTS=$(git ls-files 'models/**' 'artifacts/**' | head -n 50 || true)
+          echo "::set-output name=artifacts::$ARTIFACTS"
+      - name: Verify artifacts are cosign-signed and in Rekor
+        env:
+          COSIGN_PUBLIC_KEY: ${{ env.COSIGN_PUBLIC_KEY }}
+          REKOR_SERVER: ${{ env.REKOR_SERVER }}
+        run: |
+          set -euo pipefail
+          if [ -z "${{ steps.artifacts.outputs.artifacts }}" ]; then
+            echo "No artifacts found to verify -- passing gate."
+            exit 0
+          fi
+          for f in ${{ steps.artifacts.outputs.artifacts }}; do
+            echo "Verifying $f"
+            # Verify cosign signature (public key must be in repo secret)
+            if [ -n "$COSIGN_PUBLIC_KEY" ]; then
+              echo "$COSIGN_PUBLIC_KEY" > /tmp/cosign_pub.pem
+              cosign verify --key /tmp/cosign_pub.pem "$f" || (echo "cosign verify failed for $f" && exit 2)
+            else
+              echo "COSIGN_PUBLIC_KEY not set; skipping cosign verify (CI should set this secret)"
+            fi
+            # Verify Rekor contains an entry for this artifact (info only; we fail if not present)
+            if [ -n "$REKOR_SERVER" ]; then
+              rekor-cli search --rekor_server $REKOR_SERVER --artifact "$f" >/dev/null 2>&1 || (echo "No Rekor entry for $f" && exit 3)
+            else
+              echo "REKOR_SERVER not set; skipping Rekor check"
+            fi
+          done
+          echo "All artifacts verified"
+
*** End Patch
*** Begin Patch
*** Add File: tools/verify_cosign_and_rekor.sh
+#!/usr/bin/env bash
+# Verify an artifact is signed by cosign (public key) and present in Rekor
+# Usage: tools/verify_cosign_and_rekor.sh <artifact-path> <cosign-pub-pem> <rekor-server>
+set -euo pipefail
+ART=$1
+COSIGN_PUB=$2
+REKOR=$3
+
+if [ ! -f "$ART" ]; then echo "Missing artifact $ART"; exit 2; fi
+if [ ! -f "$COSIGN_PUB" ]; then echo "Missing public key $COSIGN_PUB"; exit 2; fi
+
+cosign verify --key "$COSIGN_PUB" "$ART"
+rekor-cli search --rekor_server "$REKOR" --artifact "$ART" >/dev/null 2>&1
+echo "Artifact $ART is cosign-signed and has a Rekor entry"
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/oidc_assume_role.yml
+name: OIDC Assume Role (example)
+on:
+  workflow_dispatch:
+
+jobs:
+  assume-role:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Assume AWS role via OIDC (example)
+        env:
+          ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}     # operator to set
+          REGION: ${{ secrets.AWS_REGION }}
+        run: |
+          # This demonstrates obtaining AWS temporary credentials via GitHub OIDC and aws sts assume-role-with-web-identity
+          # Requires role trust with GitHub OIDC provider in AWS.
+          echo "Requesting OIDC token..."
+          ID_TOKEN=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/actions/runs | head -n 1 || true)
+          # For production, use aws-actions/configure-aws-credentials action with OIDC
+          echo "OIDC/assume step is a placeholder; configure aws-actions/configure-aws-credentials in your workflows to obtain short-lived creds."
+
*** End Patch
*** Begin Patch
*** Add File: zero_trust/attestation/server.py
+#!/usr/bin/env python3
+"""
+Minimal attestation server (prototype).
+
+- Accepts TPM quotes (POST /attest) as file upload or base64 body with JSON metadata:
+  { "client_id": "...", "quote_path": "s3://..." } or multipart/form-data
+- Stores received artifacts and records a simple verification stub.
+- In production replace verification with an actual TPM quote verification pipeline.
+"""
+import os
+from flask import Flask, request, jsonify
+from datetime import datetime
+
+STORE_DIR = os.environ.get("ATTEST_STORE", "/var/lib/aegis/attestations")
+os.makedirs(STORE_DIR, exist_ok=True)
+
+app = Flask("aegis-attestation")
+
+@app.route("/attest", methods=["POST"])
+def attest():
+    client = request.form.get("client_id") or request.json.get("client_id") if request.is_json else None
+    if "quote" in request.files:
+        f = request.files["quote"]
+        fn = os.path.join(STORE_DIR, f"{client or 'anon'}_{int(datetime.utcnow().timestamp())}.bin")
+        f.save(fn)
+        # In real server, verify quote here with TPM attestation service
+        return jsonify({"status": "received", "path": fn})
+    # support JSON pointer to artifact location
+    data = request.json or {}
+    if data.get("quote_url"):
+        # In production: fetch the quote, validate signature etc.
+        return jsonify({"status": "queued", "note": "remote fetch not implemented in prototype"})
+    return jsonify({"error": "no quote provided"}), 400
+
+@app.route("/health")
+def health():
+    return jsonify({"status":"ok","ts":datetime.utcnow().isoformat()})
+
*** End Patch
*** Begin Patch
*** Add File: ansible/zero_trust/tpm_enroll.yml
+- name: TPM attestation automated enrollment
+  hosts: runners
+  become: true
+  vars:
+    attestation_server: "{{ attestation_server | default('https://attest.example') }}"
+  tasks:
+    - name: Ensure tpm2-tools installed
+      apt:
+        name: tpm2-tools
+        state: present
+      ignore_errors: yes
+
+    - name: Create TPM quote
+      shell: |
+        set -e
+        TMP_QUOTE=/tmp/tpm_quote.bin
+        if command -v tpm2_quote >/dev/null 2>&1; then
+          tpm2_quote -c 0x81010001 -l sha256:0x0004 -m "$TMP_QUOTE" || true
+        else
+          echo "tpm2_quote not available"
+        fi
+        echo "$TMP_QUOTE"
+      register: quote_path
+      ignore_errors: yes
+
+    - name: Upload quote to attestation server
+      uri:
+        url: "{{ attestation_server }}/attest"
+        method: POST
+        body_format: form-multipart
+        body:
+          client_id: "{{ inventory_hostname }}"
+          quote: "{{ lookup('file', quote_path.stdout) if quote_path.stdout is defined else '' }}"
+        status_code: [200,201,202]
+      ignore_errors: yes
+
+    - name: Debug attestation upload result
+      debug:
+        msg: "Uploaded quote for {{ inventory_hostname }} (operator must verify server)"
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/secret_rotate_cron.yml
+name: Scheduled Blind Secret Rotate
+on:
+  schedule:
+    - cron: "0 0 1 * *" # run monthly on 1st at 00:00 UTC
+  workflow_dispatch:
+
+jobs:
+  blind-rotate:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Run blind rotate helper
+        env:
+          SECRET_UPDATE_CMD: ${{ secrets.SECRET_UPDATE_CMD }} # admin command to update secret (must be set)
+        run: |
+          chmod +x security/secret_blind_rotate.sh || true
+          ./security/secret_blind_rotate.sh
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/sbom_sign_model.yml
+name: SBOM, Notebook Provenance & Model Card Sign
+on:
+  push:
+    paths:
+      - 'models/**'
+      - 'notebooks/**'
+  workflow_dispatch:
+
+jobs:
+  sbom_and_sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup
+        run: |
+          python -m pip install --upgrade pip
+          pip install nbformat mlflow
+          # syft optional: if available, the SBOM script uses it
+      - name: Generate SBOM for models
+        run: |
+          python sbom/sbom_generator.py --target models/ --out /tmp/sbom_models.json || true
+      - name: Notebook provenance
+        run: |
+          for nb in notebooks/*.ipynb; do
+            python sbom/notebook_provenance.py --notebook "$nb" --out "/tmp/prov_$(basename $nb .ipynb).json" || true
+          done
+      - name: Generate model card
+        run: |
+          python tools/generate_model_card.py --model-path models/ --out /tmp/model_card.json || true
+      - name: Sign model card with cosign (if configured)
+        env:
+          COSIGN_PKCS11_MODULE: ${{ secrets.COSIGN_PKCS11_MODULE }}   # optional
+          COSIGN_KEY_REF: ${{ secrets.COSIGN_KEY_REF }}               # optional, or use GitHub Secret with cosign key via OIDC/KMS
+        run: |
+          if [ -n "${COSIGN_PKCS11_MODULE:-}" ]; then
+            echo "Signing via PKCS11 not implemented in GH runner; operator must sign using HSM admin host."
+          else
+            echo "No PKCS11 module; use cosign with KMS or upload public key for verification."
+          fi
+      - name: Upload artifacts
+        uses: actions/upload-artifact@v4
+        with:
+          name: sbom-and-modelcard
+          path: /tmp/*.json
+
*** End Patch
*** Begin Patch
*** Add File: tools/generate_model_card.py
+#!/usr/bin/env python3
+"""
+Simple model card generator (prototype).
+Scans a model directory and generates a minimal model_card.json with provenance placeholders.
+"""
+import argparse
+import json
+import os
+from datetime import datetime
+
+def make_model_card(model_path, out):
+    model_name = os.path.basename(os.path.abspath(model_path))
+    mc = {
+        "model_name": model_name,
+        "generated": datetime.utcnow().isoformat(),
+        "description": "Model card (prototype) - fill with model metadata, datasets, fairness and safety notes.",
+        "provenance": {
+            "training_run": os.environ.get("MLFLOW_RUN_ID", ""),
+            "model_artifact": f"{model_path}",
+        },
+        "evaluation": {
+            "metrics": {},
+            "test_dataset": ""
+        },
+        "safety": {
+            "safety_tests": [],
+            "filters": []
+        }
+    }
+    with open(out, "w") as fh:
+        json.dump(mc, fh, indent=2)
+    print("Wrote model card to", out)
+
+if __name__ == "__main__":
+    p = argparse.ArgumentParser()
+    p.add_argument("--model-path", default="models/")
+    p.add_argument("--out", default="/tmp/model_card.json")
+    args = p.parse_args()
+    make_model_card(args.model_path, args.out)
+
*** End Patch
*** Begin Patch
*** Add File: docs/trust_security_README.md
+# Trust & Security Automation (Aegis)
+
+This folder adds prototypes and CI examples to enforce HSM-first signing, zero-trust enrollment, secret lifecycle rotation, and SBOM/model-card supply-chain checks.
+
+Key components added:
+- CI gate: `.github/workflows/cosign_verification_gate.yml` verifies cosign signatures and Rekor entries for artifacts.
+- OIDC example: `.github/workflows/oidc_assume_role.yml` demonstrates OIDC usage in GitHub Actions (use aws-actions/configure-aws-credentials for production).
+- TPM attestation server: `zero_trust/attestation/server.py` (prototype) to accept quotes.
+- TPM enrollment playbook: `ansible/zero_trust/tpm_enroll.yml` for device onboarding.
+- Secret rotation: `security/secret_blind_rotate.sh` (existing) and scheduled GH Action `.github/workflows/secret_rotate_cron.yml`.
+- SBOM & model card CI: `.github/workflows/sbom_sign_model.yml`, `tools/generate_model_card.py`, and SBOM/notebook provenance scripts.
+
+How this enforces HSM-first signing:
+- CI gate verifies artifacts are signed (cosign) and present in Rekor. In your production flow you should:
+  1. Sign artifacts using cosign via your HSM admin host (PKCS11), which will write an entry to Rekor.
+  2. Push artifacts to repository/storage.
+  3. CI gate verifies the presence of cosign signature and Rekor entry; if not present the promotion fails.
+
+Notes & next steps:
+- CI runners cannot access your HSM; signing must be done on the HSM-admin host (operator). CI then verifies the public evidence.
+- Replace prototype attestation server with a hardened service and integrate with your enrollment process and policy engine.
+- Wire cosign PKCS11 signing into your operator playbooks (scripts that run on HSM admin host).
+- Put COSIGN public keys and REKOR server URL into repository/org secrets for CI verification.
+
+Security disclaimers:
+- These scripts are prototypes and require integration with your operational security (Vault, IAM, HSM).
+- Do not store private keys in the repository. Use OIDC and KMS-backed signing where possible.
+
*** End Patch
*** Begin Patch
*** Add File: notes.txt
+Patch summary:
+- CI gates for cosign/Rekor verification
+- OIDC workflow example
+- TPM attestation server prototype + Ansible enrollment playbook
+- Scheduled blind secret rotation workflow
+- SBOM/notebook provenance + model card generation and CI artifact upload
+- README documenting usage and next steps
+
+Next recommended operator actions:
+1) Ensure cosign public key and REKOR_SERVER are set as repo secrets.
+2) Use HSM admin host to cosign artifacts with PKCS11 and push Rekor entries.
+3) Deploy attestation server and run ansible tpm_enroll.yml against sample devices.
+4) Enable scheduled blind rotate with a secure SECRET_UPDATE_CMD in repo secrets pointing to an admin secret updater.
+
+If you'd like, I can:
+- Produce the HSM admin host signing scripts that use cosign with PKCS11 and example commands (requires region/VPC/admin host info).
+- Wire the attestation server to validate TPM quotes (stub -> real verification steps) and produce an Ansible role to auto-enroll devices into k8s as trusted nodes.
+- Add an OPA policy example that blocks promotions when cosign/Rekor checks fail.
+
+Which of these do you want next?
+
*** End Patch
