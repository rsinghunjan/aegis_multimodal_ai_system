*** Begin Patch
*** Add File: .pre-commit-config.yaml
+repos:
+-   repo: https://github.com/zricethezav/gitleaks-pre-commit
+    rev: v1.5.0
+    hooks:
+    - id: gitleaks
+      args: ['--redact']
+-   repo: https://github.com/pre-commit/mirrors-mypy
+    rev: v0.982
+    hooks:
+    - id: mypy
+      stages: [commit]
+-   repo: https://github.com/pre-commit/pre-commit-hooks
+    rev: v4.4.0
+    hooks:
+    - id: check-yaml
+    - id: end-of-file-fixer
+    - id: trailing-whitespace
+
*** End Patch
*** Begin Patch
*** Add File: scripts/policy_linter.py
+#!/usr/bin/env python3
+"""
+policy_linter.py
+
+Static linter for generated IAM / policy JSON/YAML files.
+
+Checks for:
+ - wildcard principals/resources/actions ("*")
+ - overly-broad statements (e.g., "Allow * on *")
+ - AWS/KMS or OCI policy templates containing account-level scopes
+ - returns non-zero if any offending patterns found
+
+Usage:
+  python3 scripts/policy_linter.py [--root infra/iam,infra/oci]
+"""
+import argparse
+import json
+import os
+import re
+import sys
+import yaml
+from pathlib import Path
+
+DEFAULT_ROOTS = ["infra/iam", "infra/oci", "infra/helm", "infra/oci/policies"]
+
+WILDCARD_PATTERNS = [
+    re.compile(r'"\s*\*\s*"'),    # JSON "*" tokens
+    re.compile(r'\b\*\b'),        # literal star
+]
+
+SENSITIVE_KEYS = [
+    "Action",
+    "NotAction",
+    "Resource",
+    "Principal",
+    "Statement",
+    "Effect",
+]
+
+def load_file(path: Path):
+    try:
+        txt = path.read_text()
+        if path.suffix in (".yaml", ".yml"):
+            return list(yaml.safe_load_all(txt))
+        if path.suffix == ".json":
+            return [json.loads(txt)]
+        # fallback, return raw content
+        return [txt]
+    except Exception as e:
+        print(f"warn: failed to parse {path}: {e}")
+        return []
+
+def scan_json_like(obj, path_str, issues):
+    if isinstance(obj, dict):
+        for k, v in obj.items():
+            if isinstance(v, str):
+                if v.strip() == "*" or v.strip() == "\"*\"" or v.strip().lower() == "all":
+                    issues.append((path_str, f"Wildcard value for key {k}: {v}"))
+                if k in ("Action", "NotAction") and isinstance(v, str) and "*" in v:
+                    issues.append((path_str, f"Wildcard action: {v}"))
+            scan_json_like(v, path_str, issues)
+    elif isinstance(obj, list):
+        for i, item in enumerate(obj):
+            scan_json_like(item, f"{path_str}[{i}]", issues)
+    else:
+        # primitive
+        return
+
+def quick_text_scan(text, path_str, issues):
+    # detect patterns like "Resource": "*" or "Action": "*"
+    # Also detect account-level "arn:aws:s3:::*" style broad resources
+    if re.search(r'["\']Resource["\']\s*:\s*["\']\*["\']', text):
+        issues.append((path_str, "Resource set to '*'"))
+    if re.search(r'["\']Action["\']\s*:\s*["\']\*["\']', text):
+        issues.append((path_str, "Action set to '*'"))
+    if re.search(r'arn:aws:[^:]+::\*', text):
+        issues.append((path_str, "Account-level ARN wildcard detected"))
+    # OCI broad statements
+    if re.search(r'allow\s+dynamic-group\s+.*\s+to\s+manage\s+.*', text, re.IGNORECASE):
+        # allow manage may be too broad - flag for review
+        issues.append((path_str, "Potentially broad 'manage' permission in OCI policy; review scope"))
+    return
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--roots", default=",".join(DEFAULT_ROOTS), help="Comma-separated roots to lint")
+    args = p.parse_args()
+    roots = [r for r in args.roots.split(",") if r]
+    issues = []
+    files_scanned = 0
+
+    for root in roots:
+        root_path = Path(root)
+        if not root_path.exists():
+            continue
+        for path in root_path.rglob("*"):
+            if path.is_dir():
+                continue
+            files_scanned += 1
+            content = path.read_text(errors="ignore")
+            # quick textual checks
+            quick_text_scan(content, str(path), issues)
+            # try to parse JSON/YAML-like
+            for doc in load_file(path):
+                if doc:
+                    scan_json_like(doc, str(path), issues)
+
+    if issues:
+        print("Policy linter found issues (needs manual review):")
+        for pth, msg in issues:
+            print(f"- {pth}: {msg}")
+        print(f"Files scanned: {files_scanned}")
+        print("Failing CI to require manual security review.")
+        sys.exit(2)
+    else:
+        print(f"No obvious policy wildcard issues found across {files_scanned} files.")
+        sys.exit(0)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File: scripts/check_workflows_for_static_secrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# check_workflows_for_static_secrets.sh
+#
+# Scans .github/workflows/*.yml for direct references to classic cloud secrets (AWS keys, OCI private keys, plain API keys)
+# and for patterns that suggest long-lived credentials usage in workflows.
+#
+# This script is intended to run in CI on pull_request to fail PRs that introduce new workflows referencing static secrets.
+#
+WORKFLOW_DIR=".github/workflows"
+FAIL=0
+
+if [ ! -d "$WORKFLOW_DIR" ]; then
+  echo "No workflows directory found; skipping check."
+  exit 0
+fi
+
+echo "Scanning workflow files for static secret usage..."
+for f in "$WORKFLOW_DIR"/*.yml "$WORKFLOW_DIR"/*.yaml; do
+  [ -f "$f" ] || continue
+  echo "Checking $f"
+  # common problematic literals
+  if grep -E "AWS_ACCESS_KEY_ID|AWS_SECRET_ACCESS_KEY|OCI_PRIVATE_KEY|OCI_FINGERPRINT|AZURE_CREDENTIALS" "$f" >/dev/null 2>&1; then
+    echo "ERROR: $f references classic cloud secrets identifiers. Prefer GitHub OIDC or environment secrets masked in Actions."
+    FAIL=1
+  fi
+  # detect inline private key blocks (-----BEGIN RSA PRIVATE KEY-----)
+  if grep -q "BEGIN RSA PRIVATE KEY" "$f" || grep -q "BEGIN PRIVATE KEY" "$f"; then
+    echo "ERROR: $f contains an inline private key pattern. Do not commit keys into workflows."
+    FAIL=1
+  fi
+  # detect usage of env: | or multi-line secrets
+  if grep -E "echo .*\\n|echo \\$\\{\\{ secrets\\." "$f" >/dev/null 2>&1; then
+    # allow usage of secrets.* but flag if they appear unguarded in pull_request contexts
+    echo "Note: $f uses secrets.* — ensure workflows are restricted to trusted branches or use OIDC."
+  fi
+done
+
+if [ "$FAIL" -eq 1 ]; then
+  echo "Workflow static secret checks failed. Please remove hard-coded/explicit secret references and prefer OIDC/token-based access."
+  exit 2
+fi
+
+echo "Workflow security scan passed."
+exit 0
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_security_checks.yml
+name: CI Security Checks (pre-merge)
+
+on:
+  pull_request:
+    types: [opened, synchronize, reopened]
+
+permissions:
+  contents: read
+
+jobs:
+  pre-merge-security:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Run gitleaks (secret scan)
+        uses: zricethezav/gitleaks-action@v1
+        with:
+          args: --path=. --redact
+
+      - name: Run policy linter
+        uses: actions/setup-python@v4
+      - name: Install python deps
+        run: |
+          python -m pip install --upgrade pip
+      - name: Run policy_linter
+        run: |
+          python3 scripts/policy_linter.py --roots infra/iam,infra/oci,infra/helm || exit 2
+
+      - name: Check workflows for static secrets
+        run: |
+          chmod +x scripts/check_workflows_for_static_secrets.sh
+          ./scripts/check_workflows_for_static_secrets.sh
+
+      - name: Require Security signoff if policy changes detected
+        id: check_changes
+        run: |
+          # If any infra/iam or infra/oci files were changed in the PR, require security-review label
+          git fetch origin ${{ github.base_ref }} --depth=1 || true
+          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || true)
+          echo "Changed files: $CHANGED_FILES"
+          echo "$CHANGED_FILES" | grep -E '^infra/(iam|oci)/' >/dev/null 2>&1
+          if [ $? -eq 0 ]; then
+            echo "Policy/identity files changed; verify PR has label 'security-review'"
+            # Fail the job if label not present (GitHub Actions does not expose PR labels reliably here without token)
+            # Best-effort: check for environment variable set by repo-level labeler, otherwise print instructions and fail.
+            if [ -z "${{ github.event.pull_request.labels || '' }}" ]; then
+              echo "Security label check: cannot read labels in this environment; maintainers must ensure 'security-review' label is applied."
+              echo "Failing build to force explicit review."
+              exit 2
+            fi
+          else
+            echo "No infra IAM/OCI changes detected; continuing."
+          fi
+
+      - name: Success
+        run: echo "Security pre-merge checks passed or PR flagged for manual review."
+
*** End Patch
*** Begin Patch
*** Add File: scripts/rotate_kms_aws.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# rotate_kms_aws.sh
+#
+# - Creates a new AWS KMS CMK (symmetric) with an alias
+# - Creates a grant allowing the specified role to use the key
+# - Suggests helm value updates and optionally runs a staging backup to validate new-key encryption
+#
+# Usage:
+#   ./scripts/rotate_kms_aws.sh --alias alias/aegis-backup-20251201 --role-arn arn:aws:iam::123456789012:role/aegis-backup-irsa-role --run-drill yes|no --bucket my-bucket
+#
+
+ALIAS=""
+ROLE_ARN=""
+RUN_DRILL="no"
+BUCKET=""
+
+usage() {
+  cat <<EOF
+Usage: $0 --alias <alias/name> --role-arn <role_arn> [--run-drill yes|no] [--bucket BUCKET]
+EOF
+}
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --alias) ALIAS="$2"; shift 2;;
+    --role-arn) ROLE_ARN="$2"; shift 2;;
+    --run-drill) RUN_DRILL="$2"; shift 2;;
+    --bucket) BUCKET="$2"; shift 2;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$ALIAS" ] || [ -z "$ROLE_ARN" ]; then
+  usage
+  exit 2
+fi
+
+echo "[aws-rotate] Creating new KMS key"
+KEY_JSON=$(aws kms create-key --description "Aegis backup rotation $(date -u +%Y%m%dT%H%M%SZ)" --query KeyMetadata --output json)
+KEY_ID=$(echo "$KEY_JSON" | python3 -c "import sys,json;print(json.load(sys.stdin)['KeyId'])")
+KEY_ARN=$(echo "$KEY_JSON" | python3 -c "import sys,json;print(json.load(sys.stdin)['Arn'])")
+echo "[aws-rotate] Created key: id=$KEY_ID arn=$KEY_ARN"
+
+echo "[aws-rotate] Creating alias ${ALIAS}"
+aws kms create-alias --alias-name "$ALIAS" --target-key-id "$KEY_ID" || echo "[aws-rotate] alias creation may have failed (may already exist)"
+
+echo "[aws-rotate] Creating KMS grant for ${ROLE_ARN}"
+set +e
+GRANT_JSON=$(aws kms create-grant --key-id "$KEY_ID" --grantee-principal "$ROLE_ARN" --operations Encrypt Decrypt GenerateDataKey ReEncryptFrom ReEncryptTo --name "AegisBackupGrant-$(date -u +%Y%m%d%H%M%SZ)" 2>/dev/null)
+if [ $? -ne 0 ]; then
+  echo "[aws-rotate] create-grant may have failed or insufficient permissions. Please create a grant manually for role ${ROLE_ARN} to use key ${KEY_ID}."
+else
+  echo "[aws-rotate] Grant created."
+fi
+set -e
+
+echo "[aws-rotate] New keyARN=${KEY_ARN}"
+echo "[aws-rotate] Next steps:"
+echo " - Update your infra/overrides/aws/milvus-values-aws.yaml to point to the new KMS alias or ARN for server-side encryption."
+echo "   Example: set backup.s3.kmsKeyArn: ${KEY_ARN} (or alias/NAME)"
+echo " - Run a staging backup and verify uploaded objects have SSE-KMSKeyId pointing to the new key:"
+echo "   ./scripts/aws_backup_restore_drill.sh --namespace aegis --backup-job aegis-milvus-backup --s3-bucket ${BUCKET}"
+echo "   ./scripts/aws_verify_restore_integrity.sh --bucket ${BUCKET} --prefix <detected_prefix> --expected-kms-arn ${KEY_ARN}"
+
+if [ "$RUN_DRILL" = "yes" ]; then
+  if [ -z "$BUCKET" ]; then
+    echo "[aws-rotate] --bucket is required when --run-drill yes"
+    exit 2
+  fi
+  echo "[aws-rotate] Running staging drill to validate rotation..."
+  chmod +x scripts/aws_backup_restore_drill.sh scripts/aws_verify_restore_integrity.sh
+  ./scripts/aws_backup_restore_drill.sh --namespace "${STAGING_NAMESPACE:-aegis}" --backup-job "${AWS_BACKUP_CRONJOB:-aegis-milvus-backup}" --s3-bucket "${BUCKET}"
+  # detect latest prefix as in other scripts
+  LATEST=$(aws s3 ls "s3://${BUCKET}/backups/" --recursive | sort | tail -n 1 | awk '{print $4}' || true)
+  PREFIX=$(dirname "$LATEST")
+  ./scripts/aws_verify_restore_integrity.sh --bucket "${BUCKET}" --prefix "${PREFIX}" --expected-kms-arn "${KEY_ARN}"
+fi
+
+echo "[aws-rotate] Rotation orchestration complete. Do not retire old keys until you verified ability to decrypt historic backups."
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/kms_rotation_staging.yml
+name: KMS Rotation — Staging Orchestrator
+
+on:
+  workflow_dispatch:
+    inputs:
+      cloud:
+        description: 'cloud (aws|azure|gcp|oci)'
+        required: true
+        default: 'aws'
+      run_drill:
+        description: 'Run staging drill after rotation (yes|no)'
+        required: false
+        default: 'yes'
+
+permissions:
+  contents: read
+
+jobs:
+  rotate:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Configure AWS (if aws)
+        if: ${{ github.event.inputs.cloud == 'aws' }}
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
+          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
+          aws-region: ${{ secrets.AWS_REGION }}
+
+      - name: Run AWS rotation (manual)
+        if: ${{ github.event.inputs.cloud == 'aws' }}
+        env:
+          STAGING_NAMESPACE: ${{ secrets.STAGING_NAMESPACE }}
+          AWS_BACKUP_CRONJOB: ${{ secrets.AWS_BACKUP_CRONJOB }}
+        run: |
+          chmod +x scripts/rotate_kms_aws.sh
+          ./scripts/rotate_kms_aws.sh --alias "alias/aegis-backup-$(date +%Y%m%d%H%M%S)" --role-arn "${{ secrets.AWS_IRSA_ROLE_ARN }}" --run-drill "${{ github.event.inputs.run_drill }}" --bucket "${{ secrets.AWS_BACKUP_BUCKET }}"
+
*** End Patch
*** Begin Patch
*** Add File: docs/security_hardening.md
+# Security Hardening: Secrets, KMS Rotation, Policy Review & CI Safety
+
+This patch adds automation and checks aimed at closing critical weaknesses in secrets lifecycle, key management and policy application.
+
+What was added
+- Pre-commit/gitleaks configuration to prevent committing secrets (.pre-commit-config.yaml)
+- CI pre-merge job (.github/workflows/ci_security_checks.yml) that:
+  - runs gitleaks secret scan
+  - runs a static policy linter (scripts/policy_linter.py)
+  - scans workflow files for static secret references (scripts/check_workflows_for_static_secrets.sh)
+  - enforces explicit security review when infra/iam or infra/oci files change (best-effort)
+- KMS rotation helper for AWS (scripts/rotate_kms_aws.sh) and a staged workflow to run rotations (.github/workflows/kms_rotation_staging.yml)
+- Policy linter to detect wildcard or overly-broad permissions (scripts/policy_linter.py)
+- Workflow security check script to detect workflows that embed secrets (scripts/check_workflows_for_static_secrets.sh)
+
+How this helps
+- Prevents accidental commit of static credentials
+- Flags generated IAM/policy templates with wildcard scopes before they are merged
+- Provides an opinionated, auditable rotation path for AWS KMS keys (staging rotation + validation)
+- Promotes OIDC usage and explicit security review for policy changes
+
+Recommended follow-ups (manual actions)
+- Enforce repository-level "Require status checks" for the `pre-merge-security` job so PRs cannot merge without passing checks.
+- Configure GitHub Environments / Protection rules for workflows that perform dangerous changes (e.g., KMS/key creation) to require manual approvals.
+- Convert cloud workflows to use GitHub Actions OIDC where possible (AWS OIDC, Azure, GCP) and remove classic static API keys from repo secrets.
+- Add the `security-review` label workflow or use CODEOWNERS to ensure security team review for infra/iam changes.
+- Add cloud-specific rotation scripts for GCP/OCI and integrate into the `.github/workflows/kms_rotation_staging.yml` dispatcher.
+
+Usage notes
+- Install pre-commit locally: `pip install pre-commit && pre-commit install`
+- Run checks locally: `pre-commit run --all-files` and `python3 scripts/policy_linter.py`
+- The included AWS rotation script requires `aws` CLI configured and sufficient IAM permissions. It does NOT automatically re-encrypt historic objects — that must be planned per environment.
+
*** End Patch
