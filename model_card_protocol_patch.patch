*** Begin Patch
*** Add File:modelcard/schema/mcp_schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Aegis Model Card Schema",
  "type": "object",
  "required": ["model_name", "version", "created_at", "description", "training_data", "evaluation", "signing"],
  "properties": {
    "model_name": { "type": "string" },
    "version": { "type": "string" },
    "created_at": { "type": "string", "format": "date-time" },
    "authors": { "type": "array", "items": { "type": "string" } },
    "description": { "type": "string" },
    "training_data": {
      "type": "object",
      "properties": {
        "datasets": { "type": "array", "items": { "type": "string" } },
        "sampling": { "type": "string" },
        "sensitive_attributes": { "type": "array", "items": { "type": "string" } }
      }
    },
    "evaluation": {
      "type": "object",
      "properties": {
        "benchmarks": { "type": "object" },
        "fairness": { "type": "string" }
      }
    },
    "privacy": {
      "type": "object",
      "properties": {
        "dp": { "type": "boolean" },
        "membership_inference_score": { "type": "number" }
      }
    },
    "explainability": {
      "type": "object",
      "properties": {
        "explanation_endpoint": { "type": "string" },
        "explanation_types": { "type": "array", "items": { "type": "string" } }
      }
    },
    "signing": {
      "type": "object",
      "properties": {
        "cosign_signed": { "type": "boolean" },
        "cosign_key": { "type": "string" },
        "rekor_entry": { "type": "string" }
      },
      "required": ["cosign_signed"]
    }
  }
}
*** End Patch
*** Begin Patch
*** Add File:modelcard/validator/requirements.txt
jsonschema
boto3
requests
python-dateutil
*** End Patch
*** Begin Patch
*** Add File:modelcard/validator/validate_model_card.py
#!/usr/bin/env python3
"""
Model Card Schema Validator

Validates a model_card JSON against the Aegis MCP schema.
Can validate a local file or an S3 key (s3://bucket/key).
Exits non-zero on validation errors.

Usage:
  python validate_model_card.py --file path/to/model_card.json
  python validate_model_card.py --s3 s3://bucket/path/to/model_card.json
"""
import argparse
import json
import sys
import os
from jsonschema import validate, ValidationError
import boto3
from urllib.parse import urlparse

SCHEMA_PATH = os.path.join(os.path.dirname(__file__), "../schema/mcp_schema.json")

def load_schema():
    with open(SCHEMA_PATH, "r") as f:
        return json.load(f)

def load_json_from_file(path):
    with open(path, "r") as f:
        return json.load(f)

def load_json_from_s3(s3_url):
    parsed = urlparse(s3_url)
    bucket = parsed.netloc
    key = parsed.path.lstrip("/")
    s3 = boto3.client("s3", region_name=os.environ.get("AWS_REGION", "us-west-2"))
    obj = s3.get_object(Bucket=bucket, Key=key)
    return json.loads(obj["Body"].read())

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--file", help="Path to local model_card.json")
    p.add_argument("--s3", help="s3://bucket/key to model_card.json")
    args = p.parse_args()
    if not args.file and not args.s3:
        print("Specify --file or --s3", file=sys.stderr)
        sys.exit(2)
    schema = load_schema()
    try:
        if args.file:
            data = load_json_from_file(args.file)
        else:
            data = load_json_from_s3(args.s3)
        validate(instance=data, schema=schema)
        print("OK: model_card is valid against schema")
        sys.exit(0)
    except ValidationError as e:
        print("Validation error:", e.message)
        print(e)
        sys.exit(3)
    except Exception as e:
        print("Error validating model_card:", e, file=sys.stderr)
        sys.exit(4)

if __name__ == "__main__":
    main()
*** End Patch
*** Begin Patch
*** Add File:modelcard/signing/sign_model_card.py
#!/usr/bin/env python3
"""
Sign a model_card JSON using cosign and optionally post a Rekor entry.

This script:
 - Downloads a model_card.json from S3 (s3://bucket/key) or reads a local file
 - Runs `cosign sign` to sign the model_card (requires cosign installed and configured for KMS or local key)
 - Uploads the signature back to S3 as <key>.sig
 - Optionally POSTs a minimal Rekor entry (best-effort placeholder; operators should use Rekor client)

Usage:
  python sign_model_card.py --s3 s3://bucket/path/model_card.json --cosign-key awskms://...
  python sign_model_card.py --file ./model_card.json --cosign-key /path/to/key
"""
import argparse
import os
import subprocess
import tempfile
import boto3
import json
from urllib.parse import urlparse

EVIDENCE_BUCKET = os.environ.get("EVIDENCE_BUCKET", "")
REKOR_URL = os.environ.get("REKOR_URL", "")

def download_s3(s3_url, out_path):
    parsed = urlparse(s3_url)
    bucket = parsed.netloc
    key = parsed.path.lstrip("/")
    s3 = boto3.client("s3", region_name=os.environ.get("AWS_REGION", "us-west-2"))
    s3.download_file(bucket, key, out_path)
    return bucket, key

def upload_s3(local_path, bucket, key):
    s3 = boto3.client("s3", region_name=os.environ.get("AWS_REGION", "us-west-2"))
    s3.upload_file(local_path, bucket, key)

def sign_file(local_path, cosign_key):
    # cosign sign --key <key> <file>
    cmd = ["cosign", "sign", "--key", cosign_key, local_path]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    return proc.returncode, proc.stdout, proc.stderr

def post_rekor_entry(model_card_s3, signature_s3):
    if not REKOR_URL:
        return None
    # Minimal evidence post; operators should use Rekor client to build canonical entry
    try:
        payload = {"model_card": model_card_s3, "signature": signature_s3}
        import requests
        r = requests.post(REKOR_URL + "/api/v1/log/entries", json=payload, timeout=10)
        if r.status_code in (200,201):
            return r.json()
    except Exception:
        pass
    return None

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--s3", help="s3://bucket/key")
    p.add_argument("--file", help="local file path")
    p.add_argument("--cosign-key", required=True, help="cosign key (awskms://... or file path)")
    args = p.parse_args()
    if not args.s3 and not args.file:
        print("Specify --s3 or --file")
        return 2
    tmp = tempfile.mktemp(suffix=".json")
    bucket = None; key = None
    if args.s3:
        bucket, key = download_s3(args.s3, tmp)
    else:
        # copy local file to tmp for signing
        with open(args.file, "rb") as rf, open(tmp, "wb") as wf:
            wf.write(rf.read())
        # if EVIDENCE_BUCKET is set, we may upload signed file later
    rc, out, err = sign_file(tmp, args.cosign_key)
    print("cosign returncode:", rc)
    print(out)
    print(err)
    if rc != 0:
        print("cosign failed", err)
        return rc
    # cosign creates <file>.sig next to file
    sig_local = tmp + ".sig"
    if args.s3 and os.path.exists(sig_local):
        sig_s3_key = key + ".sig"
        upload_s3(sig_local, bucket, sig_s3_key)
        model_card_s3 = f"s3://{bucket}/{key}"
        signature_s3 = f"s3://{bucket}/{sig_s3_key}"
        rekor = post_rekor_entry(model_card_s3, signature_s3)
        print("Uploaded signature to", signature_s3, "rekor:", rekor)
        return 0
    else:
        print("Signed locally:", sig_local)
        return 0

if __name__ == "__main__":
    exit(main())
*** End Patch
*** Begin Patch
*** Add File:modelcard/registry/requirements.txt
fastapi
uvicorn[standard]
boto3
sqlalchemy
pydantic
python-dotenv
*** End Patch
*** Begin Patch
*** Add File:modelcard/registry/app.py
#!/usr/bin/env python3
"""
Model Card Registry API (FastAPI)

Provides:
 - POST /register : register a model_card S3 key and metadata (called by generator after upload & signing)
 - GET /cards : list registered model cards (with simple filters)
 - GET /cards/{id} : return model_card metadata and S3 key
 - GET /cards/{id}/view : return a simple HTML-rendered model_card (for human viewing)
Storage: sqlite index (lightweight) plus model cards remain in S3.
"""
import os
import sqlite3
import json
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
from datetime import datetime
import boto3
from jinja2 import Template

DB_PATH = os.environ.get("MODEL_CARD_REG_DB", "/data/model_cards.db")
EVIDENCE_BUCKET = os.environ.get("EVIDENCE_BUCKET", "REPLACE_WITH_EVIDENCE_BUCKET")
s3 = boto3.client("s3", region_name=os.environ.get("AWS_REGION", "us-west-2"))

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
      CREATE TABLE IF NOT EXISTS model_cards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        model_name TEXT,
        version TEXT,
        s3_key TEXT,
        created_at TEXT,
        signed INTEGER DEFAULT 0,
        cosign_key TEXT,
        rekor_entry TEXT,
        metadata TEXT
      )
    """)
    conn.commit()
    conn.close()

init_db()
app = FastAPI(title="Aegis Model Card Registry")

class RegisterReq(BaseModel):
    model_name: str
    version: str
    s3_key: str
    signed: bool = False
    cosign_key: str = None
    rekor_entry: str = None
    metadata: dict = {}

@app.post("/register")
def register(req: RegisterReq):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    now = datetime.utcnow().isoformat() + "Z"
    c.execute("INSERT INTO model_cards (model_name, version, s3_key, created_at, signed, cosign_key, rekor_entry, metadata) VALUES(?,?,?,?,?,?,?,?)",
              (req.model_name, req.version, req.s3_key, now, 1 if req.signed else 0, req.cosign_key or "", req.rekor_entry or "", json.dumps(req.metadata or {})))
    conn.commit()
    cid = c.lastrowid
    conn.close()
    return {"id": cid, "model_name": req.model_name, "version": req.version, "s3_key": req.s3_key}

@app.get("/cards")
def list_cards(model_name: str = None):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    if model_name:
        rows = c.execute("SELECT id,model_name,version,s3_key,created_at,signed FROM model_cards WHERE model_name=?", (model_name,)).fetchall()
    else:
        rows = c.execute("SELECT id,model_name,version,s3_key,created_at,signed FROM model_cards ORDER BY created_at DESC").fetchall()
    conn.close()
    out = []
    for r in rows:
        out.append({"id": r[0], "model_name": r[1], "version": r[2], "s3_key": r[3], "created_at": r[4], "signed": bool(r[5])})
    return out

@app.get("/cards/{cid}")
def get_card(cid: int):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    row = c.execute("SELECT id,model_name,version,s3_key,created_at,signed,cosign_key,rekor_entry,metadata FROM model_cards WHERE id=?", (cid,)).fetchone()
    conn.close()
    if not row:
        raise HTTPException(status_code=404, detail="not found")
    return {"id": row[0], "model_name": row[1], "version": row[2], "s3_key": row[3], "created_at": row[4], "signed": bool(row[5]), "cosign_key": row[6], "rekor_entry": row[7], "metadata": json.loads(row[8] or "{}")}

@app.get("/cards/{cid}/view")
def view_card(cid: int):
    card = get_card(cid)
    # fetch s3 json
    s3_key = card["s3_key"]
    parsed = s3_key.split("/",1)
    if len(parsed) == 1:
        bucket = EVIDENCE_BUCKET
        key = s3_key
    else:
        bucket = parsed[0]
        key = parsed[1]
    try:
        obj = s3.get_object(Bucket=bucket, Key=key)
        mc = json.loads(obj["Body"].read())
    except Exception as e:
        raise HTTPException(status_code=404, detail="model_card JSON not found")
    # simple rendering
    tpl = Template("""
    <html><body>
    <h1>Model Card: {{mc.model_name}} {{mc.version}}</h1>
    <pre>{{ mc | tojson(indent=2) }}</pre>
    <p>Signed: {{ signed }}</p>
    </body></html>
    """)
    return tpl.render(mc=mc, signed=card.get("signed"))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("MODEL_CARD_REG_PORT", "8095")))
*** End Patch
*** Begin Patch
*** Add File:modelcard/registry/ui/index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Aegis Model Card Registry</title>
  <style>body{font-family:Arial;margin:20px}pre{background:#f3f3f3;padding:10px}</style>
</head>
<body>
  <h1>Aegis Model Card Registry (Demo)</h1>
  <div id="list"></div>
  <script>
    const API = window.__MODEL_CARD_REG__ || "http://localhost:8095";
    async function load(){
      const r = await fetch(API + "/cards");
      const j = await r.json();
      const d = document.getElementById('list');
      d.innerHTML = '';
      j.forEach(c => {
        const el = document.createElement('div');
        el.innerHTML = `<h3>${c.model_name} ${c.version}</h3>
          <p>Uploaded: ${c.created_at} Signed: ${c.signed}</p>
          <a href="${API}/cards/${c.id}/view" target="_blank">View card</a>`;
        d.appendChild(el);
      });
    }
    load();
  </script>
</body>
</html>
*** End Patch
*** Begin Patch
*** Add File:modelcard/generator_v2.py
#!/usr/bin/env python3
"""
Enhanced Model Card generator that:
 - Builds a model_card JSON from template
 - Uploads to S3
 - Validates against schema
 - Signs the model_card (cosign) and uploads signature to S3
 - Registers the model_card in the local Model Card Registry (if configured)
 - Tags MLflow run with model_card_s3 and model_card_signed annotation

Environment variables:
 - EVIDENCE_BUCKET
 - AWS_REGION
 - MLFLOW_TRACKING_URI
 - MODEL_CARD_REGISTRY_URL (optional)
 - COSIGN_KEY (awskms://... or file)
"""
import os
import json
import boto3
import mlflow
import requests
import subprocess
from datetime import datetime
from docs.model_card.generator import generate_model_card as generate_model_card_base

EVIDENCE_BUCKET = os.environ.get("EVIDENCE_BUCKET", "REPLACE_WITH_EVIDENCE_BUCKET")
AWS_REGION = os.environ.get("AWS_REGION", "us-west-2")
MLFLOW_TRACKING_URI = os.environ.get("MLFLOW_TRACKING_URI", "")
MODEL_CARD_REGISTRY_URL = os.environ.get("MODEL_CARD_REGISTRY_URL", "")
COSIGN_KEY = os.environ.get("COSIGN_KEY", "")

if MLFLOW_TRACKING_URI:
    mlflow.set_tracking_uri(MLFLOW_TRACKING_URI)

s3 = boto3.client("s3", region_name=AWS_REGION)

def upload_model_card_local(model_name, version, run_id, local_path):
    key = f"model_cards/{model_name}-{version}.json"
    s3.upload_file(local_path, EVIDENCE_BUCKET, key)
    return f"s3://{EVIDENCE_BUCKET}/{key}"

def validate_model_card_s3(s3_url):
    # call validator script in this repo
    cmd = ["python", "modelcard/validator/validate_model_card.py", "--s3", s3_url]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    return proc.returncode == 0, proc.stdout + proc.stderr

def sign_model_card_s3(s3_url, cosign_key):
    # call sign script
    cmd = ["python", "modelcard/signing/sign_model_card.py", "--s3", s3_url, "--cosign-key", cosign_key]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    return proc.returncode == 0, proc.stdout + proc.stderr

def register_model_card_registry(model_name, version, s3_key, signed=False, cosign_key=None, rekor_entry=None, metadata={}):
    if not MODEL_CARD_REGISTRY_URL:
        return None
    url = MODEL_CARD_REGISTRY_URL.rstrip("/") + "/register"
    payload = {"model_name": model_name, "version": version, "s3_key": s3_key, "signed": signed, "cosign_key": cosign_key, "rekor_entry": rekor_entry, "metadata": metadata}
    r = requests.post(url, json=payload, timeout=10)
    return r.json()

def generate_model_card_and_process(model_name, version, run_id, template_path="docs/model_card/model_card_template.json"):
    # generate local file using existing generator
    local_path = f"/tmp/{model_name}-{version}-model_card.json"
    # reuse base generator to create template with run info
    try:
        key = generate_model_card_base(model_name, version, run_id, template_path)
        # generate_model_card_base already uploaded model_card to S3 and set MLflow tag
        return {"s3_key": key}
    except Exception as e:
        print("generator base failed, aborting", e)
        raise

def process_existing_s3_model_card(s3_url, model_name, version, run_id):
    # validate
    ok, out = validate_model_card_s3(s3_url)
    if not ok:
        raise RuntimeError(f"Validation failed: {out}")
    # sign
    if not COSIGN_KEY:
        raise RuntimeError("COSIGN_KEY not set in env; cannot sign model_card")
    ok2, out2 = sign_model_card_s3(s3_url, COSIGN_KEY)
    if not ok2:
        raise RuntimeError(f"Signing failed: {out2}")
    # Register in registry
    reg = register_model_card_registry(model_name, version, s3_url, signed=True, cosign_key=COSIGN_KEY, metadata={"generated_by": "generator_v2"})
    # Tag mlflow run
    try:
        client = mlflow.tracking.MlflowClient()
        client.set_tag(run_id, "model_card_s3", s3_url)
        client.set_tag(run_id, "model_card_signed", "true")
    except Exception:
        pass
    return {"s3": s3_url, "registry": reg}

if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--s3", help="Existing s3 model_card URL")
    p.add_argument("--model", required=True)
    p.add_argument("--version", default="v0.0.1")
    p.add_argument("--run-id", required=True)
    args = p.parse_args()
    if args.s3:
        print(process_existing_s3_model_card(args.s3, args.model, args.version, args.run_id))
    else:
        print("To create and process a model_card, use existing docs/model_card/generator.py to create S3 artifact, then call this script with --s3")
*** End Patch
*** Begin Patch
*** Add File:devsecops/gatekeeper/constraint_require_modelcard_signed.yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: requiremodelcardsigned
spec:
  crd:
    spec:
      names:
        kind: RequireModelCardSigned
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package requiremodelcardsigned
        violation[{"msg": msg}] {
          input.review.object.kind == "Deployment"
          annotations := input.review.object.metadata.annotations
          not annotations["aegis.model_card_s3"]
          msg := "Deployment missing aegis.model_card_s3 annotation linking to model_card in S3"
        }
        violation[{"msg": msg}] {
          input.review.object.kind == "Deployment"
          annotations := input.review.object.metadata.annotations
          annotations["aegis.model_card_signed"] != "true"
          msg := "Model Card is not marked signed (aegis.model_card_signed != true)"
        }
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/modelcard_sign_validate.yml
name: Model Card Sign & Register

on:
  workflow_dispatch:
  push:
    paths:
      - 'docs/model_card/**'
      - 'modelcard/**'

jobs:
  sign-and-register:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      - name: Install deps
        run: |
          pip install -r modelcard/validator/requirements.txt || true
          pip install -r modelcard/registry/requirements.txt || true
      - name: Validate model_card (if present)
        run: |
          if [ -f docs/model_card/model_card_template.json ]; then
            echo "Validating template"
            python modelcard/validator/validate_model_card.py --file docs/model_card/model_card_template.json
          else
            echo "No model card template found; skipping"
          fi
      - name: Sign model_card (operator must configure COSIGN_KEY secret)
        env:
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
        run: |
          # This action assumes the model_card has been uploaded to s3 by other steps or operator.
          echo "Signing not automated in CI; operator must run sign_model_card on S3 URL or configure upload step"
      - name: Register with registry (optional)
        env:
          MODEL_CARD_REGISTRY_URL: ${{ secrets.MODEL_CARD_REGISTRY_URL }}
        run: |
          echo "Use registry API to register model_card after upload"
*** End Patch
*** Begin Patch
*** Add File:mcp/api/mcp_service_model_card_checks.patch
*** End Patch
*** Begin Patch
*** Update File:mcp/api/mcp_service.py
@@
 from pydantic import BaseModel
 from fastapi import FastAPI, HTTPException
 import mlflow
 import requests
 import kubernetes
 from kubernetes import client, config
+import os
+
+MODEL_CARD_REGISTRY_URL = os.environ.get("MODEL_CARD_REGISTRY_URL", "")
*** End Patch
*** Begin Patch
*** Update File:mcp/api/mcp_service.py
@@
 def promote(req: PromoteReq):
@@
     # 1) Verify signature (best-effort)
-    sig_res = verify_signature(artifact_uri)
-    if sig_res.get("returncode", 1) != 0:
-        # In production you'd fail; here we warn
-        return {"status": "signature_failed", "details": sig_res}
+    sig_res = verify_signature(artifact_uri)
+    if sig_res.get("returncode", 1) != 0:
+        # check model_card registry as fallback
+        if MODEL_CARD_REGISTRY_URL:
+            # attempt to find a model_card record for this model+version and require signed flag
+            try:
+                r = requests.get(MODEL_CARD_REGISTRY_URL.rstrip("/") + "/cards", params={"model_name": req.model_name}, timeout=5)
+                if r.status_code == 200:
+                    cards = r.json()
+                    matched = [c for c in cards if c.get("version") == req.model_version]
+                    if matched and matched[0].get("signed"):
+                        sig_res = {"returncode": 0, "note": "found signed model_card in registry"}
+                    else:
+                        return {"status": "signature_failed", "details": "artifact signature failed and no signed model_card found in registry"}
+            except Exception:
+                return {"status": "signature_failed", "details": "artifact signature failed and registry unreachable"}
+        else:
+            return {"status": "signature_failed", "details": sig_res}
*** End Patch
*** Begin Patch
*** Add File:modelcard/runbooks/model_card_protocol_runbook.md
+# Model Card Protocol (MCP) Operator Runbook (Aegis)
+
+Goals:
+- Ensure model_cards are created, validated, signed, registered and enforced before promotion/deployment.
+
+Key components:
+- modelcard/validator : schema validation
+- modelcard/signing : cosign signing of model_card JSON and Rekor posting
+- modelcard/registry : registry API and lightweight UI
+- devsecops/gatekeeper/constraint_require_modelcard_signed.yaml : Gatekeeper enforcement template
+- mcp/promote flow: checks registry for signed model_card before creating ModelDeployment CRD
+
+Operator checklist (staging):
+1. Configure environment:
+   - EVIDENCE_BUCKET, AWS_REGION, MLFLOW_TRACKING_URI
+   - MODEL_CARD_REGISTRY_URL (if using hosted registry)
+   - COSIGN_KEY (awskms://... or local key for staging)
+   - REKOR_URL (optional)
+
+2. Deploy model card registry:
+   - Build image for modelcard/registry and deploy to namespace `aegis` (port 8095)
+   - kubectl apply -f modelcard/registry/*.yaml (if you create manifests)
+
+3. Validate model card:
+   - python modelcard/validator/validate_model_card.py --file ./path/to/model_card.json
+
+4. Upload model_card to S3:
+   - aws s3 cp model_card.json s3://<EVIDENCE_BUCKET>/model_cards/<model>-<ver>.json
+
+5. Sign model card:
+   - python modelcard/signing/sign_model_card.py --s3 s3://... --cosign-key $COSIGN_KEY
+
+6. Register model card:
+   - curl -X POST $MODEL_CARD_REGISTRY_URL/register -d '{"model_name":"...","version":"...","s3_key":"s3://...","signed":true}'
+
+7. Tag MLflow run:
+   - mlflow client set_tag run_id model_card_s3 s3://...
+   - mlflow client set_tag run_id model_card_signed true
+
+8. Enforce admission:
+   - Apply Gatekeeper template in devsecops/gatekeeper/constraint_require_modelcard_signed.yaml
+   - Ensure deployments include annotation aegis.model_card_s3 and aegis.model_card_signed=true
+
+9. Promote via MCP:
+   - Use MCP API /promote; operator will check signature and registry before creating ModelDeployment CRD.
+
+Notes:
+- For production, use KMS-backed cosign keys and Rekor entries for immutable evidence.
+- Automate generation of model_card in CI and trigger the sign/register steps from protected pipelines.
*** End Patch
*** End Patch
