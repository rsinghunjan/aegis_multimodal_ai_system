diff --git a/vault/policies/aegis_agents_policy.hcl b/vault/policies/aegis_agents_policy.hcl
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/vault/policies/aegis_agents_policy.hcl
@@ -0,0 +1,42 @@
+# Vault policy for Aegis agents: minimal read access to GitHub App key (KV v2) and dynamic DB creds.
+# NOTE: Operator must adapt paths and tighten as needed.
+path "secret/data/aegis/github_app" {
+  capabilities = ["read"]
+}
+
+path "secret/data/aegis/postgres" {
+  capabilities = ["read", "list"]
+}
+
+path "secret/data/aegis/cloud/*" {
+  capabilities = ["read"]
+}
+
+# Allow issuing dynamic DB creds from the database secrets engine
+path "database/creds/aegis-role" {
+  capabilities = ["read"]
+}
+
+# Allow reading local agent-specific tokens or transient values
+path "secret/data/aegis/ephemeral/*" {
+  capabilities = ["read","list"]
+}
+
+# Allow lookup of token information
+path "auth/token/renew-self" {
+  capabilities = ["update"]
+}
+
+#
+# Apply this policy to a k8s role that maps to aegis-agent-sa (see README for role bind steps).
+
diff --git a/k8s/manifests/orchestrator-deployment-vault.yaml b/k8s/manifests/orchestrator-deployment-vault.yaml
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/k8s/manifests/orchestrator-deployment-vault.yaml
@@ -0,0 +1,120 @@
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-orchestrator
+  namespace: aegis-ml
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: aegis-orchestrator
+  template:
+    metadata:
+      labels:
+        app: aegis-orchestrator
+      annotations:
+        # Vault Agent Injector annotations (example). Adjust to your Vault install & annotation keys.
+        vault.hashicorp.com/agent-inject: "true"
+        vault.hashicorp.com/role: "aegis-agent"
+        vault.hashicorp.com/agent-inject-secret-github_app: "secret/data/aegis/github_app"
+        vault.hashicorp.com/agent-inject-secret-postgres: "secret/data/aegis/postgres"
+        vault.hashicorp.com/agent-inject-template-github_app: |
+          {{- with secret "secret/data/aegis/github_app" -}}
+          {{ .Data.data.private_key }}
+          {{- end }}
+    spec:
+      serviceAccountName: aegis-agent-sa
+      containers:
+        - name: orchestrator
+          image: ghcr.io/yourorg/aegis-orchestrator:latest
+          env:
+            - name: VAULT_ADDR
+              value: "https://vault.example.internal"
+            - name: VAULT_SECRET_GITHUB_APP_PATH
+              value: "secret/data/aegis/github_app"
+            - name: VAULT_SECRET_POSTGRES_PATH
+              value: "secret/data/aegis/postgres"
+            - name: USE_VAULT_INJECTOR
+              value: "true"
+          volumeMounts:
+            - name: vault-secrets
+              mountPath: /vault/secrets
+      volumes:
+        - name: vault-secrets
+          emptyDir: {}
+---
+# Role & rolebinding for Vault Kubernetes auth example (operator must adapt)
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: aegis-vault-reader
+  namespace: aegis-ml
+rules:
+  - apiGroups: [""]
+    resources: ["pods"]
+    verbs: ["get","list"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: aegis-vault-reader-binding
+  namespace: aegis-ml
+subjects:
+  - kind: ServiceAccount
+    name: aegis-agent-sa
+roleRef:
+  kind: Role
+  name: aegis-vault-reader
+  apiGroup: rbac.authorization.k8s.io
+
diff --git a/agents/common/github_app_vault.py b/agents/common/github_app_vault.py
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/agents/common/github_app_vault.py
@@ -0,0 +1,220 @@
+#!/usr/bin/env python3
+"""
+Helper to obtain GitHub App installation tokens using a private key stored in Vault (KV v2).
+
+Flow:
+ - Read Vault at VAULT_ADDR using VAULT_TOKEN (in pod via Vault Agent or env)
+ - Extract private_key PEM and app_id, installation_id
+ - Create a JWT signed with private_key (RS256) and exchange it for an installation token:
+     POST https://api.github.com/app/installations/{installation_id}/access_tokens
+ - Return installation token (short-lived).
+
+Security:
+ - This code assumes Vault provides the private key via Vault Agent file or environment secrets.
+ - For production, use k8s Vault injector / CSI and restrict access by policy.
+"""
+import os
+import time
+import json
+import requests
+import jwt
+from typing import Optional
+import logging
+
+logger = logging.getLogger("aegis.github_app_vault")
+logging.basicConfig(level=logging.INFO)
+
+VAULT_ADDR = os.environ.get("VAULT_ADDR")
+VAULT_TOKEN = os.environ.get("VAULT_TOKEN")
+GITHUB_APP_VAULT_PATH = os.environ.get("VAULT_SECRET_GITHUB_APP_PATH", "secret/data/aegis/github_app")
+
+def _read_vault_secret(path: str) -> Optional[dict]:
+    if os.path.exists("/vault/secrets/github_app.pem"):
+        # prefer injector-mounted file (if using Vault Agent templates)
+        try:
+            with open("/vault/secrets/github_app.pem", "r") as fh:
+                content = fh.read()
+            # We still need metadata: app_id, installation_id - these could be in other files or same secret
+            meta = {}
+            # attempt to read meta json
+            try:
+                with open("/vault/secrets/github_app.meta.json", "r") as mh:
+                    meta = json.load(mh)
+            except Exception:
+                meta = {}
+            return {"data": {"private_key": content, **meta}}
+        except Exception:
+            pass
+
+    if not VAULT_ADDR or not VAULT_TOKEN:
+        logger.warning("VAULT_ADDR or VAULT_TOKEN not set; cannot read Vault secret")
+        return None
+
+    url = f"{VAULT_ADDR}/v1/{path}"
+    headers = {"X-Vault-Token": VAULT_TOKEN}
+    resp = requests.get(url, headers=headers, timeout=10)
+    if resp.status_code != 200:
+        logger.error("Vault read failed %s: %s", resp.status_code, resp.text)
+        return None
+    try:
+        return resp.json()
+    except Exception:
+        logger.exception("Failed to parse Vault response")
+        return None
+
+def _create_jwt(app_id: str, private_key_pem: str) -> str:
+    now = int(time.time())
+    payload = {
+        "iat": now - 60,
+        "exp": now + (10 * 60),
+        "iss": app_id
+    }
+    token = jwt.encode(payload, private_key_pem, algorithm="RS256")
+    # PyJWT returns bytes in some versions
+    if isinstance(token, bytes):
+        token = token.decode("utf-8")
+    return token
+
+def get_installation_token(installation_id: Optional[str] = None) -> Optional[str]:
+    """
+    Return installation token; fetch private_key and app_id from Vault.
+    If installation_id not provided, attempt to read from Vault secret metadata.
+    """
+    sec = _read_vault_secret(GITHUB_APP_VAULT_PATH)
+    if not sec:
+        logger.error("Failed to read GitHub App secret from Vault")
+        return None
+
+    data = sec.get("data") or sec
+    # KV v2 stores in data.data
+    if "data" in data and isinstance(data["data"], dict):
+        payload = data["data"]
+    else:
+        payload = data
+
+    private_key = payload.get("private_key")
+    app_id = payload.get("app_id") or payload.get("appId") or os.environ.get("GITHUB_APP_ID")
+    installation = installation_id or payload.get("installation_id") or payload.get("installationId") or os.environ.get("GITHUB_INSTALLATION_ID")
+    if not private_key or not app_id or not installation:
+        logger.error("Missing private_key/app_id/installation_id in Vault secret")
+        return None
+
+    # create JWT
+    jwt_token = _create_jwt(str(app_id), private_key)
+
+    # exchange for installation token
+    headers = {"Authorization": f"Bearer {jwt_token}", "Accept": "application/vnd.github+json"}
+    url = f"https://api.github.com/app/installations/{installation}/access_tokens"
+    resp = requests.post(url, headers=headers, timeout=15)
+    if resp.status_code not in (200,201):
+        logger.error("GitHub installation token exchange failed: %s %s", resp.status_code, resp.text)
+        return None
+    j = resp.json()
+    token = j.get("token")
+    expires_at = j.get("expires_at")
+    logger.info("Obtained installation token, expires_at=%s", expires_at)
+    return token
+
+if __name__ == "__main__":
+    tok = get_installation_token()
+    print("token:", tok)
+
diff --git a/policy/opa/tests/agent_policies_test.rego b/policy/opa/tests/agent_policies_test.rego
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/policy/opa/tests/agent_policies_test.rego
@@ -0,0 +1,120 @@
+package aegis.policies.tests
+
+import data.aegis.policies
+
+# Minimal unit tests for agent_policies_extended.rego
+test_allow_staging_retrain {
+  input := {"action": "retrain", "model": "low-demo-model", "env": "staging", "params": {}}
+  result := data.aegis.policies.result with input as input
+  result.allow == true
+}
+
+test_deny_high_risk_prod {
+  input := {"action": "retrain", "model": "fraud-detector-v1", "env": "production", "params": {}}
+  result := data.aegis.policies.result with input as input
+  result.allow == false
+}
+
+test_medium_require_approval {
+  input := {"action": "promote", "model": "default", "env": "production", "params": {}}
+  result := data.aegis.policies.result with input as input
+  # medium risk without approved_by should be denied
+  result.allow == false
+}
+
diff --git a/.github/workflows/policy-ci.yml b/.github/workflows/policy-ci.yml
new file mode 100644
index 0000000..5555555
--- /dev/null
+++ b/.github/workflows/policy-ci.yml
@@ -0,0 +1,132 @@
+name: Policy CI
+
+on:
+  push:
+    paths:
+      - "policy/**"
+  pull_request:
+    paths:
+      - "policy/**"
+
+jobs:
+  opa-test:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Run OPA unit tests
+        run: |
+          docker run --rm -v "${{ github.workspace }}:/workspace" openpolicyagent/opa:latest test /workspace/policy -v
+
+  rego-lint:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Lint Rego (opa fmt)
+        run: |
+          docker run --rm -v "${{ github.workspace }}:/workspace" openpolicyagent/opa:latest fmt /workspace/policy || true
+
diff --git a/sql/002_add_indexes_decision_log.sql b/sql/002_add_indexes_decision_log.sql
new file mode 100644
index 0000000..6666666
--- /dev/null
+++ b/sql/002_add_indexes_decision_log.sql
@@ -0,0 +1,64 @@
+-- Add indexes for common audit queries on decision_log
+CREATE INDEX IF NOT EXISTS idx_decision_log_created_at ON decision_log (created_at DESC);
+CREATE INDEX IF NOT EXISTS idx_decision_log_model ON decision_log ((payload->>'model'));
+CREATE INDEX IF NOT EXISTS idx_decision_log_action ON decision_log ((payload->>'action'));
+CREATE INDEX IF NOT EXISTS idx_decision_log_agent ON decision_log (agent);
+-- index on evidence keys (example JSONB path, adjust for your DB flavor)
+CREATE INDEX IF NOT EXISTS idx_decision_log_evidence ON decision_log USING GIN (evidence);
+
+-- Optional: partitioning or retention policy can be added by operator
+-- Example retention: delete rows older than 365 days (run via cron)
+-- DELETE FROM decision_log WHERE created_at < now() - interval '365 days';
+
diff --git a/tools/decisionlog_to_elastic.py b/tools/decisionlog_to_elastic.py
new file mode 100644
index 0000000..7777777
--- /dev/null
+++ b/tools/decisionlog_to_elastic.py
@@ -0,0 +1,220 @@
+#!/usr/bin/env python3
+"""
+Simple mirror from Postgres decision_log -> Elasticsearch for fast auditing.
+Invoke as a cron job or CI task. Intended as a best-effort mirror.
+
+Requires:
+ - POSTGRES_URL env
+ - ELASTIC_URL env (HTTP endpoint)
+ - minimal permissions for read from PG and write to ES
+"""
+import os
+import json
+import time
+import psycopg2
+import requests
+
+PG_URL = os.environ.get("POSTGRES_URL")
+ES_URL = os.environ.get("ELASTIC_URL")
+
+def fetch_recent(limit=1000):
+    conn = psycopg2.connect(PG_URL)
+    cur = conn.cursor()
+    cur.execute("SELECT id, created_at, agent, model, env, action, payload, evidence FROM decision_log ORDER BY created_at DESC LIMIT %s", (limit,))
+    rows = cur.fetchall()
+    cur.close()
+    conn.close()
+    return rows
+
+def index_to_es(rows):
+    for r in rows:
+        doc = {
+            "id": r[0],
+            "created_at": r[1].isoformat() if hasattr(r[1], "isoformat") else str(r[1]),
+            "agent": r[2],
+            "model": r[3],
+            "env": r[4],
+            "action": r[5],
+            "payload": r[6],
+            "evidence": r[7]
+        }
+        # simple index per id
+        url = f"{ES_URL.rstrip('/')}/decision_log/_doc/{doc['id']}"
+        headers = {"Content-Type":"application/json"}
+        resp = requests.put(url, headers=headers, data=json.dumps(doc))
+        if resp.status_code not in (200,201):
+            print("Failed to index", doc['id'], resp.status_code, resp.text)
+
+def main():
+    if not PG_URL or not ES_URL:
+        print("POSTGRES_URL and ELASTIC_URL must be set")
+        return
+    rows = fetch_recent(limit=500)
+    index_to_es(rows)
+
+if __name__ == "__main__":
+    main()
+
diff --git a/scripts/auto_approval_pr.py b/scripts/auto_approval_pr.py
new file mode 100644
index 0000000..8888888
--- /dev/null
+++ b/scripts/auto_approval_pr.py
@@ -0,0 +1,200 @@
+#!/usr/bin/env python3
+"""
+Create an approval PR when an orchestrator decision is denied or requires human signoff.
+This script expects to be invoked by the orchestrator or as a webhook handler with contextual payload.
+
+It uses GitHub App installation tokens fetched via Vault helper (agents.common.github_app_vault.get_installation_token).
+"""
+import os
+import json
+import requests
+from typing import Optional
+
+try:
+    from agents.common.github_app_vault import get_installation_token
+except Exception:
+    def get_installation_token(*a, **k):
+        return os.environ.get("GITHUB_TOKEN")
+
+GITHUB_API = "https://api.github.com"
+
+def create_pr(repo: str, title: str, body: str, head: str, base: str = "main", installation_id: Optional[str] = None):
+    token = get_installation_token(installation_id)
+    if not token:
+        raise RuntimeError("No GitHub installation token available")
+    headers = {"Authorization": f"token {token}", "Accept":"application/vnd.github+json"}
+    url = f"{GITHUB_API}/repos/{repo}/pulls"
+    payload = {"title": title, "body": body, "head": head, "base": base}
+    r = requests.post(url, headers=headers, json=payload, timeout=10)
+    r.raise_for_status()
+    return r.json()
+
+def main():
+    import argparse
+    p = argparse.ArgumentParser()
+    p.add_argument("--repo", required=True)
+    p.add_argument("--title", required=True)
+    p.add_argument("--body", default="")
+    p.add_argument("--head", required=True)
+    p.add_argument("--base", default="main")
+    p.add_argument("--installation-id", default=None)
+    args = p.parse_args()
+    pr = create_pr(args.repo, args.title, args.body, args.head, args.base, args.installation_id)
+    print(json.dumps(pr, indent=2))
+
+if __name__ == "__main__":
+    main()
+
diff --git a/k8s/manifests/feast-online-deploy.yaml b/k8s/manifests/feast-online-deploy.yaml
new file mode 100644
index 0000000..9999999
--- /dev/null
+++ b/k8s/manifests/feast-online-deploy.yaml
@@ -0,0 +1,120 @@
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: feast-online-store
+  namespace: aegis-ml
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: feast-online
+  template:
+    metadata:
+      labels:
+        app: feast-online
+    spec:
+      serviceAccountName: aegis-agent-sa
+      containers:
+        - name: feast-online
+          image: <REGISTRY>/aegis-feast-online:latest
+          env:
+            - name: REDIS_HOST
+              value: "feast-redis.aegis-ml.svc.cluster.local"
+          ports:
+            - containerPort: 6566
+          resources:
+            requests:
+              cpu: "200m"
+              memory: "512Mi"
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: feast-online
+  namespace: aegis-ml
+spec:
+  selector:
+    app: feast-online
+  ports:
+    - port: 6566
+      targetPort: 6566
+
diff --git a/k8s/manifests/labelstudio-sender-cronjob.yaml b/k8s/manifests/labelstudio-sender-cronjob.yaml
new file mode 100644
index 0000000..aaaaaaaa
--- /dev/null
+++ b/k8s/manifests/labelstudio-sender-cronjob.yaml
@@ -0,0 +1,80 @@
+apiVersion: batch/v1
+kind: CronJob
+metadata:
+  name: labelstudio-sender
+  namespace: aegis-ml
+spec:
+  schedule: "*/10 * * * *"  # every 10 minutes
+  jobTemplate:
+    spec:
+      template:
+        spec:
+          serviceAccountName: aegis-agent-sa
+          containers:
+            - name: sender
+              image: <REGISTRY>/aegis-labelstudio-sender:latest
+              env:
+                - name: LABELSTUDIO_URL
+                  value: "http://labelstudio.aegis-ml.svc.cluster.local:8080"
+                - name: LABELSTUDIO_API_KEY
+                  valueFrom:
+                    secretKeyRef:
+                      name: aegis-labelstudio-secret
+                      key: api_key
+              resources:
+                requests:
+                  cpu: "100m"
+                  memory: "128Mi"
+          restartPolicy: OnFailure
+
diff --git a/monitoring/prometheus/model_slo_rules.yaml b/monitoring/prometheus/model_slo_rules.yaml
new file mode 100644
index 0000000..bbbbbbbb
--- /dev/null
+++ b/monitoring/prometheus/model_slo_rules.yaml
@@ -0,0 +1,120 @@
+apiVersion: monitoring.coreos.com/v1
+kind: PrometheusRule
+metadata:
+  name: aegis-model-slo-rules
+  namespace: aegis-ml
+spec:
+  groups:
+    - name: aegis-model-slo.rules
+      rules:
+        - alert: ModelDecisionLatencyHigh
+          expr: avg_over_time(aegis_decision_latency_seconds[5m]) > 2
+          for: 5m
+          labels:
+            severity: warning
+          annotations:
+            summary: "High decision latency in Orchestrator"
+
+        - alert: ModelAutoExecDeniedSpike
+          expr: increase(aegis_decisions_total{result="deny"}[5m]) > 20
+          for: 5m
+          labels:
+            severity: critical
+          annotations:
+            summary: "Spike in denied decisions (possible policy regression)"
+
+        - alert: QuantumJobFidelityDrop
+          expr: decrease(aegis_quantum_job_fidelity[15m]) < -0.2
+          for: 10m
+          labels:
+            severity: warning
+          annotations:
+            summary: "Significant drop in quantum job fidelity"
+
diff --git a/tests/test_policy_ci.sh b/tests/test_policy_ci.sh
new file mode 100644
index 0000000..cccccccc
--- /dev/null
+++ b/tests/test_policy_ci.sh
@@ -0,0 +1,48 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+# Simple smoke test that runs OPA policy tests locally (requires docker)
+docker run --rm -v "${PWD}:/workspace" openpolicyagent/opa:latest test /workspace/policy -v
+echo "OPA policy tests passed (or failed with above output)"
+
diff --git a/docs/VAULT_MIGRATION_RUNBOOK.md b/docs/VAULT_MIGRATION_RUNBOOK.md
new file mode 100644
index 0000000..dddddddd
--- /dev/null
+++ b/docs/VAULT_MIGRATION_RUNBOOK.md
@@ -0,0 +1,220 @@
+# Vault Migration Runbook â€” Move secrets to Vault and enable Vault Injector
+
+Prereqs:
+- Vault installed and configured with Kubernetes auth.
+- Operator access to Vault (VAULT_ADDR and VAULT_TOKEN) and cluster admin to annotate pods.
+
+Steps:
+1. Write GH App secret to Vault (KV v2):
+   vault kv put secret/aegis/github_app private_key=@/tmp/github_app.pem app_id=12345 installation_id=67890
+
+2. Configure Vault policy (example provided in vault/policies/aegis_agents_policy.hcl)
+   vault policy write aegis-agents vault/policies/aegis_agents_policy.hcl
+
+3. Create auth role that binds k8s SA aegis-agent-sa:
+   vault write auth/kubernetes/role/aegis-agent \
+     bound_service_account_names=aegis-agent-sa \
+     bound_service_account_namespaces=aegis-ml \
+     policies=aegis-agents \
+     ttl=1h
+
+4. Annotate orchestrator deployment to use Vault Agent Injector (manifest provided: k8s/manifests/orchestrator-deployment-vault.yaml)
+
+5. Remove plaintext secrets from cluster and CI:
+   kubectl -n aegis-ml delete secret aegis-postgres-secret || true
+
+6. Test: exec into orchestrator pod and read /vault/secrets/github_app.pem or the injected path.
+
+Rollback:
+- Revert deployment annotations and re-create prior secrets if immediate rollback needed.
+
+Notes:
+- Use dynamic DB roles via Vault database secrets engine for short-lived DB users (see vault/setup_dynamic_db.sh in repo).
+- Ensure RBAC for Vault role is tightly scoped.
+
+End of runbook.
+
