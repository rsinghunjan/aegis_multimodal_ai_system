*** Begin Patch
*** Add File:quantum/hsm/docker-compose.yml
+version: "3.7"
+services:
+  softhsm:
+    image: ghcr.io/smallstep/softhsm:2.8.0
+    container_name: softhsm
+    environment:
+      - SOFTHSM2_CONF=/var/lib/softhsm2/softhsm2.conf
+    volumes:
+      - ./tokens:/var/lib/softhsm2/tokens
+      - ./softhsm2.conf:/var/lib/softhsm2/softhsm2.conf
+    ports:
+      - "9999:9999"
+    command: ["sh", "-c", "mkdir -p /var/lib/softhsm2/tokens && exec /usr/bin/softhsm2-util --show-info || sleep infinity"]
+
*** End Patch
*** Begin Patch
*** Add File:quantum/hsm/softhsm2.conf
+directories.tokendir = /var/lib/softhsm2/tokens
+
*** End Patch
*** Begin Patch
*** Add File:quantum/hsm/init_softhsm.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Init SoftHSM token and create a test RSA key for PKCS#11 signing demos.
+#
+TOKENDIR="$(pwd)/tokens"
+CONF="$(pwd)/softhsm2.conf"
+export SOFTHSM2_CONF="$CONF"
+mkdir -p "$TOKENDIR"
+
+echo "Initializing SoftHSM token..."
+softhsm2-util --init-token --free --label "aegis-pq-token" --so-pin 123456 --pin 123456 || true
+
+echo "Generating RSA keypair (placeholder for PKCS#11 signing tests)..."
+# create an RSA key pair labelled 'pqkey' (SoftHSM doesn't support PQ algs; this tests PKCS#11 integration)
+pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so --login --pin 123456 --keypairgen --key-type rsa:2048 --label pqkey || true
+
+echo "List objects in token:"
+pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so --login --pin 123456 --list-objects || true
+
+echo "SoftHSM initialization complete. Token dir: $TOKENDIR"
+
*** End Patch
*** Begin Patch
*** Add File:quantum/hsm/README.md
+# SoftHSM dev/test environment
+
+This folder contains a minimal docker-compose and init script to run SoftHSM for local testing of the PKCS#11 path.
+
+Quick start:
+1. Install pkcs11-tool (from opensc/pkcs11-tools) and softhsm2 in your environment.
+2. Start SoftHSM:
+   docker-compose -f quantum/hsm/docker-compose.yml up -d
+3. Initialize token & create a test key:
+   ./quantum/hsm/init_softhsm.sh
+
+Notes:
+- SoftHSM does not provide postâ€‘quantum algorithms; it is used to test the PKCS#11 integration path. Replace with vendor HSM for PQ support.
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/requirements-postgres.txt
+fastapi
+uvicorn
+pydantic
+sqlalchemy>=1.4
+psycopg2-binary
+qiskit
+python-jose>=3.3.0
+requests
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/db.py
+"""
+Job broker DB layer using SQLAlchemy (Postgres backend).
+This module creates required tables automatically on import.
+"""
+from sqlalchemy import create_engine, Column, String, Text, DateTime, Enum
+from sqlalchemy.ext.declarative import declarative_base
+from sqlalchemy.orm import sessionmaker
+import os, datetime, json
+
+DATABASE_URL = os.environ.get("JOB_DATABASE_URL", "postgresql://aegis:aegispass@localhost:5432/aegis_jobs")
+
+engine = create_engine(DATABASE_URL, pool_pre_ping=True)
+SessionLocal = sessionmaker(bind=engine)
+Base = declarative_base()
+
+class Job(Base):
+    __tablename__ = "jobs"
+    id = Column(String, primary_key=True, index=True)
+    spec = Column(Text, nullable=False)
+    status = Column(String, nullable=False, default="PENDING")
+    created_at = Column(DateTime, default=datetime.datetime.utcnow)
+    result = Column(Text, nullable=True)
+
+def init_db():
+    Base.metadata.create_all(bind=engine)
+
+def create_job(db, job_id, spec_json):
+    job = Job(id=job_id, spec=spec_json, status="PENDING")
+    db.add(job)
+    db.commit()
+    db.refresh(job)
+    return job
+
+def fetch_pending(db, limit=10):
+    return db.query(Job).filter(Job.status == "PENDING").limit(limit).all()
+
+def update_job(db, job_id, status, result_json=None):
+    job = db.query(Job).filter(Job.id == job_id).first()
+    if not job:
+        return None
+    job.status = status
+    if result_json is not None:
+        job.result = result_json
+    db.commit()
+    db.refresh(job)
+    return job
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/app_postgres.py
+#!/usr/bin/env python3
+"""
+FastAPI job broker with Postgres persistence and simple JWT-based auth.
+Requires:
+ - JOB_DATABASE_URL env var (standard SQLAlchemy URL)
+ - BROKER_API_JWT_SECRET env var (a shared secret used to validate simple JWTs)
+
+This app enforces Authorization: Bearer <token> header on write endpoints.
+"""
+from fastapi import FastAPI, HTTPException, Depends, Header, Request
+from pydantic import BaseModel
+import os, uuid, json, time
+from sqlalchemy.orm import Session
+from jose import jwt, JWTError
+from . import db as jb_db
+
+jb_db.init_db()
+
+app = FastAPI(title="Aegis Quantum Job Broker (Postgres)", version="1.0")
+
+JWT_SECRET = os.environ.get("BROKER_API_JWT_SECRET", "change-me")
+JWT_ALGO = os.environ.get("BROKER_API_JWT_ALGO", "HS256")
+
+def validate_token(auth_header: str = Header(None)):
+    if not auth_header:
+        raise HTTPException(status_code=401, detail="Missing Authorization header")
+    if not auth_header.lower().startswith("bearer "):
+        raise HTTPException(status_code=401, detail="Invalid Authorization header")
+    token = auth_header.split(" ",1)[1]
+    try:
+        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGO])
+        return payload
+    except JWTError as e:
+        raise HTTPException(status_code=401, detail="Invalid token") from e
+
+class JobSpec(BaseModel):
+    circuit_qasm: str
+    shots: int = 1024
+    backend: str = "aer_simulator"
+
+@app.post("/submit")
+def submit(spec: JobSpec, auth=Depends(validate_token)):
+    job_id = str(uuid.uuid4())
+    db = jb_db.SessionLocal()
+    job = jb_db.create_job(db, job_id, json.dumps(spec.dict()))
+    return {"job_id": job_id}
+
+@app.get("/status/{job_id}")
+def status(job_id: str):
+    db = jb_db.SessionLocal()
+    job = db.query(jb_db.Job).filter(jb_db.Job.id == job_id).first()
+    if not job:
+        raise HTTPException(status_code=404, detail="job not found")
+    res = None
+    if job.result:
+        try:
+            res = json.loads(job.result)
+        except:
+            res = {"raw": job.result}
+    return {"job_id": job.id, "status": job.status, "result": res}
+
+@app.get("/health")
+def health():
+    return {"ok": True}
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/worker_postgres.py
+#!/usr/bin/env python3
+"""
+Worker that polls Postgres (SQLAlchemy) for pending jobs and executes them using QiskitAdapter.
+"""
+import time, json, os
+from quantum.qbackend.qiskit_adapter import QiskitAdapter
+from . import db as jb_db
+
+adapter = QiskitAdapter()
+
+def poll_loop(poll_interval=2):
+    while True:
+        db = jb_db.SessionLocal()
+        rows = jb_db.fetch_pending(db, limit=5)
+        if not rows:
+            db.close()
+            time.sleep(poll_interval)
+            continue
+        for r in rows:
+            job_id = r.id
+            spec = json.loads(r.spec)
+            try:
+                jid = adapter.submit_job(spec)
+                res = adapter.get_result(jid)
+                jb_db.update_job(db, job_id, "DONE", json.dumps(res))
+                print("Job", job_id, "completed")
+            except Exception as e:
+                jb_db.update_job(db, job_id, "ERROR", json.dumps({"error": str(e)}))
+                print("Job", job_id, "failed:", e)
+        db.close()
+        time.sleep(poll_interval)
+
+if __name__ == "__main__":
+    poll_loop()
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/Dockerfile
+FROM python:3.10-slim
+WORKDIR /app
+RUN apt-get update && apt-get install -y gcc libpq-dev git build-essential libffi-dev && rm -rf /var/lib/apt/lists/*
+COPY quantum/job_broker/requirements-postgres.txt /app/requirements.txt
+RUN pip install --no-cache-dir -r requirements.txt
+COPY quantum/job_broker /app
+ENV PYTHONPATH=/app
+EXPOSE 8080
+CMD ["uvicorn", "app_postgres:app", "--host", "0.0.0.0", "--port", "8080"]
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/helm/Chart.yaml
+apiVersion: v2
+name: aegis-quantum-broker
+description: Helm chart for Aegis Quantum Job Broker (Postgres-backed)
+type: application
+version: 0.1.0
+appVersion: "1.0"
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/helm/values.yaml
+replicaCount: 1
+
+image:
+  repository: aegis/quantum-job-broker
+  tag: latest
+  pullPolicy: IfNotPresent
+
+service:
+  type: ClusterIP
+  port: 80
+
+env:
+  JOB_DATABASE_URL: "postgresql://aegis:aegispass@postgres.aegis.svc.cluster.local:5432/aegis_jobs"
+  BROKER_API_JWT_SECRET: "change-me"
+  BROKER_API_JWT_ALGO: "HS256"
+
+postgres:
+  enabled: false
+  postgresqlUsername: aegis
+  postgresqlPassword: aegispass
+  postgresqlDatabase: aegis_jobs
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/helm/templates/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: {{ include "aegis-quantum-broker.fullname" . }}
+spec:
+  replicas: {{ .Values.replicaCount }}
+  selector:
+    matchLabels:
+      app: aegis-quantum-broker
+  template:
+    metadata:
+      labels:
+        app: aegis-quantum-broker
+    spec:
+      containers:
+        - name: broker
+          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
+          imagePullPolicy: {{ .Values.image.pullPolicy }}
+          env:
+            - name: JOB_DATABASE_URL
+              value: "{{ .Values.env.JOB_DATABASE_URL }}"
+            - name: BROKER_API_JWT_SECRET
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-broker-secret
+                  key: BROKER_API_JWT_SECRET
+            - name: BROKER_API_JWT_ALGO
+              value: "{{ .Values.env.BROKER_API_JWT_ALGO }}"
+          ports:
+            - containerPort: 8080
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/helm/templates/secret.yaml
+apiVersion: v1
+kind: Secret
+metadata:
+  name: aegis-broker-secret
+type: Opaque
+stringData:
+  BROKER_API_JWT_SECRET: "{{ .Values.env.BROKER_API_JWT_SECRET }}"
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/helm/templates/service.yaml
+apiVersion: v1
+kind: Service
+metadata:
+  name: aegis-quantum-broker
+spec:
+  type: {{ .Values.service.type }}
+  ports:
+    - port: {{ .Values.service.port }}
+      targetPort: 8080
+  selector:
+    app: aegis-quantum-broker
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/k8s/postgres-statefulset.yaml
+apiVersion: v1
+kind: Secret
+metadata:
+  name: aegis-postgres-secret
+type: Opaque
+stringData:
+  POSTGRES_USER: aegis
+  POSTGRES_PASSWORD: aegispass
+
+---
+apiVersion: apps/v1
+kind: StatefulSet
+metadata:
+  name: postgres
+spec:
+  serviceName: "postgres"
+  replicas: 1
+  selector:
+    matchLabels:
+      app: postgres
+  template:
+    metadata:
+      labels:
+        app: postgres
+    spec:
+      containers:
+      - name: postgres
+        image: postgres:14
+        env:
+          - name: POSTGRES_USER
+            valueFrom:
+              secretKeyRef:
+                name: aegis-postgres-secret
+                key: POSTGRES_USER
+          - name: POSTGRES_PASSWORD
+            valueFrom:
+              secretKeyRef:
+                name: aegis-postgres-secret
+                key: POSTGRES_PASSWORD
+        ports:
+          - containerPort: 5432
+        volumeMounts:
+          - name: pgdata
+            mountPath: /var/lib/postgresql/data
+  volumeClaimTemplates:
+    - metadata:
+        name: pgdata
+      spec:
+        accessModes: ["ReadWriteOnce"]
+        resources:
+          requests:
+            storage: 10Gi
+
*** End Patch
*** Begin Patch
*** Add File:quantum/job_broker/README_HARDENING.md
+# Job Broker Hardening (Postgres + JWT auth)
+
+This folder adds a hardened job broker implementation:
+- Postgres-backed persistence (SQLAlchemy)
+- Worker adapted to poll Postgres
+- JWT-based Authorization for submit endpoints (use a strong secret in production)
+- Helm chart for Kubernetes deployment and an example Postgres StatefulSet (for test clusters)
+
+Local dev steps:
+1. Start Postgres (docker run -e POSTGRES_PASSWORD=aegispass -e POSTGRES_USER=aegis -e POSTGRES_DB=aegis_jobs -p 5432:5432 postgres:14)
+2. Build broker image:
+   docker build -t aegis/quantum-job-broker:local -f quantum/job_broker/Dockerfile .
+3. Run broker locally:
+   export JOB_DATABASE_URL=postgresql://aegis:aegispass@localhost:5432/aegis_jobs
+   export BROKER_API_JWT_SECRET=change-me
+   uvicorn quantum.job_broker.app_postgres:app --host 0.0.0.0 --port 8080
+
+Generate a JWT (example):
+  python3 - <<PY
+import jwt, os, time
+print(jwt.encode({'sub':'operator','exp':int(time.time())+600}, "change-me", algorithm="HS256"))
+PY
+
+Submit a job:
+  curl -X POST http://localhost:8080/submit -H "Authorization: Bearer <token>" -H "Content-Type: application/json" -d '{"circuit_qasm":"...","shots":1024}'
+
+Notes:
+- In production store BROKER_API_JWT_SECRET in a Kubernetes Secret and rotate periodically.
+- Replace example Postgres StatefulSet with managed Postgres (RDS / Cloud SQL) for reliability.
+
*** End Patch
*** Begin Patch
*** Add File:quantum/crypto/requirements-hsm.txt
+oqs==1.0.0
+pkcs11==0.8.0
+rekor-client==0.0.4
+
*** End Patch
*** Begin Patch
*** Add File:docs/hsm_and_broker_hardening_RUNBOOK.md
+# Runbook: Deploy SoftHSM (dev) and Hardened Job Broker (Postgres)
+
+Purpose
+- Provide step-by-step operator instructions to run SoftHSM locally for PKCS#11 path testing and deploy the Postgres-backed job broker to a Kubernetes test cluster.
+
+SoftHSM dev flow
+1. Ensure Docker is installed.
+2. cd quantum/hsm && docker-compose up -d
+3. ./quantum/hsm/init_softhsm.sh
+4. Verify with:
+   pkcs11-tool --module /usr/lib/softhsm/libsofthsm2.so --list-objects --login --pin 123456
+
+Hybrid signer (test)
+1. Create artifact: echo test > /tmp/art.bin
+2. Run hybrid signer using PKCS#11:
+   python3 quantum/crypto/hybrid_signer_hsm.py sign --artifact /tmp/art.bin --outdir /tmp/aegis_sigs --use-pkcs11 --pkcs11-lib /usr/lib/softhsm/libsofthsm2.so --pkcs11-slot 0 --pkcs11-pin 123456 --pkcs11-keylabel pqkey
+3. Inspect /tmp/aegis_sigs/hybrid-signature.json
+
+Job broker hardening (local)
+1. Start Postgres (local docker or k8s)
+2. Build & run broker locally per quantum/job_broker/README_HARDENING.md
+3. Start worker:
+   python3 quantum/job_broker/worker_postgres.py
+4. Monitor DB rows: psql -h localhost -U aegis -d aegis_jobs -c "select * from jobs;"
+
+Deploy to Kubernetes (test)
+1. Deploy Postgres (use cloud provider or the provided k8s postgres-statefulset.yaml for test clusters)
+2. Create secret for broker JWT:
+   kubectl create secret generic aegis-broker-secret --from-literal=BROKER_API_JWT_SECRET="$(openssl rand -hex 32)"
+3. Install helm chart:
+   helm install aegis-quantum-broker quantum/job_broker/helm
+4. Scale replicas and configure DB URL to production DB endpoint in Helm values.
+
+Notes & troubleshooting
+- If SQLAlchemy fails to connect, verify JOB_DATABASE_URL env var and network/DNS.
+- For production use a managed Postgres, enable backups and network policies.
+
*** End Patch
*** End Patch
