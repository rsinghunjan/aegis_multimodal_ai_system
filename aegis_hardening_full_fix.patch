*** Begin Patch
*** Add File:deploy/vault/ha-values-raft.yaml
+# Vault Helm values for HA using Raft storage with KMS auto-unseal and TLS via cert-manager
+server:
+  ha:
+    enabled: true
+  dataStorage:
+    enabled: false
+  standalone:
+    enabled: false
+  extraEnvironmentVars:
+    - name: VAULT_LOG_LEVEL
+      value: "info"
+unsealer:
+  aws:
+    enabled: true
+    region: "us-west-2"                 # << REPLACE
+    kmsKeyId: "arn:aws:kms:...:key/..." # << REPLACE KMS key ARN for auto-unseal
+s3:
+  enabled: false
+# Raft storage (in-cluster) - recommended for Vault HA with raft
+server:
+  raft:
+    enabled: true
+    # raft.migrate is optional for upgrades; configure storage class if needed
+tls:
+  enabled: true
+  # Operator must provision a cert-manager Certificate bound to the vault service DNS.
+  certManager:
+    enabled: true
+    issuerRef:
+      name: vault-ca-issuer
+      kind: ClusterIssuer
+resources:
+  requests:
+    cpu: 250m
+    memory: 512Mi
+  limits:
+    cpu: 1
+    memory: 2Gi
+
+# NOTES:
+# - Install cert-manager and create a CA ClusterIssuer/vault-ca-issuer (see cert-manager manifests file).
+# - Ensure the KMS key policy allows the Vault node IAM role to Decrypt/GenerateDataKey.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/vault/cert-manager-issuer-and-ca.yaml
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: cert-manager
+---
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: vault-ca-issuer
+spec:
+  selfSigned: {}
+
+---
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: vault-server-tls
+  namespace: aegis
+spec:
+  secretName: vault-server-tls
+  subject:
+    organizations: ["aegis"]
+  commonName: "vault.aegis.svc"
+  dnsNames:
+    - "vault.aegis.svc"
+  issuerRef:
+    name: vault-ca-issuer
+    kind: ClusterIssuer
+  duration: 2160h
+  renewBefore: 360h
+
+# Operator: Install cert-manager (CRDs) before applying and consider using a real CA for production.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/vault/init-vault-job.yaml
+apiVersion: batch/v1
+kind: Job
+metadata:
+  name: vault-init
+  namespace: aegis
+spec:
+  template:
+    spec:
+      serviceAccountName: vault
+      restartPolicy: OnFailure
+      containers:
+        - name: init
+          image: hashicorp/vault:1.14.0
+          env:
+            - name: VAULT_ADDR
+              value: "https://vault.aegis.svc:8200"
+          command:
+            - sh
+            - -c
+            - |
+              set -e
+              if vault status >/dev/null 2>&1; then
+                echo "Vault already initialized/unsealed or unreachable"
+              else
+                vault operator init -key-shares=1 -key-threshold=1 -format=json > /tmp/vault-init.json
+                kubectl create secret generic vault-init --from-file=/tmp/vault-init.json -n aegis || true
+                # Example policy
+                cat > /tmp/aegis-policy.hcl <<'HCL'
+path "secret/data/aegis/*" {
+  capabilities = ["read","list"]
+}
+HCL
+                vault login $(jq -r '.root_token' /tmp/vault-init.json)
+                vault policy write aegis-policy /tmp/aegis-policy.hcl
+                # enable k8s auth (operator must configure service account token reviewer)
+                vault auth enable kubernetes || true
+                # configure kubernetes auth with placeholder values (operator replace)
+                vault write auth/kubernetes/config \
+                  token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
+                  kubernetes_host="https://kubernetes.default.svc" \
+                  kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt || true
+                vault write auth/kubernetes/role/aegis-role \
+                  bound_service_account_names="*" \
+                  bound_service_account_namespaces="aegis" \
+                  policies="aegis-policy" \
+                  ttl="24h" || true
+              fi
+      restartPolicy: OnFailure
+
+# NOTE: This job is an operator convenience. In production take care with root token handling and key storage.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/rekoar/rekor-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: rekor
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: rekor
+  template:
+    metadata:
+      labels:
+        app: rekor
+    spec:
+      containers:
+        - name: rekor
+          image: sigstore/rekor-server:latest
+          ports:
+            - containerPort: 3000
+          env:
+            - name: REKOR_STORAGE_TYPE
+              value: "sqlite" # operator: replace with postgres for production
+            - name: REKOR_API_PORT
+              value: "3000"
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: rekor
+  namespace: aegis
+spec:
+  selector:
+    app: rekor
+  ports:
+    - name: http
+      port: 3000
+      targetPort: 3000
+
+# For production: deploy Postgres and configure REKOR_STORAGE_TYPE=postgres with connection string and TLS.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/cosign/cosign-readme.md
+Cosign production notes (KMS-backed signing)
+
+- To sign images with AWS KMS:
+  - Create a KMS key and grant usage to the CI identity.
+  - Use cosign with the KMS key URI: cosign sign --key aws-kms://arn:aws:kms:... <image>
+  - Rekor should be reachable; pass --rekor-url https://rekor.aegis.svc:3000
+
+- Example GitHub Action step:
+  - name: Cosign sign (AWS KMS)
+    env:
+      COSIGN_EXPERIMENTAL: "1"
+    run: |
+      cosign sign --key "awskms://arn:aws:kms:us-west-2:123456789012:key/EXAMPLE" --rekor-url "${{ secrets.REKOR_URL }}" $IMAGE
+
+Replace AWS key ARN and ensure GitHub runner has AWS credentials.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/signing-proxy/mtls-secrets-example.yaml
+# Example: create mTLS secrets (operator must replace with real certs or use cert-manager)
+apiVersion: v1
+kind: Secret
+metadata:
+  name: signing-proxy-tls
+  namespace: aegis
+type: kubernetes.io/tls
+data:
+  tls.crt: "BASE64_CERT"    # << REPLACE (base64)

î€€
