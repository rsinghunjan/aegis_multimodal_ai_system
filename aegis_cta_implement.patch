*** Begin Patch
*** Add File:terraform/aegis_infra/main.tf
+terraform {
+  required_version = ">= 1.2"
+  required_providers {
+    aws = {
+      source  = "hashicorp/aws"
+      version = "~> 5.0"
+    }
+  }
+}
+
+provider "aws" {
+  region = var.aws_region
+}
+
+resource "aws_kms_key" "vault_unseal" {
+  description             = "Aegis Vault auto-unseal key"
+  deletion_window_in_days = 30
+}
+
+resource "aws_kms_alias" "vault_alias" {
+  name          = "alias/aegis-vault-unseal"
+  target_key_id = aws_kms_key.vault_unseal.key_id
+}
+
+resource "aws_s3_bucket" "evidence" {
+  bucket = var.evidence_bucket
+  acl    = "private"
+
+  versioning {
+    enabled = true
+  }
+
+  object_lock_configuration {
+    object_lock_enabled = "Enabled"
+    rule {
+      default_retention {
+        mode = "GOVERNANCE"
+        days = 365
+      }
+    }
+  }
+
+  server_side_encryption_configuration {
+    rule {
+      apply_server_side_encryption_by_default {
+        sse_algorithm     = "aws:kms"
+        kms_master_key_id = aws_kms_key.vault_unseal.arn
+      }
+    }
+  }
+}
+
+resource "aws_s3_bucket" "model_artifacts" {
+  bucket = var.model_bucket
+  acl    = "private"
+
+  versioning {
+    enabled = true
+  }
+
+  server_side_encryption_configuration {
+    rule {
+      apply_server_side_encryption_by_default {
+        sse_algorithm     = "aws:kms"
+        kms_master_key_id = aws_kms_key.vault_unseal.arn
+      }
+    }
+  }
+}
+
+output "kms_key_arn" {
+  value = aws_kms_key.vault_unseal.arn
+}
+
+output "evidence_bucket" {
+  value = aws_s3_bucket.evidence.bucket
+}
+
+output "model_bucket" {
+  value = aws_s3_bucket.model_artifacts.bucket
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/aegis_infra/variables.tf
+variable "aws_region" {
+  type    = string
+  default = "us-west-2"
+}
+
+variable "evidence_bucket" {
+  type = string
+}
+
+variable "model_bucket" {
+  type = string
+}
+
*** End Patch
*** Begin Patch
*** Add File:ops/signing-proxy/README_mtls_integration.md
+Signing-proxy mTLS integration & Rekor forwarding
+
+Summary:
+- The signing-proxy must run with HTTPS and require client certificates from CI runners.
+- CI runners present a client cert (stored as GitHub secret or injected at runtime) to authenticate and get an ephemeral signing token from Vault.
+- The proxy forwards signatures to Rekor transparency service and persists audit logs to the EVIDENCE_BUCKET.
+
+What we provide:
+- Hardened deployment (ops/signing-proxy/hardened-deployment.yaml) requiring TLS secret and client CA.
+- Example mTLS secrets (deploy/signing-proxy/mtls-secrets-example.yaml).
+- A GitHub Action example to call signing-proxy using client cert (see .github/workflows/cosign_mtls_request.yml).
+
+Operator steps:
+1. Provision a CA (cert-manager or external CA) and create signing-proxy server cert secret and client CA secret.
+2. Provision per-runner client certs (short-lived) and upload them to GitHub Secrets (CERT_PEM, KEY_PEM, CLIENT_CA_PEM) or use OIDC+Vault issuing via dynamic CSR.
+3. Ensure signing-proxy is configured to validate client certs and map cert subject to Vault roles.
+4. Ensure Rekor service available (deploy/rekoar/rekor-deployment.yaml) and SIGNING_PROXY_REKOR_URL env set.
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/cosign_mtls_request.yml
+name: Cosign via signing-proxy (mTLS request)
+on:
+  workflow_dispatch:
+
+jobs:
+  request-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Write client cert & key
+        run: |
+          echo "${{ secrets.SIGNING_CLIENT_CERT }}" > /tmp/client.crt
+          echo "${{ secrets.SIGNING_CLIENT_KEY }}"  > /tmp/client.key
+          chmod 600 /tmp/client.key
+
+      - name: Request signature from signing-proxy
+        env:
+          SIGNING_PROXY_URL: ${{ secrets.SIGNING_PROXY_URL }}
+          IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+        run: |
+          # The signing-proxy exposes a /sign endpoint that accepts JSON: {"artifact": "<image or manifest>"}
+          curl --cert /tmp/client.crt --key /tmp/client.key --cacert <(echo "${{ secrets.SIGNING_CLIENT_CA }}") \
+            -H "Content-Type: application/json" \
+            -d "{\"artifact\": \"${IMAGE_NAME}\"}" \
+            "${SIGNING_PROXY_URL}/sign" -o /tmp/sign_res.json -sS || (cat /tmp/sign_res.json && exit 1)
+          cat /tmp/sign_res.json
+
+      - name: Publish attestation to Rekor (optional)
+        env:
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          # This step expects signing-proxy returned a cosign/public attestation blob; adapt schema as needed.
+          if [ -f /tmp/sign_res.json ]; then
+            echo "Uploading to Rekor (if necessary) - operator implement per signing-proxy output"
+          else
+            echo "No signature output"
+          fi
+
+      - name: Store artifact location
+        run: echo "Signature exchange done (check /tmp/sign_res.json) - store into evidence bucket per runbook"
+
*** End Patch
*** Begin Patch
*** Add File:ops/signing-proxy/vault-ephemeral-token-flow.md
+Signing-proxy — recommended ephemeral token flow (high-level)
+
+1) CI runner authenticates to Vault to get a short-lived client cert or signs CSR via Vault PKI or uses OIDC to request a token scoped for signing.
+2) CI uses client cert to establish mTLS to signing-proxy (mutual auth).
+3) Signing-proxy maps client cert subject to Vault role and calls Vault to issue an ephemeral signing credential (or calls HSM directly if proxy is HSM-adapter).
+4) Signing-proxy uses ephemeral signing key to sign artifact via cosign or HSM and logs the event to Rekor + EVIDENCE_BUCKET.
+5) Signing-proxy revokes ephemeral credential or lets it expire.
+
+Operator: implement steps using Vault PKI (cert-manager + Vault CA) or Vault's PKI/issuance APIs; do not store long-lived keys in CI.
+
*** End Patch
*** Begin Patch
*** Add File:deploy/vault/helm_post_install_notes.md
+Vault productionization checklist (post Helm install)
+
+1) Ensure cert-manager is installed and ClusterIssuer created (deploy/vault/cert-manager-issuer-and-ca.yaml).
+2) Helm install using deploy/vault/ha-values-raft.yaml; confirm Vault pods are on separate nodes and raft storage is healthy.
+3) Provide KMS ARN in the values file (we emitted Terraform to create KMS). Use the KMS Key ARN for auto-unseal.
+4) Run deploy/vault/init-vault-job.yaml to initialize Vault (it will create a vault-init secret containing root token and keys — secure these externally).
+5) Run scripts/ops/vault_policy_loader.sh to create policies and Kubernetes auth roles.
+6) Configure audit device: enable file or socket audit device and archive audit files to EVIDENCE_BUCKET regularly.
+
*** End Patch
*** Begin Patch
*** Add File:gatekeeper/automation/gatekeeper_dryrun_check_and_promote.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Usage:
+#  ./gatekeeper_dryrun_check_and_promote.sh --constraint <constraint-name> --namespace <staging-namespace> [--promote]
+#
+PROMOTE=false
+while [[ $# -gt 0 ]]; do
+  case $1 in
+    --constraint) CONSTRAINT="$2"; shift 2;;
+    --namespace) NS="$2"; shift 2;;
+    --promote) PROMOTE=true; shift;;
+    *) shift;;
+  esac
+done
+
+if [ -z "${CONSTRAINT:-}" ] || [ -z "${NS:-}" ]; then
+  echo "Require --constraint and --namespace"
+  exit 2
+fi
+
+echo "Running Gatekeeper dry-run evaluation for constraint ${CONSTRAINT} in namespace ${NS}"
+# Create a temporary test Pod that would be blocked when enforcement is active
+cat > /tmp/gk_test_pod.yaml <<EOF
+apiVersion: v1
+kind: Pod
+metadata:
+  name: gatekeeper-test-pod
+  namespace: ${NS}
+spec:
+  containers:
+    - name: nginx
+      image: nginx:alpine
+EOF
+
+set +e
+kubectl apply -f /tmp/gk_test_pod.yaml
+RC=$?
+set -e
+
+if [ $RC -eq 0 ]; then
+  echo "Test pod created successfully in dry-run. Gatekeeper NOT blocking. Please review constraint or workload."
+  kubectl delete pod -n "${NS}" gatekeeper-test-pod || true
+else
+  echo "Pod was rejected (good) — Gatekeeper constraint likely effective in dry-run."
+fi
+
+if [ "${PROMOTE}" = true ]; then
+  echo "Promoting constraint ${CONSTRAINT} to enforce mode"
+  kubectl patch constraint "${CONSTRAINT}" --type='merge' -p '{"spec":{"enforcementAction":"deny"}}' || { echo "Patch failed"; exit 1; }
+  echo "Constraint promoted to deny"
+fi
+
+rm -f /tmp/gk_test_pod.yaml
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ops/create_velero_creds_and_install.sh
+#!/usr/bin/env bash
+set -euo pipefail
+BUCKET=${1:-aegis-velero-backups}
+AWS_REGION=${2:-us-west-2}
+CREDENTIALS_FILE=${3:-./credentials-velero}
+
+if [ -z "${AWS_ACCESS_KEY_ID:-}" ] || [ -z "${AWS_SECRET_ACCESS_KEY:-}" ]; then
+  echo "Please export AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY in environment"
+  exit 2
+fi
+
+cat > "${CREDENTIALS_FILE}" <<EOF
+[default]
+aws_access_key_id = ${AWS_ACCESS_KEY_ID}
+aws_secret_access_key = ${AWS_SECRET_ACCESS_KEY}
+EOF
+
+kubectl create namespace velero || true
+kubectl create secret generic cloud-credentials --namespace velero --from-file=cloud=${CREDENTIALS_FILE} || true
+
+echo "Install Velero (operator: ensure velero CLI installed) with provider plugin for snapshots if needed"
+echo "Example:"
+echo "velero install --provider aws --bucket ${BUCKET} --secret-file ${CREDENTIALS_FILE} --backup-location-config region=${AWS_REGION}"
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ops/create_s3_with_object_lock.sh
+#!/usr/bin/env bash
+set -euo pipefail
+BUCKET=${1:-aegis-evidence-bucket}
+REGION=${2:-us-west-2}
+
+echo "Creating S3 bucket with object lock enabled. NOTE: object lock must be enabled at bucket creation time."
+aws s3api create-bucket --bucket "${BUCKET}" --region "${REGION}" --create-bucket-configuration LocationConstraint="${REGION}" || true
+aws s3api put-bucket-versioning --bucket "${BUCKET}" --versioning-configuration Status=Enabled
+aws s3api put-object-lock-configuration --bucket "${BUCKET}" --object-lock-configuration "ObjectLockEnabled=Enabled,Rule={DefaultRetention={Mode=GOVERNANCE,Days=365}}"
+echo "Bucket ${BUCKET} created with versioning and object lock (GOVERNANCE 365d). Verify console settings."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ops/rekor_healthcheck.sh
+#!/usr/bin/env bash
+set -euo pipefail
+REKOR_URL=${REKOR_URL:-http://rekor.aegis.svc:3000}
+echo "Checking Rekor at ${REKOR_URL}"
+curl -sSf "${REKOR_URL}/api/v1/records" >/dev/null 2>&1 && echo "Rekor reachable" || echo "Rekor may be unreachable - check deployment"
+
*** End Patch
*** Begin Patch
*** Add File:docs/CTA_EXECUTION_RUNBOOK.md
+# CTA Execution Runbook: Harden signing, Vault HA, Gatekeeper rollout, Backup Drills
+
+This runbook walks through the four CTAs and the artifacts added by the patch.
+
+Prereqs:
+- kubectl, helm, terraform, aws CLI, velero CLI installed locally (operator workstation)
+- AWS credentials with permissions to create KMS keys and S3 buckets
+- Replace placeholder names in terraform/variables.tf before running
+
+High-level steps:
+1. Provision infra (Terraform)
+   - cd terraform/aegis_infra
+   - terraform init && terraform apply -var="evidence_bucket=<your-evidence-bucket>" -var="model_bucket=<your-model-bucket>"
+   - Record outputs: kms_key_arn, evidence_bucket, model_bucket
+
+2. Create S3 buckets with object-lock (if you prefer script)
+   - scripts/ops/create_s3_with_object_lock.sh <your-evidence-bucket> <region>
+
+3. Install cert-manager and Vault (Helm)
+   - kubectl apply -f deploy/vault/cert-manager-issuer-and-ca.yaml (ensure cert-manager installed)
+   - helm install vault hashicorp/vault -n aegis -f deploy/vault/ha-values-raft.yaml
+   - kubectl apply -f deploy/vault/init-vault-job.yaml
+   - Run scripts/ops/vault_policy_loader.sh to create policies
+
+4. Deploy Rekor and signing-proxy
+   - kubectl apply -f deploy/rekoar/rekor-deployment.yaml
+   - Provision TLS secrets for signing-proxy (see deploy/signing-proxy/mtls-secrets-example.yaml)
+   - kubectl apply -f ops/signing-proxy/hardened-deployment.yaml
+   - Verify with scripts/ops/rekor_healthcheck.sh and curl to signing-proxy /health
+
+5. Configure CI mutual TLS
+   - Issue or generate client certs for CI runners (use Vault PKI or external CA).
+   - Add CERT and KEY to GitHub Secrets: SIGNING_CLIENT_CERT, SIGNING_CLIENT_KEY, SIGNING_CLIENT_CA, SIGNING_PROXY_URL.
+   - Use .github/workflows/cosign_mtls_request.yml as a template to request signatures.
+
+6. Velero & backup drills
+   - scripts/ops/create_velero_creds_and_install.sh <velero-bucket> <region>
+   - Install Velero using the CLI or helm with provided credentials.
+   - Run scripts/ops/run_restore_drill.sh aegis
+
+7. Gatekeeper rollout (staging)
+   - Apply gatekeeper/allowlist-namespace-labels.yaml to create an approved namespace.
+   - Apply gatekeeper/staging-enforcement.yaml (constraints in dryrun mode).
+   - Run gatekeeper/automation/gatekeeper_dryrun_check_and_promote.sh --constraint cosign-required-staging --namespace aegis-staging
+   - If dry-run looks good, promote via --promote and monitor.
+
+8. Falco tuning & SIEM sink
+   - Edit falco/tuning/suppressions.yaml to include observed false positives.
+   - Deploy falco-sidekick or similar forwarder and configure fluent-bit-elastic for SIEM forwarding (logging/fluentbit/output-elastic.yaml).
+
+Verification:
+- Run scripts/health/check_aegis_health.sh and verify all critical components report OK (Vault reachable, signing-proxy healthy, Rekor reachable).
+- Run a CI workflow to sign an example artifact via cosign_mtls_request.yml and confirm Rekor has a record.
+- Run a Velero backup + restore drill and verify restored namespace is functional.
+- Test Gatekeeper by creating sample workloads in staging and ensure dry-run detects violations before flip.
+
+Rollout notes:
+- Keep Gatekeeper constraints in dry-run for at least one release cycle of your staging workloads and collect false positives.
+- Rotate KMS keys and Vault root tokens per your policy. Store tokens in secure, offline vault.
+- Review signing-proxy logs and Rekor records for auditability.
+
*** End Patch
*** End Patch
