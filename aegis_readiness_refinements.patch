Copilot said: ```name=aegis_readiness_refinements.patch *** Begin Patch *** Update File: .github/workflows/readiness_poller.yml @@ name:
name=aegis_readiness_refinements.patch

*** Begin Patch
*** Update File: .github/workflows/readiness_poller.yml
@@
 name: Readiness Poller & Notifier
 
 # Runs on a schedule and on-demand. The job runs the repo readiness checker,
 # posts a summary to Slack, and upserts a comment on all open PRs.
-on:
-  # Run on a schedule (daily at 08:00 UTC) and also when main is updated (merge/push),
-  # and on-demand.
-  schedule:
-    - cron: '0 8 * * *'
-  push:
-    branches:
-      - main
-  workflow_dispatch: {}
+on:
+  # Run on a schedule (daily at 08:00 UTC) and on-demand only.
+  # To reduce noise, this workflow no longer runs on every push to main by default.
+  schedule:
+    - cron: '0 8 * * *'
+  workflow_dispatch: {}
*** End Patch
*** Begin Patch
*** Update File: scripts/post_readiness_to_slack_and_prs.sh
@@
 set -euo pipefail
 
 SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 
 # Ensure the readiness checker exists
 if [ ! -x "${SCRIPT_DIR}/repo_readiness_check.sh" ]; then
   echo "Error: repo_readiness_check.sh not found or not executable at ${SCRIPT_DIR}" >&2
   exit 2
 fi
@@
 SLACK_WEBHOOK_URL="${SLACK_WEBHOOK_URL:-}"
 GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-${REPO:-}}"
 GITHUB_TOKEN="${GITHUB_TOKEN:-${INPUT_GITHUB_TOKEN:-}}"
 POST_TO_PR="${POST_TO_PR:-}"
+# Optional filters to reduce PR noise:
+# - If ALLOWED_PR_LABELS is set (comma-separated) only PRs that have at least one of those labels will be considered.
+# - If ALLOWED_PR_AUTHORS is set (comma-separated) only PRs authored by one of those logins will be considered.
+# - FORCE_COMMENT_ALL=true bypasses these filters and the infra-file filter.
+ALLOWED_PR_LABELS="${ALLOWED_PR_LABELS:-}"
+ALLOWED_PR_AUTHORS="${ALLOWED_PR_AUTHORS:-}"
+# Retry/backoff settings
+API_MAX_RETRIES="${API_MAX_RETRIES:-5}"
+API_BASE_DELAY="${API_BASE_DELAY:-1}"
 
 # Default behavior: if GITHUB_TOKEN present and POST_TO_PR not set, enable posting
 if [ -z "$POST_TO_PR" ]; then
   if [ -n "$GITHUB_TOKEN" ]; then
     POST_TO_PR="true"
   else
     POST_TO_PR="false"
   fi
 fi
 
 if [ -z "$SLACK_WEBHOOK_URL" ]; then
   echo "Warning: SLACK_WEBHOOK_URL not set; Slack posting will be skipped." >&2
 fi
@@
 # Build a concise text summary
 summary_lines=()
 summary_lines+=("*Aegis repo readiness summary* â€” checked at ${checked_at}")
@@
 payload_text=$(printf "%s\n" "${summary_lines[@]}")
 
-# Post to Slack if webhook provided
-if [ -n "$SLACK_WEBHOOK_URL" ]; then
-  echo "Posting summary to Slack webhook..."
-  # Slack expects JSON with "text" or blocks. Use basic text payload.
-  slack_payload=$(jq -n --arg t "$payload_text" '{text: $t}')
-  curl -sS -X POST -H 'Content-type: application/json' --data "$slack_payload" "$SLACK_WEBHOOK_URL" >/dev/null || {
-    echo "Warning: Slack webhook post failed" >&2
-  }
-else
-  echo "SLACK_WEBHOOK_URL not set; skipping Slack post."
-fi
+#
+# Backoff helpers for API calls (Slack & GitHub). Retry on network errors and 5xx/429.
+#
+backoff_attempt() {
+  # $1 = attempt number (1-based)
+  # returns sleep seconds (exponential with jitter)
+  base=$API_BASE_DELAY
+  attempt=$1
+  # exponential backoff with jitter
+  max_sleep=$(( base * (2 ** (attempt - 1)) ))
+  # jitter: pick random between base and max_sleep (bash arithmetic)
+  if [ "$max_sleep" -le "$base" ]; then
+    echo "$base"
+  else
+    # generate pseudo-random jitter
+    jitter=$(( (RANDOM % (max_sleep - base + 1)) + base ))
+    echo "$jitter"
+  fi
+}
+
+http_post_with_retries() {
+  # $1 = url
+  # $2 = data/body (string)
+  # $3 = content-type header (optional)
+  url="$1"; data="$2"; ctype="${3:-application/json}"
+  attempt=1
+  while [ $attempt -le "$API_MAX_RETRIES" ]; do
+    resp=$(curl -sS -w "\n%{http_code}" -X POST -H "Content-Type: $ctype" --data "$data" "$url" 2>/dev/null) || rc=$? || true
+    if [ -z "${resp:-}" ]; then
+      rc=${rc:-1}
+    else
+      rc=0
+    fi
+    body=$(echo "$resp" | sed '$d' 2>/dev/null || true)
+    code=$(echo "$resp" | tail -n1 2>/dev/null || echo "000")
+    # treat success 2xx
+    if [ "${code:0:1}" = "2" ]; then
+      printf '%s\n' "$body"
+      return 0
+    fi
+    # retry on 429 or 5xx, otherwise break
+    if [ "$code" = "429" ] || [ "${code:0:1}" = "5" ] || [ $rc -ne 0 ]; then
+      sleep_sec=$(backoff_attempt "$attempt")
+      echo "Request to $url failed with http=$code rc=$rc; retrying in ${sleep_sec}s (attempt $attempt/$API_MAX_RETRIES)..." >&2
+      sleep "$sleep_sec"
+      attempt=$((attempt + 1))
+      continue
+    else
+      # non-retriable error
+      echo "Request to $url failed with http=$code; not retrying." >&2
+      printf '%s\n' "$body"
+      return 1
+    fi
+  done
+  echo "exhausted retries for $url" >&2
+  return 2
+}
+
+github_api_with_retries() {
+  # $1 method, $2 url, $3 data (optional)
+  method="$1"; url="$2"; data="${3:-}"
+  attempt=1
+  while [ $attempt -le "$API_MAX_RETRIES" ]; do
+    if [ -n "$data" ]; then
+      resp=$(curl -sS -w "\n%{http_code}" -X "$method" -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" --data "$data" "$url" 2>/dev/null) || rc=$? || true
+    else
+      resp=$(curl -sS -w "\n%{http_code}" -X "$method" -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "$url" 2>/dev/null) || rc=$? || true
+    fi
+    if [ -z "${resp:-}" ]; then
+      rc=${rc:-1}
+    else
+      rc=0
+    fi
+    body=$(echo "$resp" | sed '$d' 2>/dev/null || true)
+    code=$(echo "$resp" | tail -n1 2>/dev/null || echo "000")
+    if [ "${code:0:1}" = "2" ]; then
+      printf '%s\n' "$body"
+      return 0
+    fi
+    if [ "$code" = "429" ] || [ "${code:0:1}" = "5" ] || [ $rc -ne 0 ]; then
+      sleep_sec=$(backoff_attempt "$attempt")
+      echo "GitHub API $method $url failed http=$code rc=$rc; retrying in ${sleep_sec}s (attempt $attempt/$API_MAX_RETRIES)..." >&2
+      sleep "$sleep_sec"
+      attempt=$((attempt + 1))
+      continue
+    else
+      echo "GitHub API $method $url failed http=$code; not retrying." >&2
+      printf '%s\n' "$body"
+      return 1
+    fi
+  done
+  echo "exhausted retries for GitHub API $method $url" >&2
+  return 2
+}
+
+# Post to Slack if webhook provided (with retries)
+if [ -n "$SLACK_WEBHOOK_URL" ]; then
+  echo "Posting summary to Slack webhook (with retries)..."
+  slack_payload=$(jq -n --arg t "$payload_text" '{text: $t}')
+  if ! http_post_with_retries "$SLACK_WEBHOOK_URL" "$slack_payload" "application/json" >/dev/null 2>&1; then
+    echo "Warning: Slack webhook post failed after retries" >&2
+  fi
+else
+  echo "SLACK_WEBHOOK_URL not set; skipping Slack post."
+fi
@@
-  PRS_JSON=$(curl -sS -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
-    "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls?state=open&per_page=100")
+  PRS_JSON=$(github_api_with_retries GET "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls?state=open&per_page=100") || PRS_JSON="[]"
 
   pr_numbers=$(echo "$PRS_JSON" | jq -r '.[].number')
 
   if [ -z "$pr_numbers" ]; then
     echo "No open PRs found in ${GITHUB_REPOSITORY}."
   else
-    # Optional filter: only comment on PRs that touch infra/ops files to reduce noise.
-    # Set FORCE_COMMENT_ALL=true to bypass filtering and comment on all open PRs.
-    for pr in $pr_numbers; do
-      echo "Processing PR #$pr ..."
-
-      # Get list of files changed in this PR
-      files_json=$(curl -sS -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
-        "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${pr}/files?per_page=500")
-      changed_files=$(echo "$files_json" | jq -r '.[].filename' | tr '\n' ' ')
-
-      # Define path prefixes that count as infra/ops changes
-      infra_prefixes=( "infra/" "scripts/" "k8s/" "docs/" ".github/workflows/" )
-
-      touches_infra=false
-      if [ "${FORCE_COMMENT_ALL:-false}" = "true" ]; then
-        touches_infra=true
-      else
-        for f in $changed_files; do
-          for pfx in "${infra_prefixes[@]}"; do
-            case "$f" in
-              ${pfx}*) touches_infra=true; break 3 ;;
-            esac
-          done
-        done
-      fi
-
-      if [ "$touches_infra" != "true" ]; then
-        echo "PR #${pr} does not touch infra/ops files; skipping comment to reduce noise."
-        continue
-      fi
-
-      comments=$(curl -sS -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
-        "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr}/comments")
+    # Optional filters:
+    # - ALLOWED_PR_LABELS (comma-separated): only PRs with at least one of these labels are considered.
+    # - ALLOWED_PR_AUTHORS (comma-separated): only PRs authored by one of these logins are considered.
+    for pr in $pr_numbers; do
+      echo "Processing PR #$pr ..."
+
+      pr_json=$(github_api_with_retries GET "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${pr}") || pr_json="{}"
+      pr_author=$(echo "$pr_json" | jq -r '.user.login // empty')
+      pr_labels=$(echo "$pr_json" | jq -r '[.labels[].name] | join(",")')
+
+      # label filter
+      if [ -n "$ALLOWED_PR_LABELS" ] && [ "${FORCE_COMMENT_ALL:-false}" != "true" ]; then
+        match_label=false
+        IFS=',' read -r -a allowed_labels_arr <<< "$ALLOWED_PR_LABELS"
+        for lbl in "${allowed_labels_arr[@]}"; do
+          lbl_trimmed=$(echo "$lbl" | xargs)
+          if echo ",$pr_labels," | grep -Fq ",${lbl_trimmed},"; then
+            match_label=true; break
+          fi
+        done
+        if [ "$match_label" != "true" ]; then
+          echo "PR #$pr does not have allowed labels (${ALLOWED_PR_LABELS}); skipping."
+          continue
+        fi
+      fi
+
+      # author filter
+      if [ -n "$ALLOWED_PR_AUTHORS" ] && [ "${FORCE_COMMENT_ALL:-false}" != "true" ]; then
+        match_author=false
+        IFS=',' read -r -a allowed_authors_arr <<< "$ALLOWED_PR_AUTHORS"
+        for a in "${allowed_authors_arr[@]}"; do
+          a_trimmed=$(echo "$a" | xargs)
+          if [ "$a_trimmed" = "$pr_author" ]; then
+            match_author=true; break
+          fi
+        done
+        if [ "$match_author" != "true" ]; then
+          echo "PR #$pr authored by ${pr_author} which is not in ALLOWED_PR_AUTHORS; skipping."
+          continue
+        fi
+      fi
+
+      # Get list of files changed in this PR
+      files_json=$(github_api_with_retries GET "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${pr}/files?per_page=500") || files_json="[]"
+      changed_files=$(echo "$files_json" | jq -r '.[].filename' | tr '\n' ' ')
+
+      # Define path prefixes that count as infra/ops changes (existing behavior)
+      infra_prefixes=( "infra/" "scripts/" "k8s/" "docs/" ".github/workflows/" )
+
+      touches_infra=false
+      if [ "${FORCE_COMMENT_ALL:-false}" = "true" ]; then
+        touches_infra=true
+      else
+        for f in $changed_files; do
+          for pfx in "${infra_prefixes[@]}"; do
+            case "$f" in
+              ${pfx}*) touches_infra=true; break 3 ;;
+            esac
+          done
+        done
+      fi
+
+      if [ "$touches_infra" != "true" ]; then
+        echo "PR #${pr} does not touch infra/ops files; skipping comment to reduce noise."
+        continue
+      fi
+
+      comments=$(github_api_with_retries GET "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr}/comments") || comments="[]"
 
       # Look for an existing comment containing the marker
       existing_id=$(echo "$comments" | jq -r --arg marker "$COMMENT_MARKER" '.[] | select(.body | contains($marker)) | .id' | head -n1)
 
       body=$(compose_comment_body)
 
-      if [ -n "$existing_id" ] && [ "$existing_id" != "null" ]; then
-        echo "Updating existing comment id ${existing_id} on PR #${pr}"
-        update_payload=$(jq -n --arg b "$body" '{body:$b}')
-        curl -sS -X PATCH -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
-          "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/comments/${existing_id}" \
-          -d "$update_payload" >/dev/null || echo "Warning: failed to update comment ${existing_id}"
-      else
-        echo "Creating new comment on PR #${pr}"
-        create_payload=$(jq -n --arg b "$body" '{body:$b}')
-        curl -sS -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
-          "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr}/comments" \
-          -d "$create_payload" >/dev/null || echo "Warning: failed to create comment on PR ${pr}"
-      fi
+      if [ -n "$existing_id" ] && [ "$existing_id" != "null" ]; then
+        echo "Updating existing comment id ${existing_id} on PR #${pr}"
+        update_payload=$(jq -n --arg b "$body" '{body:$b}')
+        github_api_with_retries PATCH "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/comments/${existing_id}" "$update_payload" >/dev/null || echo "Warning: failed to update comment ${existing_id}"
+      else
+        echo "Creating new comment on PR #${pr}"
+        create_payload=$(jq -n --arg b "$body" '{body:$b}')
+        github_api_with_retries POST "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr}/comments" "$create_payload" >/dev/null || echo "Warning: failed to create comment on PR ${pr}"
+      fi
     done
   fi
 else
   echo "PR posting disabled (POST_TO_PR=${POST_TO_PR}) or missing GITHUB_REPOSITORY/GITHUB_TOKEN. Skipping PR comments."
 fi
 
 echo "Done."
*** End Patch

