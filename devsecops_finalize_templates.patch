*** Begin Patch
*** Add File:security/clusterissuer_corporate_ca.yaml.template
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: corporate-ca-issuer
+spec:
+  ca:
+    # This ClusterIssuer expects a TLS secret containing a CA cert & key.
+    # Create the secret using security/create_cert_secret.sh:
+    # ./security/create_cert_secret.sh /path/to/ca.crt /path/to/ca.key cert-manager
+    secretName: corporate-ca-keypair
+
+# Notes:
+# - Replace `corporate-ca-keypair` with the secret name you create in the cert-manager namespace.
+# - After applying this ClusterIssuer, restart any webhook deployments that depend on the CA bundle.
+
*** End Patch
*** Begin Patch
*** Add File:terraform/aws/kms_prod.tfvars.template
+# Template terraform variable file for KMS cosign key provisioning (replace placeholders)
+
+# The list of allowed principals (IAM role/user ARNs) that can use the cosign KMS key.
+allowed_principals = [
+  "arn:aws:iam::111122223333:role/aegis-ci",
+  "arn:aws:iam::111122223333:role/security",
+  "arn:aws:iam::111122223333:role/platform-automation"
+]
+
+# Name and alias for KMS key
+cosign_alias = "aegis-cosign-prod"
+
+# Optional: tags
+tags = {
+  "team" = "aegis"
+  "env"  = "prod"
+}
+
+# Evidence bucket used to store audit artifacts (replace)
+evidence_bucket = "REPLACE_WITH_EVIDENCE_BUCKET"
+
+# Region
+aws_region = "REPLACE_WITH_AWS_REGION"
+
+# Change these values before running `terraform apply`
+
*** End Patch
*** Begin Patch
*** Add File:devsecops/external_secrets_full.yaml.template
+---
+# SecretStore for AWS Secrets Manager (ExternalSecrets)
+apiVersion: external-secrets.io/v1beta1
+kind: SecretStore
+metadata:
+  name: aws-secrets-manager
+  namespace: aegis
+spec:
+  provider:
+    aws:
+      service: SecretsManager
+      region: REPLACE_WITH_AWS_REGION
+      auth:
+        jwt:
+          serviceAccountRef:
+            name: external-secrets-sa
+
+---
+# ExternalSecret: COSIGN KMS ARN
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: cosign-kms
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: cosign-kms
+    creationPolicy: Owner
+  data:
+    - secretKey: COSIGN_KMS_KEY_ARN
+      remoteRef:
+        key: REPLACE_SECRETPATH/cosign/kms_key_arn
+
+---
+# ExternalSecret: DW credentials (Redshift / BigQuery / Snowflake DSN)
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: dw-credentials
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: dw-credentials
+    creationPolicy: Owner
+  data:
+    - secretKey: REDSHIFT_DSN
+      remoteRef:
+        key: REPLACE_SECRETPATH/dw/redshift_dsn
+    - secretKey: REDSHIFT_IAM_ROLE_ARN
+      remoteRef:
+        key: REPLACE_SECRETPATH/dw/redshift_iam_role_arn
+
+---
+# ExternalSecret: Kubeconfigs (staging / prod) - ensure safe permissions
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: kubeconfigs
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: kubeconfigs
+    creationPolicy: Owner
+  data:
+    - secretKey: KUBECONFIG_STAGING
+      remoteRef:
+        key: REPLACE_SECRETPATH/kubeconfigs/staging
+    - secretKey: KUBECONFIG_PROD
+      remoteRef:
+        key: REPLACE_SECRETPATH/kubeconfigs/prod
+
+---
+# ExternalSecret: MLflow token & Rekor URL (optional)
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: mlflow-and-rekor
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: mlflow-and-rekor
+    creationPolicy: Owner
+  data:
+    - secretKey: MLFLOW_TOKEN
+      remoteRef:
+        key: REPLACE_SECRETPATH/mlflow/token
+    - secretKey: REKOR_URL
+      remoteRef:
+        key: REPLACE_SECRETPATH/rekor/url
+
+# NOTES:
+# - Replace REPLACE_WITH_AWS_REGION and REPLACE_SECRETPATH values with your AWS region and Secrets Manager key prefixes.
+# - Ensure the ExternalSecrets controller has IAM permission to read the referenced secrets.
+
*** End Patch
*** Begin Patch
*** Add File:pr_ready/README_PR_INSTRUCTIONS.md
+# PR instructions — how to populate templates and open a PR with the DevSecOps finalization changes
+
+Files added (templates):
+- security/clusterissuer_corporate_ca.yaml.template
+- terraform/aws/kms_prod.tfvars.template
+- devsecops/external_secrets_full.yaml.template
+
+Steps to create a populated branch:
+1. Copy templates to concrete files and replace placeholders:
+   - cp security/clusterissuer_corporate_ca.yaml.template security/clusterissuer_corporate_ca.yaml
+   - edit clusterissuer to reference the TLS secret name you created via security/create_cert_secret.sh
+   - cp terraform/aws/kms_prod.tfvars.template terraform/aws/kms_prod.tfvars
+   - edit allowed_principals, evidence_bucket, aws_region
+   - cp devsecops/external_secrets_full.yaml.template devsecops/external_secrets_full.yaml
+   - fill REPLACE_SECRETPATH and REPLACE_WITH_AWS_REGION
+
+2. Validate locally:
+   - terraform fmt && terraform validate (for TF files)
+   - conftest test k8s/ devsecops/policy --policy devsecops/policy
+
+3. Commit & open PR (example):
+   BRANCH="aegis/devsecops-finalize-$(date -u +%Y%m%dT%H%M%SZ)"
+   git checkout -b "$BRANCH"
+   git add .
+   git commit -m "DevSecOps: add ClusterIssuer, KMS tfvars and ExternalSecrets templates"
+   git push -u origin "$BRANCH"
+   # open PR via gh or UI:
+   gh pr create --title "DevSecOps: finalize KMS/ClusterIssuer/ExternalSecrets" --body "Templates added; fill in values and run TF/apply per playbook." --base main
+
+If you want, provide repo (owner/repo) and base branch and I will open the PR for you after you confirm.
+
*** End Patch
*** Begin Patch
*** Add File:devsecops/final_devsecops_playbook.template.md
+# Final DevSecOps Playbook (template) — populate and run
+
+Important: this is a template. Fill in the placeholders (AWS account IDs, evidence bucket, secret paths, KMS principals, Rekor URL, kubeconfig paths) before executing any command in production.
+
+1) Prepare variables (example)
+ - EVIDENCE_BUCKET=REPLACE_WITH_EVIDENCE_BUCKET
+ - AWS_REGION=REPLACE_WITH_AWS_REGION
+ - REKOR_URL=REPLACE_WITH_REKOR_URL
+ - COSIGN_ALIAS=aegis-cosign-prod
+ - KMS_PRINCIPALS=(arn:aws:iam::111122223333:role/aegis-ci arn:aws:iam::111122223333:role/security)
+ - TFVARS=terraform/aws/kms_prod.tfvars
+
+2) Provision KMS with restrictive policy (Terraform)
+ - Edit terraform/aws/kms_prod.tfvars with allowed_principals and run:
+   terraform -chdir=terraform/aws init
+   terraform -chdir=terraform/aws apply -var-file=kms_prod.tfvars -auto-approve
+ - Verify key ARN and alias in outputs; record COSIGN_KMS_KEY_ARN.
+ - Run validation:
+   python3 devsecops/tools/kms_policy_validator.py <kms-key-arn>
+
+3) Create TLS secret for cert-manager (corporate CA)
+ - Run on operator workstation (with kubectl access to cluster):
+   ./security/create_cert_secret.sh /path/to/ca.crt /path/to/ca.key cert-manager
+ - Apply ClusterIssuer:
+   cp security/clusterissuer_corporate_ca.yaml.template security/clusterissuer_corporate_ca.yaml
+   edit security/clusterissuer_corporate_ca.yaml to match secret name and apply:
+   kubectl apply -f security/clusterissuer_corporate_ca.yaml
+
+4) Configure ExternalSecrets
+ - Edit devsecops/external_secrets_full.yaml.template -> devsecops/external_secrets_full.yaml replacing REPLACE_SECRETPATH & region
+ - kubectl apply -f devsecops/external_secrets_full.yaml
+ - Verify secrets are mirrored:
+   kubectl -n aegis get secret cosign-kms dw-credentials kubeconfigs
+
+5) Rotate cosign key (if migrating)
+ - Use automation (best-effort):
+   ./security/cosign_rotate_rekor_automate.sh aegis-cosign-prod ${REKOR_URL}
+ - Update ExternalSecrets (or Secrets Manager entry) to point to the new key ARN.
+ - Verify cosign sign/verify in a staging workflow using ci/auto_calibration_and_sign.yml
+
+6) Gatekeeper & PR policy enforcement
+ - Ensure Gatekeeper is installed.
+ - kubectl apply -f devsecops/gatekeeper/constrainttemplate_clusterrolebinding.yaml
+ - kubectl apply -f devsecops/gatekeeper/constraint_clusterrolebinding.yaml
+ - Activate conftest CI checks and devsecops CI pipelines.
+
+7) Final validations (weekly readiness gate)
+ - Run ci/production_readiness_gate.yml or run checks manually:
+   - Telemetry 14-day coverage exists: aws s3 ls s3://$EVIDENCE_BUCKET/telemetry/health/
+   - Calibration aggregated median <= 0.10: python3 calibration/validation_aggregator.py --days 14
+   - Enforcement coverage >= 0.95: aws s3 cp s3://$EVIDENCE_BUCKET/enforcement/coverage_reports/latest.json /tmp && jq .
+   - DW idempotency test: python3 etl/load_scale_test.py --rows 50000 --reps 2
+   - Signed report present: aws s3 ls s3://$EVIDENCE_BUCKET/calibration/approved/
+
+8) Sign-off
+ - Security lead and Platform lead must verify KMS, Gatekeeper constraints, ExternalSecrets mirroring and webhook CA.
+ - Document final artifacts in s3://$EVIDENCE_BUCKET/audit/<release-id> and run audit/audit_package_collector.py
+
+If you want me to populate this playbook with your real environment values and open a PR, provide the values requested below.
+
*** End Patch
*** End Patch
