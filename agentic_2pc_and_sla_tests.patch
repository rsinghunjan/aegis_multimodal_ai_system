*** Begin Patch
*** Add File: tests/mock_participant.py
+#!/usr/bin/env python3
+"""
+Mock participant for 2PC integration testing.
+Exposes endpoints expected by Transaction Manager:
+ - POST /prepare  -> returns 200 or 500 depending on query param or runtime toggle
+ - POST /commit   -> returns 200
+ - POST /abort    -> returns 200
+
+Usage:
+  UVICORN: uvicorn tests.mock_participant:app --host 127.0.0.1 --port 8000
+Environment:
+  FAIL_PREPARE: if set to "1" the /prepare endpoint will return 500 to simulate participant prepare failure.
+  LOG_FILE: optional path to append participant events (default /tmp/mock_participant.log)
+"""
+import os, time, json
+from fastapi import FastAPI, Request
+from pydantic import BaseModel
+
+app = FastAPI(title="Mock Participant")
+LOG = os.environ.get("LOG_FILE", "/tmp/mock_participant.log")
+
+class PrepIn(BaseModel):
+    action: str = None
+    tx_id: str = None
+
+def append_log(entry: dict):
+    entry["ts"] = int(time.time())
+    try:
+        with open(LOG, "a") as fh:
+            fh.write(json.dumps(entry) + "\n")
+    except Exception:
+        pass
+
+@app.post("/prepare")
+async def prepare(req: PrepIn):
+    body = req.dict()
+    # check runtime override by env var
+    fail = os.environ.get("FAIL_PREPARE", "0") == "1"
+    append_log({"event":"prepare_called", "body": body, "fail": fail})
+    if fail:
+        return {"ok": False, "error": "simulated prepare failure"}, 500
+    # simulate some processing time
+    await __import__("asyncio").sleep(0.5)
+    return {"ok": True, "status": "prepared"}
+
+@app.post("/commit")
+async def commit(req: PrepIn):
+    body = req.dict()
+    append_log({"event":"commit_called", "body": body})
+    await __import__("asyncio").sleep(0.2)
+    return {"ok": True, "status": "committed"}
+
+@app.post("/abort")
+async def abort(req: PrepIn):
+    body = req.dict()
+    append_log({"event":"abort_called", "body": body})
+    await __import__("asyncio").sleep(0.1)
+    return {"ok": True, "status": "aborted"}
+
+@app.get("/health")
+def health():
+    return {"ok": True}
+
*** End Patch
*** Begin Patch
*** Add File: tests/2pc_integration_test.sh
+#!/usr/bin/env bash
+#
+# 2PC integration test script
+# Requirements: transaction-manager service must be reachable at TXMGR_URL (default http://localhost:8301)
+# It will launch a mock participant locally on port 8000 and run:
+#  - Successful prepare -> commit
+#  - Forced prepare failure -> abort
+
+set -euo pipefail
+
+TXMGR_URL=${TXMGR_URL:-http://localhost:8301}
+PART_URL=${PART_URL:-http://127.0.0.1:8000}
+
+echo "Starting mock participant..."
+# Start uvicorn in background
+uvicorn tests.mock_participant:app --host 127.0.0.1 --port 8000 >/tmp/mock_participant.log 2>&1 &
+MP_PID=$!
+sleep 1
+echo "Mock participant PID: $MP_PID"
+
+echo "=== Test 1: Success path (prepare -> commit) ==="
+TX_ID=$(curl -s -X POST "${TXMGR_URL}/tx/start" | jq -r '.tx_id')
+echo "Started tx: $TX_ID"
+
+echo "Registering participant..."
+curl -s -X POST "${TXMGR_URL}/tx/${TX_ID}/participant" -H "Content-Type: application/json" -d "{\"name\":\"mock1\",\"prepare_url\":\"${PART_URL}/prepare\",\"commit_url\":\"${PART_URL}/commit\",\"abort_url\":\"${PART_URL}/abort\"}" | jq .
+
+echo "Calling prepare..."
+RES=$(curl -s -X POST "${TXMGR_URL}/tx/${TX_ID}/prepare")
+echo "Prepare response: $RES"
+
+echo "Calling commit..."
+RES2=$(curl -s -X POST "${TXMGR_URL}/tx/${TX_ID}/commit")
+echo "Commit response: $RES2"
+
+echo "Fetching tx status..."
+curl -s "${TXMGR_URL}/tx/${TX_ID}" | jq .
+
+echo "=== Test 2: Failure path (prepare fails -> abort) ==="
+echo "Restarting mock participant in fail mode..."
+kill $MP_PID || true
+sleep 1
+FAIL_PREPARE=1 LOG_FILE=/tmp/mock_participant_fail.log uvicorn tests.mock_participant:app --host 127.0.0.1 --port 8000 >/tmp/mock_participant_fail.log 2>&1 &
+MP_PID=$!
+sleep 1
+
+TX_ID2=$(curl -s -X POST "${TXMGR_URL}/tx/start" | jq -r '.tx_id')
+echo "Started tx: $TX_ID2"
+curl -s -X POST "${TXMGR_URL}/tx/${TX_ID2}/participant" -H "Content-Type: application/json" -d "{\"name\":\"mock1\",\"prepare_url\":\"${PART_URL}/prepare\",\"commit_url\":\"${PART_URL}/commit\",\"abort_url\":\"${PART_URL}/abort\"}" | jq .
+
+echo "Calling prepare (expected to fail)..."
+set +e
+PREPRES=$(curl -s -X POST "${TXMGR_URL}/tx/${TX_ID2}/prepare")
+RET=$?
+set -e
+echo "Prepare returned exit $RET and body: $PREPRES"
+
+echo "Fetching tx status after failed prepare..."
+curl -s "${TXMGR_URL}/tx/${TX_ID2}" | jq .
+
+echo "Cleaning up mock participant..."
+kill $MP_PID || true
+
+echo "2PC integration tests completed."
+
*** End Patch
*** Begin Patch
*** Add File: prometheus/alerts-tx.rules.yaml
+groups:
+- name: aegis-tx-alerts
+  rules:
+  - alert: TransactionPrepareLatencyHigh
+    expr: histogram_quantile(0.95, sum(rate(tx_prepare_duration_seconds_bucket[5m])) by (le)) > 5
+    for: 10m
+    labels:
+      severity: page
+    annotations:
+      summary: "Transaction prepare latency high (95th > 5s)"
+      description: "Transaction coordinator prepare calls are slow. Investigate participant responsiveness."
+
+  - alert: TransactionAbortRateHigh
+    expr: increase(tx_aborts_total[10m]) > 5
+    for: 5m
+    labels:
+      severity: warning
+    annotations:
+      summary: "High transaction abort rate"
+      description: "More than 5 aborts occurred in the last 10 minutes. Check participants and orchestrator logs."
+
*** End Patch
*** Begin Patch
*** Add File: runbooks/2pc_and_sla_runbook.md
+# 2PC & Long-running Agent SLA Runbook
+
+Purpose: how to validate 2PC transactional semantics and SLA for longâ€‘running agents in staging.
+
+Prereqs:
+- transaction-manager service reachable (TXMGR_URL, default http://localhost:8301)
+- mock_participant (tests/mock_participant.py) and tests/2pc_integration_test.sh available on test runner
+- Prometheus scraping transaction-manager metrics (tx_prepare_duration_seconds, tx_aborts_total)
+
+Steps: 2PC integration tests
+1. Run the 2PC integration test:
+   - ./tests/2pc_integration_test.sh
+   - The script runs two scenarios:
+     a) successful prepare => commit
+     b) forced prepare failure => abort
+2. Inspect logs:
+   - Mock participant logs: /tmp/mock_participant.log and /tmp/mock_participant_fail.log
+   - Transaction manager logs (/var/log/txmgr or container logs)
+3. Verify metrics:
+   - Query Prometheus for tx_prepare_duration_seconds and tx_aborts_total
+   - Ensure no unexpected aborts are occurring.
+
+Steps: Long-running agent SLA validation (pilot)
+1. Define SLA threshold (e.g., agent task end-to-end completion <= 10 minutes).
+2. Submit representative long-running plans to agent orchestrator via API (or simulate long-running via mock orchestrator).
+3. Observe agent session lifecycle in Redis (agent:state:{session_id}) and measure total duration.
+4. Verify Prometheus alerting: ApprovalLatencyHigh and custom agent task latency metrics are within SLO.
+
+If SLA breach:
+- Escalate to SRE and operator on-call.
+- Run sandbox-scale test to ensure sandbox stability.
+- If related to participant failures, run the 2PC failure scenario and collect evidence for participant owner.
+
+Automation:
+- Add tests/2pc_integration_test.sh as a scheduled CI job in staging to run nightly.
+- Alert on TransactionPrepareLatencyHigh and TransactionAbortRateHigh via Prometheus -> PagerDuty.
+
*** End Patch
