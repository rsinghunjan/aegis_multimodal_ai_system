*** Begin Patch
*** Add File:docs/vault_transit_signing.md
+# Vault Transit Signing (generic, provider-agnostic)
+
+This document describes a generic, provider-agnostic way to use HashiCorp Vault's Transit secrets engine to sign artifacts and verify signatures. By using Vault Transit you can centralize signing keys, rotate keys, and avoid embedding cloud provider credentials in CI. The scripts in scripts/vault/ are scaffolds that operators should review and adapt to their Vault version and policy model.
+
+High-level flow
+1. Enable the Transit secrets engine (if not already enabled).
+2. Create a transit key for signing (ECDSA recommended for compact signatures).
+3. Create a Vault policy that allows the CI or service account to use transit/sign on the key.
+4. Use the provided wrapper script to sign artifacts via Vault (no private key ever leaves Vault).
+5. Optionally export the public key (if your Vault setup allows export) for external verification, or verify signatures by calling Vault verify APIs if available.
+6. Record signatures and artifacts in Rekor (recommended) for public/non-repudiable audit entries.
+
+Security notes & operator guidance
+- Exporting public keys: For maximum security, keep keys non-exportable. If you need to publish public keys for verification (e.g., cosign verify-blob), create an exportable signing key only if permitted by policy. Alternatively, make Vault itself the verification authority (verify via Vault API) or publish a wrapped public key created by an offline process.
+- Least privilege: Create a dedicated Vault policy for signing and bind it to a short-lived token or a Kubernetes service account via Kubernetes auth/OIDC.
+- Audit: Ensure Vault audit logging is enabled and forwarded to your SIEM before using any signing key.
+- Rekor: Record signed artifacts to Rekor for immutable timestamped records.
+
+Files added
+- scripts/vault/transit_setup.sh — creates transit key and policy (interactive placeholders).
+- scripts/vault/vault_transit_sign.sh — wrapper to sign a file via Vault Transit and write a signature file.
+- scripts/vault/export_public_key.sh — helper to export public key (operator: verify commands for your Vault version).
+- .github/workflows/vault_transit_sign_example.yml — example GitHub Action showing how CI could call the wrapper (requires VAULT_ADDR & VAULT_TOKEN set in runner/secret).
+
+Usage summary (example)
+1. Bootstrap transit key (operator):
+   VAULT_ADDR="https://vault.example.com" VAULT_TOKEN=<token> bash scripts/vault/transit_setup.sh
+
+2. Sign artifact locally (operator):
+   VAULT_ADDR="https://vault.example.com" VAULT_TOKEN=<token> bash scripts/vault/vault_transit_sign.sh --key aegis-signing-key --file ./build/artifact.tar.gz --out ./artifact.sig
+
+3. (Optional) Export public key for external verification:
+   VAULT_ADDR="https://vault.example.com" VAULT_TOKEN=<token> bash scripts/vault/export_public_key.sh --key aegis-signing-key --out ./pub.pem
+
+4. Verify signature with cosign verify-blob (if pub.pem is available):
+   cosign verify-blob --key pub.pem --signature artifact.sig ./build/artifact.tar.gz
+
+Operator note: These scripts are intentionally conservative scaffolds to avoid including tenancy secrets. Review and adapt them to your Vault deployment and security posture before using in CI.
+
*** End Patch
*** Begin Patch
*** Add File:scripts/vault/transit_setup.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# transit_setup.sh
+# Generic script to enable transit and create a signing key and a minimal policy.
+# Operator must review and run this using a Vault admin token or equivalent permissions.
+#
+VAULT=${VAULT:-vault} # vault CLI binary
+KEY_NAME=${1:-aegis-signing-key}
+MOUNT_PATH=${2:-transit}
+
+if ! command -v $VAULT >/dev/null 2>&1; then
+  echo "vault CLI not found in PATH. Install Vault CLI and re-run."
+  exit 2
+fi
+
+echo "Checking Vault connectivity..."
+$VAULT status >/dev/null
+
+echo "Enabling transit secrets engine (if not already enabled) at path: $MOUNT_PATH"
+if ! $VAULT secrets list -format=json | jq -r 'keys[]' | grep -q "^$MOUNT_PATH/"; then
+  $VAULT secrets enable -path="$MOUNT_PATH" transit
+else
+  echo "Transit engine already enabled at $MOUNT_PATH"
+fi
+
+echo "Creating transit key: $KEY_NAME (ECDSA P-256, exportable for verification convenience)"
+# NOTE: exportable=true allows exporting public key for verification; set to false in stricter environments.
+$VAULT write -f "$MOUNT_PATH/keys/$KEY_NAME" type="ecdsa-p256" exportable=true
+
+echo "Creating Vault policy 'aegis-transit-sign' that allows signing with the key (adjust path if needed)"
+cat > /tmp/aegis-transit-sign-policy.hcl <<'POL'
+path "transit/sign/*" {
+  capabilities = ["create", "update"]
+}
+path "transit/keys/*" {
+  capabilities = ["read", "list"]
+}
+POL
+
+$VAULT policy write aegis-transit-sign /tmp/aegis-transit-sign-policy.hcl
+rm -f /tmp/aegis-transit-sign-policy.hcl
+
+echo "Policy 'aegis-transit-sign' created. Attach this policy to the CI runner's token/service account."
+echo "Transit key $KEY_NAME created at $MOUNT_PATH/keys/$KEY_NAME (ECDSA P-256)."
+echo
+echo "Important security note: exportable=true is convenient for verification (public key), but may not be acceptable in your environment. Consider turning exportable=false and using Vault to verify signatures instead of exposing the public key."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/vault/vault_transit_sign.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# vault_transit_sign.sh
+# Signs an input file using Vault Transit and writes a base64 signature file suitable for verify-blob workflows.
+# This is a simple wrapper: operator must ensure VAULT_ADDR and VAULT_TOKEN (or other auth) are available in environment.
+#
+usage() {
+  cat <<EOF
+Usage: $0 --key <transit-key-name> --file <artifact> --out <signature-file>
+
+Requires:
+  - VAULT_ADDR and VAULT_TOKEN (or equivalent auth method) present in env
+  - vault CLI in PATH
+
+Example:
+  VAULT_ADDR=https://vault.example.com VAULT_TOKEN=... $0 --key aegis-signing-key --file ./artifact.tar.gz --out ./artifact.sig
+EOF
+  exit 1
+}
+
+KEY=""
+FILE=""
+OUT=""
+MOUNT=${VAULT_TRANSIT_MOUNT:-transit}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --key) KEY="$2"; shift 2;;
+    --file) FILE="$2"; shift 2;;
+    --out) OUT="$2"; shift 2;;
+    --mount) MOUNT="$2"; shift 2;;
+    -h|--help) usage;;
+    *) echo "Unknown arg: $1"; usage;;
+  esac
+done
+
+if [ -z "$KEY" ] || [ -z "$FILE" ] || [ -z "$OUT" ]; then
+  usage
+fi
+
+if ! command -v vault >/dev/null 2>&1; then
+  echo "vault CLI required in PATH"
+  exit 2
+fi
+
+if [ ! -f "$FILE" ]; then
+  echo "Artifact not found: $FILE"
+  exit 2
+fi
+
+INPUT_B64=$(base64 -w 0 "$FILE")
+
+echo "Signing $FILE using Vault Transit key: $KEY (mount: $MOUNT)"
+# Call Vault transit sign
+RESP=$(vault write -format=json "${MOUNT}/sign/${KEY}" input="$INPUT_B64" 2>/dev/null || true)
+
+if [ -z "$RESP" ]; then
+  echo "Vault transit sign failed. Ensure VAULT_ADDR and VAULT_TOKEN are set and policy permits transit/sign for ${KEY}."
+  exit 2
+fi
+
+# Extract signature field. Example format may be "vault:v1:BASE64"
+SIG_FULL=$(echo "$RESP" | jq -r '.data.signature')
+if [ -z "$SIG_FULL" ] || [ "$SIG_FULL" = "null" ]; then
+  echo "No signature returned from Vault: $RESP"
+  exit 2
+fi
+
+# Strip "vault:v1:" prefix if present
+SIG_B64="${SIG_FULL#vault:v1:}"
+
+echo "$SIG_B64" > "$OUT"
+echo "Wrote base64 signature to $OUT"
+
+echo
+echo "Notes:"
+echo "- If you exported the public key to pub.pem, you can verify the signature with cosign verify-blob --key pub.pem --signature $OUT $FILE"
+echo "- Adjust this wrapper if your Vault Transit returns different signature encodings in your Vault version."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/vault/export_public_key.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# export_public_key.sh
+# Attempt to export the public key for a transit key. Exporting may be disallowed depending on key settings.
+# Operator: review your Vault version's correct export endpoint and adjust commands below.
+#
+usage() {
+  cat <<EOF
+Usage: $0 --key <transit-key-name> --out <pub.pem> [--mount <mount-path>]
+Example:
+  VAULT_ADDR=https://vault.example.com VAULT_TOKEN=... $0 --key aegis-signing-key --out ./pub.pem
+EOF
+  exit 1
+}
+
+KEY=""
+OUT=""
+MOUNT=${VAULT_TRANSIT_MOUNT:-transit}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --key) KEY="$2"; shift 2;;
+    --out) OUT="$2"; shift 2;;
+    --mount) MOUNT="$2"; shift 2;;
+    -h|--help) usage;;
+    *) echo "Unknown arg: $1"; usage;;
+  esac
+done
+
+if [ -z "$KEY" ] || [ -z "$OUT" ]; then
+  usage
+fi
+
+if ! command -v vault >/dev/null 2>&1; then
+  echo "vault CLI required in PATH"
+  exit 2
+fi
+
+echo "Attempting to export public key for $KEY from mount $MOUNT"
+echo "NOTE: The exact export endpoint varies by Vault version. The command below is a conservative example; adapt as needed."
+
+# Conservative attempt: try the transit/export-signing-key endpoint (may vary)
+RESP=$(vault write -format=json "${MOUNT}/keys/${KEY}/export-signing-key" 2>/dev/null || true)
+if [ -n "$RESP" ]; then
+  PUB=$(echo "$RESP" | jq -r '.data.public_key' || true)
+fi
+
+if [ -z "${PUB:-}" ] || [ "$PUB" = "null" ]; then
+  echo "Automatic export attempt failed. Try vendor-specific export command, for example:"
+  echo "  vault read -format=json ${MOUNT}/export/signing-key/${KEY}  # or consult vault transit docs for your version"
+  echo "Or create a separate, exportable key with exportable=true when creating the key."
+  exit 2
+fi
+
+echo "$PUB" > "$OUT"
+echo "Public key written to $OUT (PEM format or provider-specific; inspect file to confirm)"
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/vault_transit_sign_example.yml
+name: Example: Sign artifact with Vault Transit (requires VAULT_ADDR & VAULT_TOKEN secrets)
+
+on:
+  workflow_dispatch:
+
+jobs:
+  sign-artifact:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Prepare artifact
+        run: |
+          mkdir -p artifact
+          echo "hello aegis" > artifact/test.txt
+          tar -czf artifact/test.tar.gz -C artifact test.txt
+          ls -l artifact
+
+      - name: Install Vault CLI
+        run: |
+          sudo apt-get update && sudo apt-get install -y jq
+          wget -qO- https://releases.hashicorp.com/vault/1.14.3/vault_1.14.3_linux_amd64.zip | bsdtar -xvf- -C /usr/local/bin
+
+      - name: Sign with Vault Transit
+        env:
+          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
+          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
+        run: |
+          chmod +x scripts/vault/vault_transit_sign.sh
+          ./scripts/vault/vault_transit_sign.sh --key aegis-signing-key --file artifact/test.tar.gz --out artifact/test.sig
+          echo "Signature (base64) saved to artifact/test.sig"
+
+      - name: Show signature
+        run: |
+          echo "Signature content:"
+          cat artifact/test.sig || true
+
+      - name: Optional: export public key (if allowed)
+        if: always()
+        env:
+          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
+          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
+        run: |
+          chmod +x scripts/vault/export_public_key.sh || true
+          ./scripts/vault/export_public_key.sh --key aegis-signing-key --out artifact/pub.pem || true
+          ls -l artifact || true
+
*** End Patch
*** End Patch
