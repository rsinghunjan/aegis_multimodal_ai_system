*** Begin Patch
*** Add File:security/safety_monitor/app.py
+from fastapi import FastAPI, HTTPException
+from pydantic import BaseModel
+import requests
+import os
+import logging
+
+app = FastAPI(title="Aegis Safety Monitor")
+logger = logging.getLogger("safety-monitor")
+logger.setLevel(logging.INFO)
+
+OPA_URL = os.environ.get("OPA_URL", "http://opa.aegis.svc:8181")
+OPA_POLICY_PATH = os.environ.get("OPA_POLICY_PATH", "safety/policy/allow")
+
+class DecisionContext(BaseModel):
+    actor_id: str
+    artifact_id: str
+    action: str
+    parameters: dict
+    timestamp: float
+
+class DecisionResult(BaseModel):
+    allowed: bool
+    reason: str = ""
+    advice: dict = {}
+
+@app.post("/evaluate", response_model=DecisionResult)
+def evaluate(dc: DecisionContext):
+    """
+    Evaluate a decision payload against OPA runtime policies.
+    Returns allowed: true/false and a reason.
+    """
+    input_payload = {"input": dc.dict()}
+    try:
+        url = f"{OPA_URL}/v1/data/{OPA_POLICY_PATH}"
+        resp = requests.post(url, json=input_payload, timeout=5)
+        resp.raise_for_status()
+        data = resp.json()
+        # Expected OPA policy returns {"result": {"allowed":bool, "reason": "...", "advice": {...}}}
+        result = data.get("result")
+        if result is None:
+            raise ValueError("OPA returned no result")
+        return DecisionResult(allowed=result.get("allowed", False),
+                              reason=result.get("reason", ""),
+                              advice=result.get("advice", {}))
+    except Exception as e:
+        logger.exception("OPA evaluation failed, falling back to conservative deny")
+        # Fallback: deny-safe mode
+        return DecisionResult(allowed=False, reason=f"OPA error: {str(e)}")
+
+@app.get("/health")
+def health():
+    return {"status": "ok"}
+
*** End Patch
*** Begin Patch
*** Add File:security/safety_monitor/requirements.txt
+fastapi
+uvicorn[standard]
+pydantic
+requests
+
*** End Patch
*** Begin Patch
*** Add File:security/safety_monitor/Dockerfile
+FROM python:3.10-slim
+WORKDIR /app
+COPY requirements.txt /app/requirements.txt
+RUN pip install --no-cache-dir -r /app/requirements.txt
+COPY app.py /app/app.py
+EXPOSE 8080
+CMD ["uvicorn","app:app","--host","0.0.0.0","--port","8080","--log-level","info"]
+
*** End Patch
*** Begin Patch
*** Add File:security/opa/policies.rego
+package safety.policy
+
+default allow = {"allowed": false, "reason": "default deny", "advice": {}}
+
+# Example: a conservative safety policy that uses envelope constraints.
+allow = {"allowed": true, "reason": "within envelope", "advice": advice} {
+  input.action == "command"
+  params := input.parameters
+  # Example constraints - operator should replace with mission-specific invariants
+  params.speed <= 250
+  params.altitude <= 10000
+  not dangerous(params)
+  advice := {"note": "action within allowed envelope"}
+}
+
+dangerous(params) {
+  params.altitude > 9000
+  params.speed > 220
+}
+
*** End Patch
*** Begin Patch
*** Add File:security/opa/deployment.yaml
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: opa-policy
+  namespace: aegis
+data:
+  policy.rego: |
+{{`}}package safety.policy
+
+default allow = {"allowed": false, "reason": "default deny", "advice": {}}
+
+allow = {"allowed": true, "reason": "within envelope", "advice": advice} {
+  input.action == "command"
+  params := input.parameters
+  params.speed <= 250
+  params.altitude <= 10000
+  not dangerous(params)
+  advice := {"note": "action within allowed envelope"}
+}
+
+dangerous(params) {
+  params.altitude > 9000
+  params.speed > 220
+}
+{{`}}
+
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: opa
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: opa
+  template:
+    metadata:
+      labels:
+        app: opa
+    spec:
+      containers:
+        - name: opa
+          image: openpolicyagent/opa:0.45.0
+          args:
+            - "run"
+            - "--server"
+            - "--set=decision_logs.console=true"
+            - "/policies/policy.rego"
+          ports:
+            - containerPort: 8181
+          volumeMounts:
+            - name: policy
+              mountPath: /policies
+      volumes:
+        - name: policy
+          configMap:
+            name: opa-policy
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: opa
+  namespace: aegis
+spec:
+  selector:
+    app: opa
+  ports:
+    - name: http
+      port: 8181
+      targetPort: 8181
+
*** End Patch
*** Begin Patch
*** Add File:security/safety_monitor/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: safety-monitor
+  namespace: aegis
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: safety-monitor
+  template:
+    metadata:
+      labels:
+        app: safety-monitor
+    spec:
+      containers:
+        - name: safety-monitor
+          image: registry.example.com/aegis/safety-monitor:latest
+          env:
+            - name: OPA_URL
+              value: "http://opa.aegis.svc:8181"
+            - name: OPA_POLICY_PATH
+              value: "safety/policy/allow"
+          ports:
+            - containerPort: 8080
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: safety-monitor
+  namespace: aegis
+spec:
+  selector:
+    app: safety-monitor
+  ports:
+    - protocol: TCP
+      port: 8080
+      targetPort: 8080
+
*** End Patch
*** Begin Patch
*** Add File:security/webhook/validatingwebhook.yaml
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-safety-webhook
+webhooks:
+  - name: safety.admission.aegis
+    admissionReviewVersions: ["v1"]
+    sideEffects: None
+    timeoutSeconds: 10
+    failurePolicy: Fail
+    clientConfig:
+      service:
+        name: safety-monitor
+        namespace: aegis
+        path: "/admit"
+        port: 8443
+      # caBundle: <replace-with-base64-ca-cert>
+    rules:
+      - apiGroups: [""]
+        apiVersions: ["v1"]
+        operations: ["CREATE", "UPDATE"]
+        resources: ["pods"]
+        scope: "Namespaced"
+    namespaceSelector:
+      matchLabels:
+        safety-enabled: "true"
+
+# NOTE:
+# - The webhook above calls safety-monitor /admit for admission decisions.
+# - Kubernetes requires the webhook server to use HTTPS with a cert that Kubernetes trusts.
+# - Operator must provision TLS certs for safety-monitor and fill caBundle above.
+
*** End Patch
*** Begin Patch
*** Add File:argo/workflows/digital_twin_sim.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Workflow
+metadata:
+  generateName: digital-twin-sim-
+  namespace: aegis
+spec:
+  entrypoint: dt-sim
+  templates:
+    - name: dt-sim
+      inputs:
+        parameters:
+          - name: scenarios
+            value: "100"
+      steps:
+        - - name: gen-scenarios
+            template: gen-scenarios
+            arguments:
+              parameters:
+                - name: count
+                  value: "{{inputs.parameters.scenarios}}"
+        - - name: run-sims
+            template: run-sims
+            arguments:
+              parameters:
+                - name: count
+                  value: "{{inputs.parameters.scenarios}}"
+        - - name: collect-sign
+            template: collect-sign
+
+    - name: gen-scenarios
+      inputs:
+        parameters:
+          - name: count
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - pip install numpy || true; python3 scripts/sim/generate_scenarios.py --count {{inputs.parameters.count}} --out /tmp/scenarios.json
+      outputs:
+        artifacts:
+          - name: scenarios
+            path: /tmp/scenarios.json
+
+    - name: run-sims
+      inputs:
+        parameters:
+          - name: count
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - pip install numpy || true; python3 scripts/sim/run_simulation.py --scenarios /tmp/scenarios.json --out /tmp/sim_results.json || true
+      outputs:
+        artifacts:
+          - name: sim-results
+            path: /tmp/sim_results.json
+
+    - name: collect-sign
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - python3 scripts/sim/collect_and_sign.py --sim /tmp/sim_results.json --out /tmp/dt_evidence.tgz || true; ls -l /tmp || true
+      outputs:
+        artifacts:
+          - name: evidence
+            path: /tmp/dt_evidence.tgz
+
*** End Patch
*** Begin Patch
*** Add File:scripts/sim/generate_scenarios.py
+#!/usr/bin/env python3
+import argparse, json, random
+
+def gen(count):
+    out = []
+    for i in range(int(count)):
+        s = {
+            "id": f"scen-{i}",
+            "initial_altitude": random.randint(0, 12000),
+            "initial_speed": random.randint(0, 400),
+            "wind": random.uniform(-20, 20),
+            "sensor_noise": random.uniform(0, 1)
+        }
+        out.append(s)
+    return out
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--count", default=10)
+    p.add_argument("--out", default="/tmp/scenarios.json")
+    args = p.parse_args()
+    s = gen(args.count)
+    open(args.out,"w").write(json.dumps(s))
+    print("Wrote", args.out)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:scripts/sim/run_simulation.py
+#!/usr/bin/env python3
+import argparse, json, random, time
+
+def run_one(s):
+    # simulate model decision and safety outcome (stub)
+    decision = {"action":"command","parameters":{"altitude": s["initial_altitude"] + random.randint(-50,50),"speed": s["initial_speed"] + random.randint(-20,20)}}
+    # safety monitor check simulated locally: mark unsafe if altitude>10000 or speed>250
+    unsafe = decision["parameters"]["altitude"] > 10000 or decision["parameters"]["speed"] > 250
+    return {"id": s["id"], "decision": decision, "unsafe": unsafe, "metadata": {"sim_time": time.time()}}
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--scenarios", required=False)
+    p.add_argument("--out", default="/tmp/sim_results.json")
+    args = p.parse_args()
+    if args.scenarios:
+        s = json.load(open(args.scenarios))
+    else:
+        s = []
+    results = []
+    for scen in s:
+        results.append(run_one(scen))
+    open(args.out,"w").write(json.dumps(results))
+    print("Wrote", args.out)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:scripts/sim/collect_and_sign.py
+#!/usr/bin/env python3
+import argparse, json, subprocess, os, tempfile
+
+def bundle(sim_path, out):
+    tmp = tempfile.mkdtemp()
+    subprocess.run(["cp", sim_path, os.path.join(tmp,"sim_results.json")], check=True)
+    tar = out
+    subprocess.run(["tar","czf",tar,"-C",tmp,"."], check=True)
+    return tar
+
+def sign(tar, out):
+    # try cosign KMS if configured
+    kms = os.environ.get("COSIGN_KMS_KEY_ARN")
+    if kms:
+        subprocess.run(["cosign","sign","--key",f"awskms://{kms}", tar], check=False)
+    # upload to s3 if EVIDENCE_BUCKET set
+    bucket = os.environ.get("EVIDENCE_BUCKET")
+    if bucket:
+        subprocess.run(["aws","s3","cp", tar, f"s3://{bucket}/digital-twin/"], check=False)
+    open(out,"w").write(json.dumps({"bundle": tar, "signed": bool(kms)}))
+
+def main():
+    import argparse
+    p = argparse.ArgumentParser()
+    p.add_argument("--sim", required=True)
+    p.add_argument("--out", default="/tmp/dt_evidence.tgz")
+    args = p.parse_args()
+    tar = bundle(args.sim, args.out)
+    sign(tar, args.out + ".meta.json")
+    print("Created evidence", tar)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:shadow/model/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: model-serving
+  namespace: aegis
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: model-serving
+  template:
+    metadata:
+      labels:
+        app: model-serving
+    spec:
+      containers:
+        - name: model
+          image: registry.example.com/aegis/model-serving:latest
+          env:
+            - name: SHADOW_MODE
+              value: "true"  # model will emit decisions to shadow endpoint and not actuate
+            - name: SAFETY_MONITOR_URL
+              value: "http://safety-monitor.aegis.svc:8080/evaluate"
+          ports:
+            - containerPort: 8081
+
*** End Patch
*** Begin Patch
*** Add File:shadow/offpolicy/evaluator.py
+#!/usr/bin/env python3
+"""
+Off-policy evaluator: compare model decisions vs operator decisions and emit basic metrics.
+Input: JSON lines file with {"model_decision": {...}, "operator_decision": {...}, "timestamp": ...}
+Output: metrics JSON
+"""
+import argparse, json
+
+def score_pair(m, o):
+    # simple scoring: equality of action and closeness of numeric params
+    if m["action"] != o["action"]:
