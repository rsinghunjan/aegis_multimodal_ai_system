*** Begin Patch
*** Add File:infra/terraform/full_infra.tf
+terraform {
+  required_version = ">= 1.0.0"
+}
+
+provider "aws" {
+  region = var.aws_region
+}
+
+variable "aws_region" {
+  type    = string
+  default = "us-west-2"
+}
+
+variable "secret_prefix" {
+  type    = string
+  default = "aegis"
+}
+
+variable "evidence_bucket" {
+  type    = string
+  default = "aegis-evidence-bucket"
+}
+
+resource "aws_kms_key" "cosign" {
+  description             = "KMS key for cosign signing in Aegis"
+  deletion_window_in_days = 30
+  enable_key_rotation     = true
+}
+
+resource "aws_kms_alias" "cosign_alias" {
+  name          = "alias/${var.secret_prefix}-cosign"
+  target_key_id = aws_kms_key.cosign.key_id
+}
+
+resource "aws_secretsmanager_secret" "cosign" {
+  name = "${var.secret_prefix}/cosign"
+}
+
+resource "aws_secretsmanager_secret_version" "cosign_value" {
+  secret_id     = aws_secretsmanager_secret.cosign.id
+  secret_string = jsonencode({ "kms_arn" = aws_kms_key.cosign.arn })
+}
+
+resource "aws_s3_bucket" "evidence" {
+  bucket = var.evidence_bucket
+  acl    = "private"
+  versioning {
+    enabled = true
+  }
+  lifecycle_rule {
+    id      = "audit-archive"
+    enabled = true
+    prefix  = "audit/"
+    transition {
+      days          = 30
+      storage_class = "STANDARD_IA"
+    }
+    expiration {
+      days = 365
+    }
+  }
+  server_side_encryption_configuration {
+    rule {
+      apply_server_side_encryption_by_default {
+        kms_master_key_id = aws_kms_key.cosign.arn
+        sse_algorithm     = "aws:kms"
+      }
+    }
+  }
+}
+
+resource "aws_iam_policy" "ci_cosign_policy" {
+  name = "${var.secret_prefix}-ci-cosign-policy"
+  policy = jsonencode({
+    Version = "2012-10-17"
+    Statement = [
+      {
+        Action = [
+          "kms:Sign",
+          "kms:Verify",
+          "kms:DescribeKey",
+          "kms:Encrypt",
+          "kms:Decrypt",
+          "kms:GenerateDataKey"
+        ]
+        Effect = "Allow"
+        Resource = aws_kms_key.cosign.arn
+      },
+      {
+        Action = [
+          "s3:PutObject",
+          "s3:GetObject",
+          "s3:ListBucket"
+        ]
+        Effect = "Allow"
+        Resource = [
+          aws_s3_bucket.evidence.arn,
+          "${aws_s3_bucket.evidence.arn}/*"
+        ]
+      }
+    ]
+  })
+}
+
+output "cosign_kms_arn" {
+  value = aws_kms_key.cosign.arn
+}
+
+output "evidence_bucket" {
+  value = aws_s3_bucket.evidence.bucket
+}
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/full_release_and_deploy.yml
+name: Full Release: Build -> Sign -> Rekor -> Deploy -> Gatekeeper Cutover
+
+on:
+  workflow_dispatch:
+
+env:
+  REGISTRY: ghcr.io/${{ github.repository_owner }}
+
+jobs:
+  build-sign-publish:
+    runs-on: ubuntu-latest
+    outputs:
+      image_tag: ${{ steps.set.outputs.image_tag }}
+    steps:
+      - uses: actions/checkout@v4
+      - name: Build images
+        run: |
+          IMAGE_TAG=${GITHUB_SHA}
+          docker build -t $REGISTRY/aegis-mcp:$IMAGE_TAG mcp/api
+          docker build -t $REGISTRY/aegis-mcp-operator:$IMAGE_TAG mcp/operator
+          docker build -t $REGISTRY/aegis-cosign-admission:$IMAGE_TAG security/cosign-admission
+          echo "::set-output name=image_tag::$IMAGE_TAG"
+        id: set
+      - name: Push images
+        run: |
+          IMAGE_TAG=${GITHUB_SHA}
+          docker push $REGISTRY/aegis-mcp:$IMAGE_TAG
+          docker push $REGISTRY/aegis-mcp-operator:$IMAGE_TAG
+          docker push $REGISTRY/aegis-cosign-admission:$IMAGE_TAG
+      - name: Install cosign & rekor-cli
+        run: |
+          curl -sSL -o /usr/local/bin/cosign https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
+          chmod +x /usr/local/bin/cosign
+          curl -sSL -o /usr/local/bin/rekor-cli https://github.com/sigstore/rekor/releases/latest/download/rekor-cli_linux_amd64
+          chmod +x /usr/local/bin/rekor-cli
+      - name: Sign images with cosign (KMS) and verify Rekor
+        env:
+          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          IMAGE_TAG=${GITHUB_SHA}
+          set -euo pipefail
+          IMAGES=(
+            "$REGISTRY/aegis-mcp:$IMAGE_TAG"
+            "$REGISTRY/aegis-mcp-operator:$IMAGE_TAG"
+            "$REGISTRY/aegis-cosign-admission:$IMAGE_TAG"
+          )
+          for IMG in "${IMAGES[@]}"; do
+            cosign sign --key "$COSIGN_KEY" "$IMG"
+            cosign verify --key "$COSIGN_KEY" "$IMG"
+          done
+          # verify Rekor connectivity (cosign posts to Rekor when REKOR_SERVER env is configured)
+          if [ -z "${REKOR_URL:-}" ]; then
+            echo "REKOR_URL not configured; failing"
+            exit 1
+          fi
+      - name: Save image tag
+        run: echo "image_tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT
+
+  deploy-staging:
+    needs: build-sign-publish
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup kubectl
+        uses: azure/setup-kubectl@v3
+        with:
+          version: '1.27.3'
+      - name: Configure Kubeconfig
+        run: |
+          echo "${{ secrets.KUBECONFIG_STAGING }}" > kubeconfig
+          export KUBECONFIG=$(pwd)/kubeconfig
+          kubectl config use-context ${{ secrets.STAGING_KUBE_CONTEXT }}
+      - name: Apply ExternalSecrets
+        run: |
+          kubectl apply -f infra/secrets/externalsecret_app_secrets.yaml
+          kubectl apply -f infra/secrets/externalsecret_cosign_kms.yaml
+      - name: Deploy images to staging
+        run: |
+          IMG_TAG=${{ needs.build-sign-publish.outputs.image_tag }}
+          sed "s|ghcr.io/yourorg/aegis-mcp:latest|$REGISTRY/aegis-mcp:$IMG_TAG|" mcp/manifests/mcp-deployment.yaml | kubectl apply -f -
+          sed "s|ghcr.io/yourorg/aegis-mcp-operator:latest|$REGISTRY/aegis-mcp-operator:$IMG_TAG|" mcp/manifests/operator-deployment.yaml | kubectl apply -f -
+          sed "s|ghcr.io/yourorg/aegis-cosign-admission:latest|$REGISTRY/aegis-cosign-admission:$IMG_TAG|" security/cosign-admission/deployment.yaml | kubectl apply -f -
+      - name: Create ValidatingWebhookConfiguration (caBundle from cert-manager)
+        run: |
+          python3 security/validatingwebhook/create_validatingwebhook.py --namespace security --secret cosign-admission-tls --service cosign-admission
+      - name: Apply Gatekeeper templates (staging dry-run)
+        run: |
+          kubectl apply -f devsecops/gatekeeper/constraint_require_signed_images.yaml
+          kubectl apply -f devsecops/gatekeeper/constraint_require_modelcard_signed.yaml
+          # Create Constraint instances in dry-run mode manually (operators must set enforcementAction: dryrun)
+
+  run-validations:
+    needs: deploy-staging
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Run staging validation suite
+        env:
+          EVIDENCE_BUCKET: ${{ secrets.EVIDENCE_BUCKET }}
+          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
+        run: |
+          bash scripts/run_validations.sh || true
+      - name: Publish results artifact
+        uses: actions/upload-artifact@v4
+        with:
+          name: staging-validation
+          path: ./validation-results || true
+
*** End Patch
*** Begin Patch
*** Add File:security/validatingwebhook/validatingwebhook.yaml
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-cosign-admission
+webhooks:
+  - name: cosign.admission.aegis
+    clientConfig:
+      service:
+        name: cosign-admission
+        namespace: security
+        path: /validate
+      # caBundle must be populated from cert-manager secret (see security/validatingwebhook/create_validatingwebhook.py)
+      caBundle: REPLACE_WITH_BASE64_CA_BUNDLE
+    rules:
+      - apiGroups: ["apps"]
+        apiVersions: ["v1"]
+        operations: ["CREATE", "UPDATE"]
+        resources: ["deployments"]
+      - apiGroups: [""]
+        apiVersions: ["v1"]
+        operations: ["CREATE"]
+        resources: ["pods"]
+    failurePolicy: Fail
+    sideEffects: None
+    admissionReviewVersions: ["v1"]
+
*** End Patch
*** Begin Patch
*** Add File:devsecops/gatekeeper/constraints_prod.yaml
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: RequireSignedImages
+metadata:
+  name: require-signed-images-prod
+spec:
+  enforcementAction: "deny"
+  match:
+    namespaces:
+      - "aegis"
+
+---
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: RequireModelCardSigned
+metadata:
+  name: require-modelcard-signed-prod
+spec:
+  enforcementAction: "deny"
+  match:
+    namespaces:
+      - "aegis"
+
+---
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: RequireContextAndCardSigned
+metadata:
+  name: require-context-card-signed-prod
+spec:
+  enforcementAction: "deny"
+  match:
+    namespaces:
+      - "aegis"
+
*** End Patch
*** Begin Patch
*** Add File:registry/postgres/secret_db.yaml
+apiVersion: v1
+kind: Secret
+metadata:
+  name: registry-db-secret
+  namespace: aegis
+type: Opaque
+stringData:
+  DATABASE_URL: "postgresql://aegis:REPLACE_POSTGRES_PASSWORD@postgres.aegis.svc.cluster.local:5432/aegis_registry"
+
*** End Patch
*** Begin Patch
*** Add File:mcp_context/middleware/enforce_redaction.py
+#!/usr/bin/env python3
+"""
+Enforce redaction rules for inputs and provide helper to validate contexts before upload.
+This module integrates with MCPMiddleware to ensure no raw PII is inline in context JSON.
+"""
+from .redaction import redact_text, redact_and_upload_input
+import json
+
+PII_FIELDS = ["ssn", "email", "phone", "credit_card", "personal_identifiable_info"]
+
+def ensure_redacted_input(input_payload, run_id, bucket, kms_key_arn=None, region='us-west-2'):
+    """
+    If input_payload appears to contain PII or is larger than threshold, redact and upload to encrypted S3,
+    and return a pointer. Otherwise return None to allow inline short inputs.
+    """
+    as_text = input_payload if isinstance(input_payload, str) else json.dumps(input_payload)
+    # simple heuristic: if contains '@' or digits > 10 treat as PII and redact
+    if "@" in as_text or any(ch.isdigit() for ch in as_text[:30]):
+        ptr = redact_and_upload_input(as_text, bucket, run_id, kms_key_arn=kms_key_arn, region=region)
+        return ptr
+    if len(as_text) > 1024:
+        # large input -> upload pointer only
+        ptr = redact_and_upload_input(as_text, bucket, run_id, kms_key_arn=kms_key_arn, region=region)
+        return ptr
+    # else safe to inline (still redacted)
+    return redact_text(as_text)
+
*** End Patch
*** Begin Patch
*** Add File:registry/migrate/helm_postgres_instructions.md
+Postgres migration instructions (operator)
+
+1. Deploy Postgres (managed or Helm chart). Example:
+   helm repo add bitnami https://charts.bitnami.com/bitnami
+   helm upgrade --install postgres bitnami/postgresql -n aegis -f registry/postgres/values.yaml
+
+2. Create secret registry-db-secret with DATABASE_URL (see registry/postgres/secret_db.yaml).
+
+3. Build & push registry image with Postgres support (ensure code uses DATABASE_URL env).
+
+4. Run migration:
+   export DATABASE_URL=postgresql://aegis:password@postgres.aegis.svc.cluster.local:5432/aegis_registry
+   python registry/migrate/migrate_sqlite_to_postgres.py --sqlite /path/to/model_cards.db
+
*** End Patch
*** Begin Patch
*** Add File:security/s3/lifecycle_apply.sh
+#!/usr/bin/env bash
+set -euo pipefail
+BUCKET=${1:-}
+if [ -z "$BUCKET" ]; then
+  echo "Usage: $0 <bucket-name>"
+  exit 2
+fi
+aws s3api put-bucket-lifecycle-configuration --bucket "$BUCKET" --lifecycle-configuration file://infra/s3/lifecycle_policy.json
+echo "Lifecycle policy applied to $BUCKET"
+
*** End Patch
*** Begin Patch
*** Add File:security/iam/ci_role_policy_example.json
+{
+  "Version": "2012-10-17",
+  "Statement": [
+    {
+      "Sid": "AllowKMSUse",
+      "Effect": "Allow",
+      "Action": [
+        "kms:Sign",
+        "kms:GenerateDataKey*",
+        "kms:DescribeKey"
+      ],
+      "Resource": "REPLACE_COSIGN_KMS_ARN"
+    },
+    {
+      "Sid": "AllowS3Audit",
+      "Effect": "Allow",
+      "Action": [
+        "s3:PutObject",
+        "s3:GetObject",
+        "s3:ListBucket"
+      ],
+      "Resource": ["arn:aws:s3:::REPLACE_EVIDENCE_BUCKET", "arn:aws:s3:::REPLACE_EVIDENCE_BUCKET/*"]
+    }
+  ]
+}
+
*** End Patch
*** Begin Patch
*** Add File:mcp/verifier/nli_verifier_integration.md
+NLIVerifier integration notes
+
+1. The NLIVerifier (mcp/verifier/nli_verifier.py) is used by the Verifier service to perform stronger entailment checking.
+2. For CI gating, call the Verifier service endpoint /verify_run/<run_id> which uses NLI to validate claims against retrieved docs.
+3. Operators should select an appropriate NLI model given latency and cost constraints. Consider a small distilled NLI model for CI, and larger ensemble in offline audits.
+
*** End Patch
*** Begin Patch
*** Add File:dsar/README.md
+DSAR tooling
+
+Use dsar/dsar_tool.py to locate contexts referencing a subject hash and redact/delete them.
+
+Operator steps:
+ - Ensure MODEL_CONTEXT_REG_DB and EVIDENCE_BUCKET are accessible.
+ - Run: python dsar/dsar_tool.py --subject-hash <hash> --registry-url http://model-context-registry:8096 --s3-bucket <bucket> --action redact
+
*** End Patch
*** Begin Patch
*** Add File:infra/monitoring/pagerduty_playbooks.md
+PagerDuty & Alerting playbooks
+
+1. Define escalation policies in PagerDuty tied to Prometheus alert labels (severity: critical -> immediate, warning -> email).
+2. For AegisServiceDown or CarbonBudgetExceeded, page on-call SRE with runbook link and MCP run_context pointer.
+3. Include remediation steps in runbook and expected logs/artifacts to collect.
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/hardening_and_cutover.md
+# Hardening and Cutover Runbook
+
+Steps to get from staged dry-run to production fail-closed:
+1. Provision infra (Terraform): KMS, S3 evidence bucket, SecretsManager entries (cosign KMS ARN).
+2. Configure CI secrets: COSIGN_KEY (awskms ARN), REKOR_URL, EVIDENCE_BUCKET, MLFLOW_TRACKING_URI.
+3. Run .github/workflows/full_release_and_deploy.yml to build, sign and deploy to staging with Gatekeeper in dry-run.
+4. Validate staging with scripts/run_validations.sh and scale harnesses; collect artifacts.
+5. Apply ValidatingWebhookConfiguration (create_validatingwebhook.py) and verify it rejects unsigned test deployments.
+6. Flip Gatekeeper Constraint instances in devsecops/gatekeeper/constraints_prod.yaml to enforcementAction: deny for prod namespaces.
+7. Run smoke promotions and audit signoff. If issues, roll back by removing constraint enforcement or rotating keys.
+
*** End Patch
*** Begin Patch
*** Add File:tests/integration/test_cosign_and_rekor.py
+import os
+import subprocess
+
+def test_cosign_installed():
+    rc = subprocess.call(["which", "cosign"])
+    assert rc == 0, "cosign not installed in runner"
+
+def test_rekor_cli_installed():
+    rc = subprocess.call(["which", "rekor-cli"])
+    assert rc == 0, "rekor-cli not installed in runner"
+
*** End Patch
*** End Patch
