diff --git a/scripts/dgx/finish_dgx_enablement.sh b/scripts/dgx/finish_dgx_enablement.sh
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/scripts/dgx/finish_dgx_enablement.sh
@@ -0,0 +1,360 @@
+#!/usr/bin/env bash
+#
+# Finish DGX Cloud enablement for Aegis - orchestrator script
+#
+# This script runs the remaining "operational" steps to reach DGX production support:
+#  - verifies prerequisites and CI secrets
+#  - optionally builds/publishes & signs validated images
+#  - configures GPU Operator driver strategy (autoInstall on/off)
+#  - labels DGX nodes (or updates manifests nodeSelector)
+#  - runs NCCL tuning and applies tuned values to ConfigMap
+#  - ensures checkpoint PVC exists (fast storage) and deploys offloader CronJob
+#  - runs the production validation job & collects artifacts
+#  - optionally promotes the image if validation passes
+#
+# Requirements (local operator or CI runner):
+#  - kubectl, helm, docker (or skopeo), jq, yq (recommended), cosign, syft, trivy
+#  - scripts created earlier in the repo (nccl_tuning.sh, publish_sign_register_image.sh, etc.)
+#  - environment variables / secrets set (see docs/dgx/CI_and_SECRET_SETUP.md)
+#
+# WARNING: This script touches cluster & registry. Review steps & run in a controlled environment.
+#
+# Usage example (local / interactive):
+#   REGISTRY=ghcr.io/myorg TARGET=h100 IMAGE_TAG=aegis-deepspeed:h100-cuda12.1-pytorch2.2 \
+#   KUBECONFIG=./kubeconfigs/kubeconfig-dgx ./scripts/dgx/finish_dgx_enablement.sh --promote
+#
+set -euo pipefail
+
+# Configurable env & defaults
+REGISTRY="${REGISTRY:-}"
+TARGET="${TARGET:-h100}"           # h100 or a100
+IMAGE_TAG="${IMAGE_TAG:-}"        # e.g., aegis-deepspeed:h100-cuda12.1-pytorch2.2
+KUBECONFIG="${KUBECONFIG:-$HOME/.kube/config}"
+NAMESPACE="${NAMESPACE:-aegis-ml}"
+EXPECTED_GPU_OPERATOR_AUTOINSTALL="${EXPECTED_GPU_OPERATOR_AUTOINSTALL:-false}"
+PROMOTE="${PROMOTE:-false}"       # if true, attempt promotion after validation
+DECISION_LOG_URL="${DECISION_LOG_URL:-}"
+SELF_HOSTED_RUNNER="${SELF_HOSTED_RUNNER:-false}"
+
+print_help() {
+  cat <<EOF
+Usage: $0 [--build-image] [--label-nodes node1,node2] [--update-node-selector key=value]
+          [--gpu-operator-autoinstall true|false] [--promote] [--skip-sbom-scan]
+
+Environment variables used:
+  REGISTRY, TARGET, IMAGE_TAG, KUBECONFIG, NAMESPACE, DECISION_LOG_URL
+
+Examples:
+  REGISTRY=ghcr.io/org TARGET=h100 IMAGE_TAG=aegis-deepspeed:h100... \
+    KUBECONFIG=./kubeconfigs/kubeconfig-dgx ./scripts/dgx/finish_dgx_enablement.sh --build-image --label-nodes dgx-node-1,dgx-node-2 --promote
+
+EOF
+}
+
+# CLI args
+BUILD_IMAGE=false
+LABEL_NODES=""
+UPDATE_SELECTOR=""
+GPU_OPERATOR_AUTOINSTALL=""
+SKIP_SBOM_SCAN=false
+
+while [[ $# -gt 0 ]]; do
+  case $1 in
+    --build-image) BUILD_IMAGE=true; shift ;;
+    --label-nodes) LABEL_NODES="$2"; shift 2 ;;
+    --update-node-selector) UPDATE_SELECTOR="$2"; shift 2 ;;
+    --gpu-operator-autoinstall) GPU_OPERATOR_AUTOINSTALL="$2"; shift 2 ;;
+    --promote) PROMOTE=true; shift ;;
+    --skip-sbom-scan) SKIP_SBOM_SCAN=true; shift ;;
+    -h|--help) print_help; exit 0 ;;
+    *) echo "Unknown arg: $1"; print_help; exit 2 ;;
+  esac
+done
+
+if [[ -z "$IMAGE_TAG" && "$BUILD_IMAGE" == "true" ]]; then
+  echo "ERROR: IMAGE_TAG must be set when --build-image is requested"
+  exit 2
+fi
+
+if [[ -z "$REGISTRY" && "$BUILD_IMAGE" == "true" ]]; then
+  echo "ERROR: REGISTRY must be set when --build-image is requested"
+  exit 2
+fi
+
+if [[ ! -f "$KUBECONFIG" ]]; then
+  echo "ERROR: kubeconfig not found at $KUBECONFIG"
+  exit 2
+fi
+
+export KUBECONFIG
+
+echo "=== Aegis DGX finish enablement orchestrator ==="
+echo "Namespace: $NAMESPACE"
+echo "Kubeconfig: $KUBECONFIG"
+echo "Registry: ${REGISTRY:-<not set>}"
+echo "Image tag: ${IMAGE_TAG:-<not set>}"
+echo "Build image requested: $BUILD_IMAGE"
+echo "Label nodes: $LABEL_NODES"
+echo "Update node selector: $UPDATE_SELECTOR"
+echo "GPU Operator autoInstall override: ${GPU_OPERATOR_AUTOINSTALL:-<none>}"
+echo "Promote after validation: $PROMOTE"
+echo
+
+check_binary() {
+  if ! command -v "$1" >/dev/null 2>&1; then
+    echo "WARNING: $1 not found in PATH; some steps may skip or fail."
+  fi
+}
+
+for b in kubectl helm docker cosign syft trivy jq yq; do
+  check_binary "$b"
+done
+
+# Step 1: optionally build/publish & sign image
+if [[ "$BUILD_IMAGE" == "true" ]]; then
+  echo "==> Building, scanning, signing and registering image: $IMAGE_TAG"
+  export REGISTRY TARGET IMAGE_TAG
+  # reuse earlier script (publish_sign_register_image.sh)
+  if [[ -x "./scripts/dgx/publish_sign_register_image.sh" ]]; then
+    if [[ "$SKIP_SBOM_SCAN" == "true" ]]; then
+      echo "Skipping SBOM/scan per flag (not recommended for prod)"
+      REGISTRY="$REGISTRY" TARGET="$TARGET" IMAGE_TAG="$IMAGE_TAG" ./scripts/dgx/publish_sign_register_image.sh
+    else
+      REGISTRY="$REGISTRY" TARGET="$TARGET" IMAGE_TAG="$IMAGE_TAG" ./scripts/dgx/publish_sign_register_image.sh
+    fi
+  else
+    echo "Missing scripts/dgx/publish_sign_register_image.sh; cannot build image" ; exit 3
+  fi
+fi
+
+# Step 2: Label nodes OR update manifests nodeSelector
+if [[ -n "$LABEL_NODES" ]]; then
+  echo "==> Labeling nodes: $LABEL_NODES"
+  ./scripts/dgx/label_dgx_nodes.sh --nodes "$LABEL_NODES" --label node.kubernetes.io/dgx=true
+elif [[ -n "$UPDATE_SELECTOR" ]]; then
+  echo "==> Updating manifests nodeSelector to: $UPDATE_SELECTOR"
+  ./scripts/dgx/label_dgx_nodes.sh --update-manifests --selector "$UPDATE_SELECTOR" --manifests-dir k8s/manifests
+else
+  echo "No node labeling requested; ensure nodes are labeled node.kubernetes.io/dgx=true or manifests adjusted."
+fi
+
+# Step 3: Decide GPU Operator driver handling
+if [[ -n "$GPU_OPERATOR_AUTOINSTALL" ]]; then
+  echo "==> Applying GPU Operator values (autoInstall=$GPU_OPERATOR_AUTOINSTALL)"
+  if [[ "$GPU_OPERATOR_AUTOINSTALL" == "false" ]]; then
+    # use the no-driver values file if present
+    VAL_FILE="k8s/manifests/dgx/gpu-operator-values-no-driver.yaml"
+  else
+    VAL_FILE="k8s/manifests/dgx/gpu-operator-values.yaml"
+  fi
+  if [[ -f "$VAL_FILE" ]]; then
+    helm repo add nvidia https://nvidia.github.io/gpu-operator || true
+    helm repo update || true
+    helm upgrade --install --namespace gpu-operator gpu-operator nvidia/gpu-operator -f "$VAL_FILE"
+  else
+    echo "GPU operator values $VAL_FILE not found; please create or copy into k8s/manifests/dgx/" ; exit 4
+  fi
+else
+  echo "GPU Operator autoInstall not overridden here; ensure you installed GPU operator per docs/dgx/README.md"
+fi
+
+# Wait for nodes & device plugin readiness (basic check)
+echo "Waiting*
î€€
