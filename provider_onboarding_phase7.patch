*** Begin Patch
*** Add File: scripts/create_github_issue_request_creds.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Create a GitHub issue requesting provider sandbox credentials or a secure self-hosted runner.
+# Requires `gh` CLI authenticated (gh auth login) and repository context.
+#
+# Usage:
+#   export REPO="yourorg/yourrepo"
+#   ./scripts/create_github_issue_request_creds.sh --provider ibm --type creds --assignee ops-team
+
+REPO="${REPO:-}"
+PROVIDER=""
+TYPE="creds"   # creds | runner
+ASSIGNEE=""
+TITLE=""
+BODY=""
+
+usage() {
+  cat <<EOF
+Usage: $0 --provider <ibm|braket> [--type creds|runner] [--assignee <github-user-or-team>] [--repo owner/repo]
+
+Creates a GitHub Issue asking for provider sandbox credentials or a secure self-hosted runner.
+Requires the GitHub CLI (gh) and that you are authenticated with permission to create issues.
+EOF
+}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --provider) PROVIDER="$2"; shift 2;;
+    --type) TYPE="$2"; shift 2;;
+    --assignee) ASSIGNEE="$2"; shift 2;;
+    --repo) REPO="$2"; shift 2;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg: $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$PROVIDER" ]; then
+  echo "provider is required" >&2
+  usage
+  exit 2
+fi
+if [ -z "$REPO" ]; then
+  echo "REPO not set; set env REPO=owner/repo or pass --repo" >&2
+  exit 2
+fi
+
+if [ "$TYPE" = "creds" ]; then
+  TITLE="Request: sandbox credentials for provider ${PROVIDER}"
+  BODY=$(cat <<-BODY
+Please provide sandbox credentials for the ${PROVIDER} quantum provider (for onboarding and verification).
+
+Preferred approach (recommended):
+- Write provider secrets to Vault at path: secret/data/quantum/providers/${PROVIDER}
+  - Example keys for IBM: { "ibm_token": "..." , "url": "https://..." }
+  - Example keys for Braket: { "aws_access_key_id": "...", "aws_secret_access_key": "...", "region": "us-west-1", "s3_bucket": "..." }
+
+Alternative (operator-assisted):
+- Encrypt credentials and hand off to operator using the repo helper:
+  ./credentials/encrypt_credentials.sh --in provider_${PROVIDER}.json --pubkey operator_pub.pem --out-dir ./secure_creds
+
+We will run the provider E2E verifier and stress tests; please provide limited-scope sandbox credentials to avoid billing.
+
+Deliverable:
+- Vault secret created OR encrypted credential bundle delivered out-of-band.
+
+Security note: Do NOT commit credentials to git. Use Vault or the encryptor tool.
+BODY
+)
+else
+  TITLE="Request: secure self-hosted runner for provider E2E (label: self-hosted,qpu-adjacent)"
+  BODY=$(cat <<-BODY
+Please provision a secure, isolated self-hosted GitHub Actions runner for provider end-to-end verification with labels:
+  - self-hosted
+  - qpu-adjacent
+
+Runner requirements:
+- Python 3.11, kubectl, docker (optional)
+- Network access to provider endpoints (IBM/Braket)
+- Signing private key stored at /opt/aegis/secrets/signing_key.pem (chmod 600), or Rekor configured
+- Kubeconfig available to runner (if running K8s job)
+
+We will run provider_endtoend_verify.py and provider_stress_test.py on this runner and adapt provider adapters as needed.
+
+Deliverable:
+- Runner registered in GitHub with labels above and documentation on how to access it.
+BODY
+)
+fi
+
+if [ -n "$ASSIGNEE" ]; then
+  gh issue create --repo "$REPO" --title "$TITLE" --body "$BODY" --assignee "$ASSIGNEE"
+else
+  gh issue create --repo "$REPO" --title "$TITLE" --body "$BODY"
+fi
+
+echo "Created GitHub issue in $REPO (or attempted to)."
+
*** End Patch
*** Begin Patch
*** Add File: scripts/send_slack_request.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Send a Slack notification (webhook) requesting provider credentials or runner.
+#
+# Usage:
+#  SLACK_WEBHOOK=https://hooks.slack.com/services/... ./scripts/send_slack_request.sh --provider ibm --type creds --channel "#ops"
+
+SLACK_WEBHOOK="${SLACK_WEBHOOK:-}"
+PROVIDER=""
+TYPE="creds"
+CHANNEL=""
+MESSAGE=""
+
+usage() {
+  cat <<EOF
+Usage: $0 --provider <ibm|braket> [--type creds|runner] [--channel <slack-channel>]
+
+Requires SLACK_WEBHOOK env var.
+EOF
+}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --provider) PROVIDER="$2"; shift 2;;
+    --type) TYPE="$2"; shift 2;;
+    --channel) CHANNEL="$2"; shift 2;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg: $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$SLACK_WEBHOOK" ]; then
+  echo "SLACK_WEBHOOK is required" >&2
+  exit 2
+fi
+if [ -z "$PROVIDER" ]; then
+  echo "provider is required" >&2
+  usage
+  exit 2
+fi
+
+if [ "$TYPE" = "creds" ]; then
+  MESSAGE="Requesting sandbox credentials for provider *${PROVIDER}*.\nPreferred: Vault secret at secret/data/quantum/providers/${PROVIDER}.\nAlternative: encrypted bundle via repo tool.\nPlease coordinate with the quantum platform team."
+else
+  MESSAGE="Requesting a secure self-hosted runner with labels *self-hosted,qpu-adjacent* for provider E2E verification.\nRunner should have Python3, kubectl and secure network access to provider endpoints."
+fi
+
+PAYLOAD=$(jq -n --arg text "$MESSAGE" --arg channel "$CHANNEL" '{text:$text, channel:$channel}')
+curl -sS -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK" >/dev/null
+echo "Slack notification sent."
+
*** End Patch
*** Begin Patch
*** Add File: scripts/run_vault_terraform_and_create_secret.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run Terraform under terraform/vault/ to create AppRole & policy, then produce k8s secret via helper.
+#
+# Usage:
+#   VAULT_TOKEN=s.xxxxx ./scripts/run_vault_terraform_and_create_secret.sh --vault-addr https://vault.example.com --tf-dir terraform/vault --out tf_out.json --deploy-rotator
+
+TF_DIR="${1:-terraform/vault}"
+VAULT_ADDR=""
+OUT_JSON="${2:-tf_out.json}"
+DEPLOY_ROTATOR="false"
+NAMESPACE="aegis"
+
+usage() {
+  cat <<EOF
+Usage: $0 [--tf-dir <path>] --vault-addr <addr> [--out <tf_out.json>] [--deploy-rotator]
+
+Environment:
+  VAULT_TOKEN must be set (admin token used by operator to run Terraform)
+EOF
+}
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --tf-dir) TF_DIR="$2"; shift 2;;
+    --vault-addr) VAULT_ADDR="$2"; shift 2;;
+    --out) OUT_JSON="$2"; shift 2;;
+    --deploy-rotator) DEPLOY_ROTATOR="true"; shift;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$VAULT_ADDR" ]; then
+  echo "--vault-addr is required" >&2
+  usage
+  exit 2
+fi
+if [ -z "${VAULT_TOKEN:-}" ]; then
+  echo "VAULT_TOKEN env var must be set (admin token)" >&2
+  exit 2
+fi
+
+pushd "$TF_DIR" >/dev/null
+export VAULT_ADDR
+export VAULT_TOKEN
+
+terraform init -input=false
+terraform plan -out=tfplan -input=false
+terraform apply -input=false tfplan
+
+terraform output -json > "../${OUT_JSON}"
+popd >/dev/null
+
+echo "Terraform apply completed; outputs captured to ${OUT_JSON}"
+
+# Create k8s secret from outputs
+./terraform/vault/create_k8s_secret_from_tf_outputs.sh "${OUT_JSON}" "${NAMESPACE}"
+
+if [ "$DEPLOY_ROTATOR" = "true" ]; then
+  kubectl apply -f k8s/cronjobs/vault-token-rotator-cronjob.yaml
+  echo "Vault token rotator CronJob deployed."
+fi
+
+echo "Done."
+
*** End Patch
*** Begin Patch
*** Add File: scripts/sync_argo_and_run_staging_tests.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Sync Argo apps into a staging namespace and run test wrappers.
+# This script uses argocd CLI if available; otherwise relies on ArgoCD auto-sync.
+#
+# Usage:
+#   ./scripts/sync_argo_and_run_staging_tests.sh --results-dir ./provider_staging_results --wait 300
+
+RESULTS_DIR="./provider_staging_results"
+WAIT_SEC=300
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --results-dir) RESULTS_DIR="$2"; shift 2;;
+    --wait) WAIT_SEC="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 [--results-dir ./provider_staging_results] [--wait 300]"; exit 0;;
+    *) echo "Unknown arg $1"; exit 2;;
+  esac
+done
+
+echo "Syncing Argo apps (argo/apps/*.yaml)..."
+for f in argo/apps/*.yaml; do
+  appname="$(basename "$f" .yaml)"
+  echo "Processing app $appname"
+  if command -v argocd >/dev/null 2>&1; then
+    echo "Syncing via argocd CLI: $appname"
+    argocd app sync "$appname" || echo "argocd sync failed for $appname"
+    argocd app wait "$appname" --health --timeout "${WAIT_SEC}s" || echo "wait timed out for $appname"
+  else
+    echo "argocd CLI not found: ensure auto-sync or use ArgoCD UI to sync $appname"
+  fi
+done
+
+echo "Allowing ${WAIT_SEC}s for resources to settle..."
+sleep "$WAIT_SEC"
+
+echo "Running Redis failover test..."
+python3 scripts/redis_failover_test.py || echo "Redis failover test failed; see logs"
+
+echo "Running provider stress test (if self-hosted runner / creds available)..."
+python3 scripts/provider_stress_test.py --provider ibm --count 20 --concurrency 4 || echo "Provider stress test had failures"
+
+echo "Gathering logs and results into ${RESULTS_DIR}..."
+mkdir -p "${RESULTS_DIR}"
+kubectl get pods -n aegis -l app=redis -o wide > "${RESULTS_DIR}/redis_pods.txt" || true
+kubectl get pods -n aegis -l app=quantum-controller -o wide > "${RESULTS_DIR}/controller_pods.txt" || true
+kubectl logs -n aegis -l app=quantum-controller --tail=200 > "${RESULTS_DIR}/controller_logs.txt" || true
+echo "Done. Results in ${RESULTS_DIR}"
+
*** End Patch
*** Begin Patch
*** Add File: docs/communication_templates/ask_vault_admin.md
+Subject: Vault: Please apply Terraform for Quantum AppRole & provide outputs
+
+Hi Vault Admins,
+
+Please run the Terraform in terraform/vault/ to create the `quantum-provider-read` policy and an AppRole for the quantum controller, then provide the outputs (approle_role_id and approle_secret_id) securely to the operator.
+
+Steps (recommended):
+1. cd terraform/vault
+2. terraform init
+3. terraform plan -out=tfplan
+4. terraform apply tfplan
+5. terraform output -json > tf_out.json
+
+Please deliver tf_out.json securely to the operator (do not commit to git). The operator will run:
+  ./terraform/vault/create_k8s_secret_from_tf_outputs.sh tf_out.json
+and optionally deploy the vault-token-rotator CronJob to exchange the AppRole for scoped runtime tokens.
+
+Security note: treat secret_id as sensitive (one-time or limited-use); prefer direct secure channels for delivery.
+
+Thank you!
+
*** End Patch
*** Begin Patch
*** Add File: docs/communication_templates/request_runner.md
+Subject: Request: secure self-hosted runner for quantum provider E2E (labels: self-hosted,qpu-adjacent)
+
+Please provision a secure self-hosted GitHub Actions runner with the following:
+- Labels: self-hosted, qpu-adjacent
+- Software: Python 3.11, kubectl, docker (optional)
+- Secure storage for signing key: /opt/aegis/secrets/signing_key.pem (chmod 600)
+- Network access to provider endpoints (IBM/Braket)
+
+We will run provider_endtoend_verify.py and provider_stress_test.py on the runner to validate adapters and produce signed artifacts + Rekor attestations.
+
+Provide the runner registration token or register the runner and share its name/labels in the response.
+
+Thank you!
+
*** End Patch
*** End Patch
