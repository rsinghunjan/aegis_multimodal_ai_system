*** Begin Patch
*** Add File: ci/release/cosign_rekor_sign_publish.yml
+name: Sign manifest with Cosign (KMS/HSM) and publish to Rekor
+on:
+  workflow_dispatch:
+
+jobs:
+  sign-and-publish:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Install cosign and rekor-cli
+        run: |
+          curl -LO https://github.com/sigstore/cosign/releases/download/v1.13.0/cosign-linux-amd64
+          chmod +x cosign-linux-amd64
+          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
+          curl -LO https://github.com/sigstore/rekor-cli/releases/download/v0.15.0/rekor-cli_0.15.0_linux_amd64.tar.gz
+          tar xzf rekor-cli_0.15.0_linux_amd64.tar.gz
+          sudo mv rekor-cli /usr/local/bin/rekor-cli || true
+
+      - name: Prepare manifest
+        run: |
+          # manifest.json should exist in repo or be generated earlier in pipeline
+          ls -la manifest.json || (echo "manifest.json missing" && exit 1)
+
+      - name: Sign with Cosign using KMS or private key
+        env:
+          COSIGN_KMS_KEY: ${{ secrets.COSIGN_KMS_KEY }}
+          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
+        run: |
+          if [ -n "${COSIGN_KMS_KEY}" ]; then
+            echo "Signing manifest with KMS key ${COSIGN_KMS_KEY}"
+            cosign sign --key "${COSIGN_KMS_KEY}" manifest.json
+          else
+            echo "Using local cosign key from secrets"
+            echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
+            chmod 600 cosign.key
+            cosign sign --key cosign.key manifest.json
+          cosign verify manifest.json || true
+
+      - name: Submit to Rekor (via cosign integration)
+        env:
+          REKOR_SERVER: "https://rekor.sigstore.dev"
+        run: |
+          # cosign will normally submit the entry to Rekor automatically when signing.
+          # Verify there's a Rekor entry for the manifest digest.
+          DIGEST=$(sha256sum manifest.json | awk '{print $1}')
+          echo "Manifest digest: $DIGEST"
+          rekor-cli search hash "$DIGEST" || echo "No Rekor entry found yet"
+
+      - name: Output verification artifacts
+        run: |
+          cosign verify --key cosign.key manifest.json || true
+          rekor-cli search hash $(sha256sum manifest.json | awk '{print $1}') || true
+
*** End Patch
*** Begin Patch
*** Add File: scripts/cosign_sign_kms.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Sign a file with cosign. If COSIGN_KMS_KEY is provided, sign with KMS/HSM; otherwise use local key.
+FILE="${1:-manifest.json}"
+
+: "${FILE:?manifest file required as first arg}"
+
+if [ -n "${COSIGN_KMS_KEY:-}" ]; then
+  echo "Signing ${FILE} with KMS key ${COSIGN_KMS_KEY}"
+  cosign sign --key "${COSIGN_KMS_KEY}" "${FILE}"
+else
+  echo "Signing ${FILE} with local cosign key (COSIGN_PRIVATE_KEY must be set in env)"
+  if [ -z "${COSIGN_PRIVATE_KEY:-}" ]; then
+    echo "COSIGN_PRIVATE_KEY not set" >&2
+    exit 2
+  fi
+  echo "${COSIGN_PRIVATE_KEY}" > /tmp/cosign.key
+  chmod 600 /tmp/cosign.key
+  cosign sign --key /tmp/cosign.key "${FILE}"
+fi
+
+echo "Signed ${FILE}"
+
*** End Patch
*** Begin Patch
*** Add File: scripts/rekor_verify_submit.sh
+#!/usr/bin/env bash
+set -euo pipefail
+MANIFEST="${1:-manifest.json}"
+
+: "${MANIFEST:?manifest required}"
+
+DIGEST=$(sha256sum "${MANIFEST}" | awk '{print $1}')
+echo "manifest sha256: ${DIGEST}"
+echo "Searching Rekor for digest..."
+rekor-cli search hash "${DIGEST}" || (echo "No Rekor entry found for ${DIGEST}" && exit 1)
+echo "Found Rekor entry"
+
*** End Patch
*** Begin Patch
*** Add File: pki/k8s/vault-rotate-cronjob.yaml
+apiVersion: batch/v1
+kind: CronJob
+metadata:
+  name: aegis-vault-device-rotate
+  namespace: aegis
+spec:
+  schedule: "0 3 * * *"  # run daily at 03:00 UTC
+  jobTemplate:
+    spec:
+      template:
+        spec:
+          serviceAccountName: aegis-vault-operator
+          containers:
+            - name: rotate
+              image: aegis/vault-provision:latest
+              command: ["/bin/sh","-c","/provisioning/vault_rotate_device_certs.sh --role aegis-device-role --devices $(cat /etc/aegis/devices_list) --out-path secret/data/aegis/devices"]
+              env:
+                - name: VAULT_ADDR
+                  valueFrom:
+                    secretKeyRef:
+                      name: vault-addr
+                      key: addr
+                - name: VAULT_TOKEN
+                  valueFrom:
+                    secretKeyRef:
+                      name: vault-token
+                      key: token
+              volumeMounts:
+                - name: devices
+                  mountPath: /etc/aegis
+                  readOnly: true
+          restartPolicy: OnFailure
+          volumes:
+            - name: devices
+              configMap:
+                name: aegis-devices-config
+
*** End Patch
*** Begin Patch
*** Add File: pki/revocation/revoke_cert.py
+#!/usr/bin/env python3
+"""
+Revoke certificates issued by Vault PKI using serial number or certificate PEM.
+Usage:
+  python revoke_cert.py --serial <serial>
+  python revoke_cert.py --cert-file device_cert.pem
+"""
+import argparse
+import subprocess
+import json
+import sys
+
+def parse_args():
+    p = argparse.ArgumentParser()
+    p.add_argument("--serial", default=None)
+    p.add_argument("--cert-file", default=None)
+    return p.parse_args()
+
+def main():
+    args = parse_args()
+    if args.cert_file:
+        # extract serial using openssl
+        out = subprocess.check_output(["openssl", "x509", "-in", args.cert_file, "-serial", "-noout"])
+        serial = out.decode().strip().split("=")[-1]
+    elif args.serial:
+        serial = args.serial
+    else:
+        print("provide --serial or --cert-file", file=sys.stderr)
+        sys.exit(2)
+    # call vault revoke on the intermediate pki
+    try:
+        subprocess.check_call(["vault", "write", f"pki_int/revoke", f"serial_number={serial}"])
+        print("revoked", serial)
+    except subprocess.CalledProcessError as e:
+        print("revoke failed", e)
+        sys.exit(1)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File: k8s/fleet/controller/prod_rbac.yaml
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: aegis-fleet-controller
+  namespace: aegis
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: aegis-fleet-controller
+rules:
+  - apiGroups: [""]
+    resources: ["pods", "services", "endpoints", "configmaps", "secrets"]
+    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
+  - apiGroups: ["coordination.k8s.io"]
+    resources: ["leases"]
+    verbs: ["get", "create", "update", "delete", "patch"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: aegis-fleet-controller-binding
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: aegis-fleet-controller
+subjects:
+  - kind: ServiceAccount
+    name: aegis-fleet-controller
+    namespace: aegis
+
*** End Patch
*** Begin Patch
*** Add File: k8s/fleet/controller/hpa_pdb.yaml
+apiVersion: autoscaling/v2
+kind: HorizontalPodAutoscaler
+metadata:
+  name: aegis-fleet-controller
+  namespace: aegis
+spec:
+  scaleTargetRef:
+    apiVersion: apps/v1
+    kind: Deployment
+    name: aegis-fleet-controller
+  minReplicas: 3
+  maxReplicas: 12
+  metrics:
+    - type: Resource
+      resource:
+        name: cpu
+        target:
+          type: Utilization
+          averageUtilization: 50
+
+---
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: aegis-fleet-controller-pdb
+  namespace: aegis
+spec:
+  minAvailable: 2
+  selector:
+    matchLabels:
+      app: aegis-fleet-controller
+
*** End Patch
*** Begin Patch
*** Add File: k8s/fleet/controller/lease_leader.yaml
+apiVersion: coordination.k8s.io/v1
+kind: Lease
+metadata:
+  name: aegis-fleet-controller-leader
+  namespace: aegis
+spec:
+  holderIdentity: ""
+  leaseDurationSeconds: 30
+
*** End Patch
*** Begin Patch
*** Add File: k8s/security/pod-security-constraints.yaml
+apiVersion: policy/v1
+kind: PodSecurityPolicy
+metadata:
+  name: aegis-restricted
+spec:
+  privileged: false
+  allowPrivilegeEscalation: false
+  requiredDropCapabilities:
+    - ALL
+  volumes:
+    - 'configMap'
+    - 'emptyDir'
+    - 'persistentVolumeClaim'
+  hostNetwork: false
+  hostPID: false
+  hostIPC: false
+  runAsUser:
+    rule: MustRunAsNonRoot
+  seLinux:
+    rule: RunAsAny
+  fsGroup:
+    rule: MustRunAs
+  readOnlyRootFilesystem: false
+
*** End Patch
*** Begin Patch
*** Add File: policies/opa/require_signed_images.rego
+package aegis.policies.images
+
+default allow = false
+
+# Enforce that Kubernetes Pod spec annotations include cosign signature metadata
+# Input: { "pod": <k8s pod json> }
+allow {
+  pod := input.pod
+  annotations := pod.metadata.annotations
+  annotations["aegis.cosign.signed"] == "true"
+}
+
*** End Patch
*** Begin Patch
*** Add File: hardware/runner/provision_many_runners.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Provision N self-hosted runners on multiple devices.
+# Usage: ./provision_many_runners.sh --repo owner/repo --token-file tokens.txt
+REPO=""
+TOKENS_FILE=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --repo) REPO="$2"; shift 2;;
+    --token-file) TOKENS_FILE="$2"; shift 2;;
+    *) echo "usage: --repo owner/repo --token-file tokens.txt" && exit 2;;
+  esac
+done
+
+: "${REPO:?}"
+: "${TOKENS_FILE:?}"
+
+i=0
+while read -r TOKEN; do
+  NAME="runner-$(printf '%03d' "$i")"
+  ssh root@runner-device-${i} "bash -s" < <(cat <<'SSH'
+set -euo pipefail
+ARCH=$(uname -m)
+mkdir -p actions-runner && cd actions-runner
+curl -O -L https://github.com/actions/runner/releases/download/v2.308.0/actions-runner-linux-${ARCH}-2.308.0.tar.gz
+tar xzf actions-runner-linux-${ARCH}-2.308.0.tar.gz
+./config.sh --url https://github.com/REPO_PLACEHOLDER --token TOKEN_PLACEHOLDER --name NAME_PLACEHOLDER --labels self-hosted,jetson --unattended
+sudo tee /etc/systemd/system/github-runner.service >/dev/null <<EOF
+[Unit]
+Description=GitHub Actions Runner
+After=network.target
+
+[Service]
+Type=simple
+User=root
+WorkingDirectory=$(pwd)
+ExecStart=$(pwd)/run.sh
+Restart=always
+RestartSec=5
+
+[Install]
+WantedBy=multi-user.target
+EOF
+sudo systemctl daemon-reload
+sudo systemctl enable --now github-runner.service
+SSH
+)
+  i=$((i+1))
+done < "$TOKENS_FILE"
+
+echo "Runner provisioning invoked for devices"
+
*** End Patch
*** Begin Patch
*** Add File: hardware/validation/validate_tensorrt_batch.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run TensorRT validation across a set of models/inputs and upload results to MLflow and controller.
+# Usage: validate_tensorrt_batch.sh --models models_dir --mlflow-run-id <runid> --controller <url> --device-id <id>
+
+MODELS_DIR=""
+MLFLOW_RUN=""
+CONTROLLER=""
+DEVICE_ID=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --models) MODELS_DIR="$2"; shift 2;;
+    --mlflow-run-id) MLFLOW_RUN="$2"; shift 2;;
+    --controller) CONTROLLER="$2"; shift 2;;
+    --device-id) DEVICE_ID="$2"; shift 2;;
+    *) echo "usage: --models dir --mlflow-run-id id --controller url --device-id id" && exit 2;;
+  esac
+done
+
+: "${MODELS_DIR:?}"
+
+for f in "${MODELS_DIR}"/*; do
+  echo "Validating ${f}"
+  # placeholder for real validation
+  python3 - <<PY
+import json,sys
+report={"model":"${f}", "ok": True, "notes":"placeholder validation"}
+print(json.dumps(report))
+PY
+done
+
+if [ -n "${MLFLOW_RUN:-}" ]; then
+  echo "Uploading reports to MLflow run ${MLFLOW_RUN} (placeholder)"
+fi
+if [ -n "${CONTROLLER:-}" ] && [ -n "${DEVICE_ID:-}" ]; then
+  echo "Posting validation summary to controller"
+  curl -s -X POST -H "Content-Type: application/json" --data '{"device_id":"'"${DEVICE_ID}"'","validation":"completed"}' "${CONTROLLER}/api/v1/devices/${DEVICE_ID}/telemetry" || true
+fi
+
*** End Patch
*** Begin Patch
*** Add File: ci/hardware/jetson_validation_job.yml
+name: Jetson Hardware Validation (self-hosted)
+on:
+  workflow_dispatch:
+
+jobs:
+  validate:
+    runs-on: [self-hosted, jetson]
+    steps:
+      - uses: actions/checkout@v4
+      - name: Run TensorRT validation on device
+        run: |
+          ./hardware/validation/validate_tensorrt_batch.sh --models ./out --mlflow-run-id ${{ secrets.MLFLOW_RUN_ID }} --controller ${{ secrets.CONTROLLER_URL }} --device-id ${{ secrets.DEVICE_ID }}
+
*** End Patch
*** Begin Patch
*** Add File: compliance/hipaa/hipaa_checklist.md
+# HIPAA Readiness Checklist (starter)
+
+This is a non‑exhaustive checklist to guide compliance work. Engage legal/compliance for certification.
+
+1) Administrative Safeguards
+ - Risk analysis and management process documented
+ - Access controls & least privilege policies in place
+ - Workforce training and role‑based access controls
+
+2) Physical Safeguards
+ - Secure hardware labs, physical access control for devices running PHI
+ - Asset inventory for Jetson/edge devices that may process PHI
+
+3) Technical Safeguards
+ - Encryption in transit and at rest (Vault, TLS enforced)
+ - Access logging and audit (MLflow audit, decision_log)
+ - Key management using KMS/HSM for signing and encryption
+ - Data minimization and deidentification before sending to external providers (QPU or cloud)
+
+4) Policies & Agreements
+ - Business Associate Agreements (BAA) with cloud providers or third parties handling PHI
+ - Data retention and disposal policies
+ - Incident response and breach notification procedures
+
+5) Evidence & Documentation
+ - System architecture, policies, training records, change control logs, and CI/CD audit trails
+ - Evidence collection scripts (see compliance/evidence/collect_evidence.sh)
+
*** End Patch
*** Begin Patch
*** Add File: compliance/evidence/collect_evidence.sh
+#!/usr/bin/env bash
+set -euo pipefail
+OUTDIR="${1:-/tmp/aegis_evidence}"
+mkdir -p "${OUTDIR}"
+echo "Collecting MLflow artifacts (last 24h) - placeholder"
+# Example: download artifacts via MLflow API (requires MLflow CLI / API)
+echo "Collecting controller logs"
+kubectl logs -l app=aegis-fleet-controller -n aegis --tail=500 > "${OUTDIR}/controller_logs.txt" || true
+echo "Collecting cosign/release artifacts"
+cp manifest.json "${OUTDIR}/" || true
+tar czf "${OUTDIR}/evidence_$(date +%s).tgz" -C "${OUTDIR}" .
+echo "Wrote evidence bundle to ${OUTDIR}/evidence_*.tgz"
+
*** End Patch
*** Begin Patch
*** Add File: security/image_scan_and_sign.yml
+name: Image Scan, Vulnerability Report & Cosign Sign
+on:
+  workflow_dispatch:
+
+jobs:
+  scan-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Build runtime image
+        run: docker build -t aegis/edge-runtime:latest runtime/edge_runtime
+      - name: Run Trivy vulnerability scan
+        uses: aquasecurity/trivy-action@v0.1.8
+        with:
+          image-ref: aegis/edge-runtime:latest
+      - name: Sign image with cosign
+        env:
+          COSIGN_KMS_KEY: ${{ secrets.COSIGN_KMS_KEY }}
+        run: |
+          if [ -n "${COSIGN_KMS_KEY}" ]; then
+            cosign sign --key "${COSIGN_KMS_KEY}" aegis/edge-runtime:latest
+          else
+            echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
+            cosign sign --key cosign.key aegis/edge-runtime:latest
+          cosign verify aegis/edge-runtime:latest || true
+
*** End Patch
*** Begin Patch
*** Add File: runbooks/incident/incident_response_template.md
+# Incident Response Template
+
+1) Detect & Triage
+ - Which alert fired? (Prometheus alertname)
+ - Scope: number of affected devices, rollouts, or regions
+ - Initial severity and PagerDuty escalation
+
+2) Containment
+ - If rollout related: pause/abort rollout and block further promotions
+ - If image vulnerability: revoke image tags and halt deployments
+ - If signing key compromise: rotate keys in KMS/HSM, revoke affected signatures if possible
+
+3) Eradication & Recovery
+ - Rollback to previous known-good release
+ - Reprovision devices or revoke device certs where necessary
+ - Re-run CI verification after fixes
+
+4) Postmortem
+ - Collect artifacts, logs, timelines and RCA
+ - Update runbooks and policy (OPA) to prevent recurrence
+
*** End Patch
*** Begin Patch
*** Add File: docs/ops/ha_design_notes.md
+# Fleet Controller HA & Multi-Region Resilience (notes)
+
+Recommended patterns:
+- Run controller deployment with multiple replicas (>=3) and HPA to scale under load.
+- Use a highly available Postgres (managed RDS or Patroni cluster) with read replicas and connection pooling.
+- Use Kubernetes Lease object for leader election (see k8s/fleet/controller/lease_leader.yaml).
+- Expose controller behind a regional ingress + Global Load Balancer (cloud LB) and use DNS failover for multi-region resilience.
+- Use read/write splitting or sharding for telemetry ingestion; move heavy aggregations to worker jobs.
+- RBAC: controller runs with least privilege ServiceAccount and ClusterRole (see k8s/fleet/controller/prod_rbac.yaml).
+- Backup & restore: schedule regular database backups and store in encrypted object storage; automate restore runbooks.
+
*** End Patch
*** End Patch
