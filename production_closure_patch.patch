*** Begin Patch
*** Add File: k8s/networkpolicies/operator-isolation.yaml
+apiVersion: networking.k8s.io/v1
+kind: NetworkPolicy
+metadata:
+  name: operator-signer-isolation
+  namespace: operator
+spec:
+  podSelector:
+    matchLabels:
+      app: device-hsm-signer
+  policyTypes:
+    - Ingress
+  ingress:
+    - from:
+        - namespaceSelector:
+            matchLabels:
+              aegis-role: operator
+        - podSelector:
+            matchLabels:
+              app: monitoring
+      ports:
+        - protocol: TCP
+          port: 8111
+    - from:
+        - ipBlock:
+            cidr: 10.0.0.0/8
+            except:
+              - 10.0.0.0/24
+      ports:
+        - protocol: TCP
+          port: 8111
+
+---
+apiVersion: networking.k8s.io/v1
+kind: NetworkPolicy
+metadata:
+  name: restrict-quantum-admission
+  namespace: aegis
+spec:
+  podSelector:
+    matchLabels:
+      app: quantum-admission
+  policyTypes:
+    - Ingress
+  ingress:
+    - from:
+        - namespaceSelector:
+            matchLabels:
+              aegis-role: operator
+        - podSelector:
+            matchLabels:
+              app: gateway
+      ports:
+        - protocol: TCP
+          port: 8410
+
*** End Patch
*** Begin Patch
*** Add File: vault/policies/hsm_operator.hcl
+# Vault policy for HSM operator namespace: restrict key management operations
+path "transit/*" {
+  capabilities = ["read", "update", "create"]
+}
+path "secret/data/hsm/*" {
+  capabilities = ["read"]
+}
+path "sys/policy/hsm-operator" {
+  capabilities = ["read"]
+}
+
*** End Patch
*** Begin Patch
*** Add File: operator/hsm_integration/rotate_with_audit.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# HSM rotate wrapper that:
+#  - runs vendor rotate command
+#  - records rotation evidence to COMPLIANCE_BUCKET
+#  - creates a Rekor entry if cosign/logging is configured
+
+COMPLIANCE_BUCKET=${COMPLIANCE_BUCKET:-}
+HSM_ROTATE_CMD=${HSM_ROTATE_CMD:-/opt/hsm/hsm_rotate_key.sh}
+TMPDIR=$(mktemp -d)
+TS=$(date -u +"%Y%m%dT%H%M%SZ")
+
+echo "Running HSM rotation..."
+if [ -x "${HSM_ROTATE_CMD}" ]; then
+  "${HSM_ROTATE_CMD}" || { echo "HSM rotate failed"; exit 2; }
+else
+  echo "No vendor rotate command found; aborting" >&2
+  exit 2
+fi
+
+EVIDENCE="${TMPDIR}/rotation_${TS}.json"
+cat > "${EVIDENCE}" <<EOF
+{"rotated_at":"${TS}","operator":"$(whoami)","method":"hsm_vendor"}
+EOF
+
+if [ -n "${COMPLIANCE_BUCKET}" ]; then
+  aws s3 cp "${EVIDENCE}" "s3://${COMPLIANCE_BUCKET}/hsm/rotation_${TS}.json"
+  echo "Uploaded rotation evidence to s3://${COMPLIANCE_BUCKET}/hsm/rotation_${TS}.json"
+fi
+
+echo "Rotation complete"
+
*** End Patch
*** Begin Patch
*** Add File: operator/rotation_automation/rotation_rollback_helper.py
+#!/usr/bin/env python3
+"""
+Rotation rollback helper: after rotation, run canaries; if canaries fail call vendor rollback API or mark incident.
+This script is intentionally conservative — it will only mark remediation artifacts for human operator action if rollback endpoint not available.
+"""
+import os, requests, time, json
+
+CANARY_SIGNER_URL = os.environ.get("CANARY_SIGNER_URL", "http://device-hsm-signer.operator.svc:8111/sign_device")
+ROLLBACK_API = os.environ.get("HSM_ROLLBACK_API")  # vendor-provided
+COMPLIANCE_BUCKET = os.environ.get("COMPLIANCE_BUCKET")
+
+def canary_enroll(device_id):
+    try:
+        r = requests.post(CANARY_SIGNER_URL, json={"device_id":device_id,"public_key":"CANARYPUB","attestation":"CANARY"}, timeout=10)
+        return r.ok
+    except Exception:
+        return False
+
+def record_incident(detail):
+    ts = int(time.time())
+    fn = f"/tmp/rotation_incident_{ts}.json"
+    json.dump(detail, open(fn,"w"), indent=2)
+    if COMPLIANCE_BUCKET:
+        try:
+            import boto3
+            s3=boto3.client("s3")
+            s3.upload_file(fn, COMPLIANCE_BUCKET, f"incidents/rotation_incident_{ts}.json")
+        except Exception:
+            pass
+    print("Recorded incident:", fn)
+
+def try_rollback():
+    if not ROLLBACK_API:
+        print("No rollback API configured; escalate to operator")
+        return False
+    r = requests.post(ROLLBACK_API, json={"reason":"canary_fail"}, timeout=10)
+    return r.ok
+
+def main():
+    # run a few canaries
+    failed = []
+    for i in range(3):
+        ok = canary_enroll(f"canary-{i}")
+        print("canary", i, "ok:", ok)
+        if not ok:
+            failed.append(i)
+    if failed:
+        print("Canary failures detected:", failed)
+        if try_rollback():
+            print("Rollback initiated via vendor API")
+        else:
+            record_incident({"failed_canaries": failed, "ts": int(time.time())})
+            print("Escalated incident for operator handling")
+
+if __name__=="__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File: monitoring/prometheus/agentic_alerts.yaml
+groups:
+- name: agentic.rules
+  rules:
+    - alert: AgenticStuckTransactions
+      expr: increase(agent_stuck_transactions_total[15m]) > 0
+      for: 5m
+      labels:
+        severity: critical
+      annotations:
+        summary: "Stuck transactions detected in Agentic ({{ $value }})"
+        description: "One or more transactions have been stuck for >15m."
+
+    - alert: AgenticHighPrepareFailRate
+      expr: rate(agent_prepare_failures_total[5m]) > 0.01
+      for: 10m
+      labels:
+        severity: warning
+      annotations:
+        summary: "High prepare failure rate"
+        description: "Prepare failures >1% over 5m."
+
+    - alert: QuantumReconcileAnomalies
+      expr: increase(quantum_reconcile_anomalies_total[30m]) > 0
+      for: 5m
+      labels:
+        severity: warning
+      annotations:
+        summary: "Quantum reconciliation anomalies detected"
+        description: "Check reconciler reports in S3 and remediation tickets."
+
+    - alert: RLHFBillingAnomaly
+      expr: increase(billing_reconcile_anomalies_total[30m]) > 0
+      for: 5m
+      labels:
+        severity: warning
+      annotations:
+        summary: "Billing reconciliation anomalies"
+        description: "Billing reconcile reported anomalies — inspect billing pipeline."
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/production_gate.yml
+name: Production Readiness Gate
+on:
+  workflow_dispatch:
+    inputs:
+      branch:
+        required: false
+        default: "main"
+
+jobs:
+  gate:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Ensure Agentic chaos passed
+        run: |
+          gh workflow run agentic_full_chaos_sequence.yml --ref ${{ github.event.inputs.branch }} -f runs=3 -f duration=600 -f namespace=aegis
+          # wait for completion and fail if run failed
+          sleep 10
+          gh run watch --exit-status --workflow agentic_full_chaos_sequence.yml || (echo "Agentic chaos failed" && exit 2)
+      - name: Ensure rotation drill success
+        run: |
+          gh workflow run edge_rotation_drill_ci.yml --ref ${{ github.event.inputs.branch }} -f total_devices=500
+          sleep 10
+          gh run watch --exit-status --workflow edge_rotation_drill_ci.yml || (echo "Rotation drill failed" && exit 2)
+      - name: Ensure Quantum reconciliation is clean
+        run: |
+          gh workflow run quantum_full_prod_reconcile.yml --ref ${{ github.event.inputs.branch }}
+          sleep 10
+          gh run watch --exit-status --workflow quantum_full_prod_reconcile.yml || (echo "Quantum reconcile failed" && exit 2)
+      - name: Run RLHF production pilot (gated)
+        run: |
+          gh workflow run rlhf_prod_pilot.yml --ref ${{ github.event.inputs.branch }} -f profile=pilot_medium
+          sleep 10
+          gh run watch --exit-status --workflow rlhf_prod_pilot.yml || (echo "RLHF pilot failed" && exit 2)
+      - name: Finalize promotion
+        run: |
+          echo "All gates passed. Marking branch for production release."
+          # create a release tag or trigger promotion pipeline here
+          gh release create "prod-$(date +%Y%m%d%H%M%S)" --notes "Production readiness gate passed" || true
+
*** End Patch
*** Begin Patch
*** Add File: scripts/create_github_issue_on_reconcile_anomaly.py
+#!/usr/bin/env python3
+"""
+Create GitHub issue automatically when reconciler v4 reports anomalies.
+This is used by the reconciler as a remediation hook.
+Requires GITHUB_TOKEN in env with repo:issues permissions.
+"""
+import os, sys, json
+import requests
+
+GITHUB_REPO = os.environ.get("GITHUB_REPO")  # e.g., owner/repo
+GITHUB_TOKEN =

