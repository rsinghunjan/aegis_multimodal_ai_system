*** Begin Patch
*** Add File:ops/apply_irsa_and_annotate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Apply Terraform IRSA (local tfvars) and annotate Kubernetes ServiceAccounts with role ARNs.
+# Usage:
+#   cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars
+#   # edit terraform/irsa/my.tfvars locally (do NOT commit)
+#   ./ops/apply_irsa_and_annotate.sh terraform/irsa/my.tfvars
+
+TFVARS=${1:-terraform/irsa/my.tfvars}
+TF_DIR="terraform/irsa"
+
+if [ ! -f "${TFVARS}" ]; then
+  echo "Error: tfvars not found at ${TFVARS}"
+  exit 2
+fi
+
+echo "Running Terraform in ${TF_DIR} with ${TFVARS}..."
+pushd "${TF_DIR}" >/dev/null
+terraform init -input=false
+terraform plan -input=false -var-file="${TFVARS}" -out=tfplan
+terraform apply -input=false -auto-approve tfplan
+terraform output -json > /tmp/irsa_outputs.json
+popd >/dev/null
+
+if [ -f /tmp/irsa_outputs.json ]; then
+  echo "Annotating ServiceAccounts based on Terraform outputs..."
+  if [ -x terraform/irsa/irsa_annotate_sa.sh ]; then
+    ./terraform/irsa/irsa_annotate_sa.sh /tmp/irsa_outputs.json
+  else
+    echo "Warning: terraform/irsa/irsa_annotate_sa.sh not executable or not present. Please run annotation manually."
+  fi
+else
+  echo "Terraform outputs not found at /tmp/irsa_outputs.json"
+fi
+
+echo "IRSA apply + annotation (attempt) finished."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/terraform_irsa_apply.yml
+name: Terraform IRSA Plan & Apply (OIDC)
+
+on:
+  workflow_dispatch:
+    inputs:
+      auto_approve:
+        description: 'Set to true to auto-apply (use with caution)'
+        required: false
+        default: 'false'
+
+jobs:
+  plan:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Setup Terraform
+        uses: hashicorp/setup-terraform@v2
+        with:
+          terraform_version: 1.5.0
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Terraform Init & Plan
+        working-directory: terraform/irsa
+        run: |
+          terraform init -input=false
+          terraform plan -input=false -var-file=my.tfvars -out=tfplan
+      - name: Upload tfplan
+        uses: actions/upload-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+
+  apply:
+    needs: plan
+    if: ${{ github.event.inputs.auto_approve == 'true' }}
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Download tfplan
+        uses: actions/download-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+      - name: Terraform Apply
+        working-directory: terraform/irsa
+        run: terraform apply -input=false -auto-approve tfplan
+
*** End Patch
*** Begin Patch
*** Add File:ops/provision_github_secrets_and_externalsecrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Create GitHub repo secrets and apply ExternalSecrets YAML to the cluster.
+# Required environment variables:
+#   REPO, COSIGN_KMS_ARN, REKOR_URL, EVIDENCE_BUCKET, MLFLOW_TRACKING_URI
+# Optional:
+#   AWS_ROLE_TO_ASSUME, PROVIDER_API_KEYS_JSON, NAMESPACE (default: aegis)
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+NAMESPACE=${NAMESPACE:-aegis}
+
+required=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI)
+for v in "${required[@]}"; do
+  if [ -z "${!v:-}" ]; then
+    echo "Error: environment variable ${v} must be set"
+    exit 2
+  fi
+done
+
+echo "Setting GitHub secrets for ${REPO}..."
+gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+gh secret set EVIDENCE_BUCKET --repo "${REPO}" --body "${EVIDENCE_BUCKET}"
+gh secret set MLFLOW_TRACKING_URI --repo "${REPO}" --body "${MLFLOW_TRACKING_URI}"
+if [ -n "${AWS_ROLE_TO_ASSUME:-}" ]; then
+  gh secret set AWS_ROLE_TO_ASSUME --repo "${REPO}" --body "${AWS_ROLE_TO_ASSUME}"
+fi
+if [ -n "${PROVIDER_API_KEYS_JSON:-}" ]; then
+  gh secret set PROVIDER_API_KEYS_JSON --repo "${REPO}" --body "${PROVIDER_API_KEYS_JSON}"
+fi
+
+echo "Applying ExternalSecrets SecretStore and ExternalSecret manifests (requires ExternalSecrets operator)"
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/secretstore.aws.yaml || true
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/externalsecret_runtime_values.yaml || true
+
+echo "Provisioning finished. Verify secrets in GitHub and ExternalSecrets in Kubernetes."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/ci_registry_kms_validation.yml
+name: CI Registry & KMS Permissions Validation
+
+on:
+  workflow_dispatch:
+    inputs:
+      ecr_registry:
+        description: 'ECR registry (optional)'
+        required: false
+
+jobs:
+  validate:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Validate KMS describe permission
+        run: |
+          if [ -z "${{ secrets.COSIGN_KMS_ARN }}" ]; then
+            echo "COSIGN_KMS_ARN not set in secrets; failing"
+            exit 1
+          fi
+          aws kms describe-key --key-id "${{ secrets.COSIGN_KMS_ARN }}"
+      - name: Validate ECR push auth (optional)
+        if: ${{ github.event.inputs.ecr_registry != '' }}
+        run: |
+          REG="${{ github.event.inputs.ecr_registry }}"
+          aws ecr get-authorization-token --registry-ids "$(echo ${REG} | cut -d. -f1)"
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_runtime_services.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install runtime services:
+#  - Argo Workflows
+#  - ArgoCD (Helm)
+#  - Prometheus (kube-prometheus-stack via Helm)
+#  - ExternalSecrets operator (Helm)
+#  - Istio (demo) and/or Knative (optional)
+#
+echo "Installing Argo Workflows..."
+kubectl create namespace argo --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/stable/manifests/install.yaml
+
+echo "Installing ArgoCD via Helm..."
+bash ops/install_argocd_helm.sh
+
+echo "Installing Prometheus (kube-prometheus-stack)..."
+helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
+helm repo update
+kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install kube-prom prometheus-community/kube-prometheus-stack -n monitoring --wait
+
+echo "Installing ExternalSecrets operator..."
+helm repo add external-secrets https://external-secrets.github.io/kubernetes-external-secrets/ || true
+helm repo update
+kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install external-secrets external-secrets/kubernetes-external-secrets -n external-secrets --wait
+
+echo "Installing Istio (demo profile)..."
+bash istio/install_istio.sh || true
+echo "Installing Knative (optional; may be skipped)..."
+bash knative/install_knative.sh || true
+
+echo "Runtime services installed (check pods in argo, argocd, monitoring, external-secrets namespaces)."
+
*** End Patch
*** Begin Patch
*** Add File:ops/deploy_metricproxy_and_promoter_and_secret.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Deploy metric-proxy and gitops-promoter to the cluster and create in-cluster secret for promoter.
+# Required env vars:
+#   GITHUB_TOKEN (optional but required if promoter should open PRs)
+#   NAMESPACE (default: aegis)
+#
+NAMESPACE=${NAMESPACE:-aegis}
+
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "Applying metric-proxy manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-deployment.yaml
+
+echo "Applying promoter manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-deployment.yaml
+
+if [ -n "${GITHUB_TOKEN:-}" ]; then
+  echo "Creating in-cluster gitops-promoter-secret..."
+  kubectl -n "${NAMESPACE}" create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}" --dry-run=client -o yaml | kubectl apply -f -
+  echo "Promoter secret created."
+else
+  echo "GITHUB_TOKEN not provided; promoter will not have credentials to open PRs until secret is created manually."
+fi
+
+echo "Metric-proxy and promoter deployed into namespace ${NAMESPACE}."
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_gatekeeper_and_set_branch_protection.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Gatekeeper, apply constraints, and configure GitHub branch protection + required PR checks.
+# Requires GITHUB_TOKEN to set branch protection via gh.
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+echo "Installing Gatekeeper..."
+kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+sleep 5
+echo "Applying Gatekeeper constraint templates..."
+kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml || true
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping GitHub branch protection configuration. Set GITHUB_TOKEN and re-run to enforce protections."
+  exit 0
+fi
+
+echo "Configuring branch protection for ${REPO}:${BRANCH} (requires gh CLI and GITHUB_TOKEN)"
+required_contexts='["sanitizer","ci_train_validate_register","image_build_cosign"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Gatekeeper installed and branch protection configured."
+
*** End Patch
*** Begin Patch
*** Add File:ops/upload_legal_signoff_and_require_checks.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Upload legal signoff to evidence S3 and enforce sanitizer + CI checks on target branch.
+# Usage:
+#   export EVIDENCE_BUCKET, REPO, BRANCH, GITHUB_TOKEN
+#   ./ops/upload_legal_signoff_and_require_checks.sh path/to/legal_signoff.md
+#
+FILE=${1:-ops/legal_signoff.md}
+EVIDENCE_BUCKET=${EVIDENCE_BUCKET:-REPLACE_EVIDENCE_BUCKET}
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+if [ ! -f "${FILE}" ]; then
+  echo "Error: legal signoff file not found: ${FILE}"
+  exit 2
+fi
+
+echo "Uploading legal signoff to s3://${EVIDENCE_BUCKET}/legal_signoff/"
+aws s3 cp "${FILE}" "s3://${EVIDENCE_BUCKET}/legal_signoff/$(basename "${FILE}")"
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "GITHUB_TOKEN not set; skipping branch protection update. Set GITHUB_TOKEN and re-run to require sanitizer/CI checks."
+  exit 0
+fi
+
+echo "Enforcing sanitizer and CI checks on ${REPO}:${BRANCH}"
+required_contexts='["sanitizer","ci_train_validate_register","secret-and-deploy-preflight"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "Legal signoff uploaded and branch protection updated."
+
*** End Patch
*** Begin Patch
*** Add File:ops/tune_slos_and_validate_budget.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Tune SLO thresholds in the aegis-slo-config ConfigMap and run sample queries via metric-proxy.
+# Also run a placeholder cost estimator validation step.
+#
+P95=${1:-0.5}
+ERROR_RATE=${2:-0.02}
+WINDOW_MIN=${3:-60}
+METRIC_PROXY_URL=${METRIC_PROXY_URL:-http://metric-proxy.aegis.svc.cluster.local:8080}
+
+echo "Updating aegis-slo-config: p95=${P95}, error_rate=${ERROR_RATE}, window=${WINDOW_MIN}m"
+kubectl -n aegis create configmap aegis-slo-config --from-literal=p95_latency_threshold_seconds="${P95}" --from-literal=canary_error_rate_threshold="${ERROR_RATE}" --from-literal=canary_success_window_minutes="${WINDOW_MIN}" -o yaml --dry-run=client | kubectl apply -f -
+
+echo "Querying metric-proxy for p95 latency (sample query)..."
+QUERY='histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+ENCODED_QUERY=$(python3 - <<PY
+import urllib.parse
+print(urllib.parse.quote('''${QUERY}'''))
+PY
+)
+curl -s "${METRIC_PROXY_URL}/api/v1/query?query=${ENCODED_QUERY}" | jq .
+
+echo "Running cost/budget validation (placeholder) â€” ensure your cost-estimator is run and result <= budget"
+if [ -x ./ops/qpu_cost_estimator_braket_integration.py ]; then
+  echo "Running qpu cost estimator placeholder..."
+  python3 ./ops/qpu_cost_estimator_braket_integration.py --sample || echo "Cost estimator run returned non-zero (or placeholder)"
+else
+  echo "No cost estimator script found; validate budgets manually."
+fi
+
+echo "SLO tuning & budget validation complete."
+
*** End Patch
*** Begin Patch
*** Add File:docs/operator_finalize_runbook.md
+## Aegis Finalize: Operator Runbook (summary)
+
+This runbook summarizes the commands to finalize the Aegis platform. Replace REPLACE_* placeholders locally; never commit secrets.
+
+1) Apply Terraform IRSA and annotate SAs:
+   cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars
+   # edit terraform/irsa/my.tfvars locally (do NOT commit)
+   ./ops/apply_irsa_and_annotate.sh terraform/irsa/my.tfvars
+
+2) Provision GitHub secrets & ExternalSecrets:
+   export REPO="owner/repo"
+   export COSIGN_KMS_ARN="arn:aws:kms:..."
+   export REKOR_URL="https://rekor.example.com"
+   export EVIDENCE_BUCKET="aegis-evidence-123"
+   export MLFLOW_TRACKING_URI="https://mlflow.example.com"
+   export AWS_ROLE_TO_ASSUME="arn:aws:iam::123:role/ci-oidc-role"   # optional
+   export PROVIDER_API_KEYS_JSON='{"ibm_api_key":"..."}'           # optional
+   ./ops/provision_github_secrets_and_externalsecrets.sh
+
+3) Validate CI registry & KMS role:
+   - Run the GitHub Action workflow "CI Registry & KMS Permissions Validation" via the Actions UI, or:
+   - Locally, ensure your CI OIDC role (AWS_ROLE_TO_ASSUME) can be assumed and can call KMS/ECR.
+
+4) Install runtime services:
+   ./ops/install_runtime_services.sh
+
+5) Deploy metric-proxy & promoter and create in-cluster secret:
+   export GITHUB_TOKEN="ghp_..."
+   ./ops/deploy_metricproxy_and_promoter_and_secret.sh
+
+6) Install Gatekeeper and enforce branch protection:
+   export GITHUB_TOKEN="ghp_..."
+   export REPO="owner/repo"
+   ./ops/install_gatekeeper_and_set_branch_protection.sh
+
+7) Upload legal signoff and require sanitizer + CI checks:
+   export EVIDENCE_BUCKET="aegis-evidence-123"
+   export REPO="owner/repo"
+   export BRANCH="main"
+   export GITHUB_TOKEN="ghp_..."
+   ./ops/upload_legal_signoff_and_require_checks.sh path/to/legal_signoff.md
+
+8) Tune SLOs & validate budgets:
+   ./ops/tune_slos_and_validate_budget.sh 0.5 0.02 60
+
+9) Verify:
+   kubectl -n argocd get pods
+   kubectl -n argo get pods
+   kubectl -n monitoring get pods
+   kubectl -n aegis get deployments,svc
+   gh secret list --repo owner/repo
+
+Security reminders:
+- NEVER commit terraform/irsa/my.tfvars or any secret values.
+- Use ExternalSecrets backed by a secure store (AWS Secrets Manager, HashiCorp Vault).
+- Limit who can edit GitHub repo secrets and branch protection settings.
+
*** End Patch
*** End Patch
