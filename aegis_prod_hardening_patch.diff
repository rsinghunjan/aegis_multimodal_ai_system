diff --git a/vault/write_github_app_to_vault.sh b/vault/write_github_app_to_vault.sh
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/vault/write_github_app_to_vault.sh
@@ -0,0 +1,140 @@
+#!/usr/bin/env bash
+#
+# Operator helper: write GitHub App PEM and metadata into Vault KV v2.
+# Requires VAULT_ADDR & VAULT_TOKEN env vars and `vault` cli installed.
+#
+# Usage:
+#   ./vault/write_github_app_to_vault.sh --pem /tmp/github_app.pem --app-id 12345 --installation-id 67890
+
+set -euo pipefail
+
+PEM_FILE=""
+APP_ID=""
+INSTALLATION_ID=""
+VAULT_PATH="${VAULT_PATH:-secret/data/aegis/github_app}"
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --pem) PEM_FILE="$2"; shift 2;;
+    --app-id) APP_ID="$2"; shift 2;;
+    --installation-id) INSTALLATION_ID="$2"; shift 2;;
+    --vault-path) VAULT_PATH="$2"; shift 2;;
+    *) echo "Unknown arg $1"; exit 1;;
+  esac
+done
+
+if [ -z "$PEM_FILE" ] || [ -z "$APP_ID" ] || [ -z "$INSTALLATION_ID" ]; then
+  echo "Provide --pem, --app-id and --installation-id"
+  exit 1
+fi
+
+if [ -z "${VAULT_ADDR:-}" ] || [ -z "${VAULT_TOKEN:-}" ]; then
+  echo "Set VAULT_ADDR and VAULT_TOKEN in environment"
+  exit 1
+fi
+
+echo "Writing GitHub App PEM to Vault at $VAULT_PATH"
+# Use KV v2 write format: data: {...}
+PEM_CONTENT=$(sed 's/"/\\"/g' "$PEM_FILE")
+curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request POST \
+  --data "{\"data\": {\"private_key\": \"$(sed -e ':a' -e 'N' -e '$!ba' -e 's/\\n/\\\\n/g' "$PEM_FILE")\", \"app_id\": \"$APP_ID\", \"installation_id\": \"$INSTALLATION_ID\" }}" \
+  "$VAULT_ADDR/v1/$VAULT_PATH" | jq . || true
+
+echo "Done. Ensure Vault policy allows the aegis-agent role to read $VAULT_PATH"
+
+exit 0
+
diff --git a/k8s/manifests/remove_plaintext_secrets.sh b/k8s/manifests/remove_plaintext_secrets.sh
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/k8s/manifests/remove_plaintext_secrets.sh
@@ -0,0 +1,120 @@
+#!/usr/bin/env bash
+#
+# Helper to detect and optionally remove plaintext Kubernetes secrets in the aegis-ml namespace.
+# Use with caution. This script lists secrets that look like credentials and optionally deletes them.
+
+NAMESPACE="${1:-aegis-ml}"
+DRY_RUN=true
+
+if [[ "${2:-}" == "--apply" ]]; then
+  DRY_RUN=false
+fi
+
+echo "Scanning namespace $NAMESPACE for suspicious secrets (dry-run=$DRY_RUN)..."
+SECRETS=$(kubectl -n "$NAMESPACE" get secrets -o json | jq -r '.items[].metadata.name')
+for s in $SECRETS; do
+  # heuristics: secret names containing password, postgres, github, token, key, pem
+  if echo "$s" | egrep -i "password|postgres|db|github|token|key|pem|secret" >/dev/null; then
+    echo "Found candidate secret: $s"
+    kubectl -n "$NAMESPACE" get secret "$s" -o yaml | yq e '.data' - >/dev/null 2>&1 || true
+    if [ "$DRY_RUN" = "false" ]; then
+      echo "Deleting secret $s"
+      kubectl -n "$NAMESPACE" delete secret "$s" || true
+    else
+      echo "(dry-run) would delete: $s"
+    fi
+  fi
+done
+
+echo "Scan complete. If you removed secrets, ensure Vault Injector annotations are present on deployments and that Vault policies/roles are configured."
+
diff --git a/policy/opa/data/models_canonical.json b/policy/opa/data/models_canonical.json
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/policy/opa/data/models_canonical.json
@@ -0,0 +1,120 @@
+{
+  "models": {
+    "low-demo-model": {
+      "risk": "low",
+      "team": "ads",
+      "budget_usd_per_month": 200.0,
+      "owners": ["alice","bob"],
+      "approved_installations": []
+    },
+    "fraud-detector-v1": {
+      "risk": "high",
+      "team": "fraud",
+      "budget_usd_per_month": 1000.0,
+      "owners": ["sre","security"],
+      "approved_installations": []
+    },
+    "default": {
+      "risk": "medium",
+      "team": "ml",
+      "budget_usd_per_month": 500.0,
+      "owners": ["ml-team"],
+      "approved_installations": []
+    }
+  }
+}
+
diff --git a/policy/opa/tests/agent_policies_more_tests.rego b/policy/opa/tests/agent_policies_more_tests.rego
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/policy/opa/tests/agent_policies_more_tests.rego
@@ -0,0 +1,220 @@
+package aegis.policies.tests
+
+import data.aegis.policies
+import data.models
+
+# Test a variety of action types and risk levels
+test_retrain_staging_allowed {
+  input := {"action": "retrain", "model": "low-demo-model", "env": "staging", "params": {}}
+  result := data.aegis.policies.result with input as input
+  result.allow == true
+}
+
+test_promote_medium_requires_approval {
+  input := {"action": "promote", "model": "default", "env": "production", "params": {}}
+  result := data.aegis.policies.result with input as input
+  result.allow == false
+}
+
+test_promote_medium_with_approval {
+  input := {"action": "promote", "model": "default", "env": "production", "params": {"approved_by": "sre"}}
+  result := data.aegis.policies.result with input as input
+  result.allow == true
+}
+
+test_high_risk_retrain_denied_in_prod {
+  input := {"action":"retrain","model":"fraud-detector-v1","env":"production","params":{}}
+  result := data.aegis.policies.result with input as input
+  result.allow == false
+}
+
+test_create_pr_allowed_in_prod_for_high_risk {
+  input := {"action":"create_pr","model":"fraud-detector-v1","env":"production","params":{}}
+  result := data.aegis.policies.result with input as input
+  result.allow == true
+}
+
+test_unknown_model_uses_default_medium {
+  input := {"action":"retrain","model":"some-unknown-model","env":"production","params":{}}
+  result := data.aegis.policies.result with input as input
+  # default is medium so should require approval for promote
+  result.allow == false
+}
+
diff --git a/.github/workflows/policy_review.yml b/.github/workflows/policy_review.yml
new file mode 100644
index 0000000..5555555
--- /dev/null
+++ b/.github/workflows/policy_review.yml
@@ -0,0 +1,180 @@
+name: Policy Review CI
+
+on:
+  pull_request:
+    paths:
+      - "policy/**"
+
+jobs:
+  policy-tests:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Run OPA tests & lint
+        run: |
+          docker run --rm -v "${{ github.workspace }}:/workspace" openpolicyagent/opa:latest test /workspace/policy -v
+          docker run --rm -v "${{ github.workspace }}:/workspace" openpolicyagent/opa:latest fmt /workspace/policy || true
+      - name: Post policy review checklist comment
+        uses: marocchino/sticky-pull-request-comment@v2
+        with:
+          message: |
+            Policy tests ran. Please ensure product/SRE/Sec have reviewed changes and updated data/models_canonical.json if needed.
+
diff --git a/agents/common/github_client.py b/agents/common/github_client.py
new file mode 100644
index 0000000..6666666
--- /dev/null
+++ b/agents/common/github_client.py
@@ -0,0 +1,240 @@
+#!/usr/bin/env python3
+"""
+GitHub client wrapper that obtains installation tokens from Vault and performs actions
+such as creating PRs and commenting. Uses agents.common.github_app_vault to fetch installation tokens.
+"""
+import os
+import requests
+import json
+import logging
+from typing import Optional, Dict, Any
+
+logger = logging.getLogger("aegis.github.client")
+logging.basicConfig(level=logging.INFO)
+
+try:
+    from agents.common.github_app_vault import get_installation_token
+except Exception:
+    def get_installation_token(installation_id=None):
+        return os.environ.get("GITHUB_TOKEN")
+
+GITHUB_API = "https://api.github.com"
+
+def _headers(token: str) -> Dict[str, str]:
+    return {"Authorization": f"token {token}", "Accept": "application/vnd.github+json"}
+
+def create_pr(repo: str, title: str, body: str, head: str, base: str = "main", installation_id: Optional[str] = None) -> Dict[str, Any]:
+    token = get_installation_token(installation_id)
+    if not token:
+        raise RuntimeError("No installation token available")
+    url = f"{GITHUB_API}/repos/{repo}/pulls"
+    resp = requests.post(url, headers=_headers(token), json={"title": title, "body": body, "head": head, "base": base}, timeout=10)
+    resp.raise_for_status()
+    return resp.json()
+
+def add_pr_label(repo: str, pr_number: int, label: str, installation_id: Optional[str] = None):
+    token = get_installation_token(installation_id)
+    url = f"{GITHUB_API}/repos/{repo}/issues/{pr_number}/labels"
+    resp = requests.post(url, headers=_headers(token), json={"labels":[label]}, timeout=10)
+    resp.raise_for_status()
+    return resp.json()
+
+def request_review(repo: str, pr_number: int, reviewers: list, installation_id: Optional[str] = None):
+    token = get_installation_token(installation_id)
+    url = f"{GITHUB_API}/repos/{repo}/pulls/{pr_number}/requested_reviewers"
+    resp = requests.post(url, headers=_headers(token), json={"reviewers": reviewers}, timeout=10)
+    resp.raise_for_status()
+    return resp.json()
+
+if __name__ == "__main__":
+    # quick smoke test when running in dev (requires GITHUB_TOKEN fallback)
+    print("GitHub client ready")
+
diff --git a/k8s/manifests/approval-gateway-deployment.yaml b/k8s/manifests/approval-gateway-deployment.yaml
new file mode 100644
index 0000000..7777777
--- /dev/null
+++ b/k8s/manifests/approval-gateway-deployment.yaml
@@ -0,0 +1,160 @@
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-approval-gateway
+  namespace: aegis-ml
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: aegis-approval-gateway
+  template:
+    metadata:
+      labels:
+        app: aegis-approval-gateway
+    spec:
+      serviceAccountName: aegis-agent-sa
+      containers:
+        - name: gateway
+          image: <REGISTRY>/aegis-approval-gateway:latest
+          env:
+            - name: ORCHESTRATOR_WEBHOOK
+              value: "http://orchestrator.aegis-ml.svc.cluster.local:8082/webhook"
+            - name: GITHUB_REPO
+              value: "<OWNER/REPO>"
+          ports:
+            - containerPort: 8080
+          resources:
+            requests:
+              cpu: "200m"
+              memory: "256Mi"
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: aegis-approval-gateway
+  namespace: aegis-ml
+spec:
+  selector:
+    app: aegis-approval-gateway
+  ports:
+    - port: 8080
+      targetPort: 8080
+
diff --git a/sql/003_partition_decision_log.sql b/sql/003_partition_decision_log.sql
new file mode 100644
index 0000000..8888888
--- /dev/null
+++ b/sql/003_partition_decision_log.sql
@@ -0,0 +1,64 @@
+-- Example: create monthly partitioned decision_log (Postgres 12+)
+-- This is an operator-run script; adjust schema names and retention as needed.
+BEGIN;
+
+CREATE TABLE IF NOT EXISTS decision_log_y2025m01 (LIKE decision_log INCLUDING ALL);
+
+-- Example function to route inserts based on created_at - requires trigger setup by operator
+-- Partitioning strategy and retention should be decided by DBA.
+
+COMMIT;
+
+-- Note: for retention, operators can run:
+-- DELETE FROM decision_log WHERE created_at < now() - interval '365 days';
+
diff --git a/k8s/manifests/feast-sync-job.yaml b/k8s/manifests/feast-sync-job.yaml
new file mode 100644
index 0000000..9999999
--- /dev/null
+++ b/k8s/manifests/feast-sync-job.yaml
@@ -0,0 +1,120 @@
+apiVersion: batch/v1
+kind: Job
+metadata:
+  name: aegis-feast-sync
+  namespace: aegis-ml
+spec:
+  template:
+    spec:
+      serviceAccountName: aegis-agent-sa
+      containers:
+        - name: feast-sync
+          image: <REGISTRY>/aegis-feast-sync:latest
+          command: ["python", "/app/feast_sync.py"]
+          env:
+            - name: BATCH_FEATURE_PATH
+              value: "s3://<BUCKET>/features/"
+            - name: FEAST_REDIS_HOST
+              value: "feast-redis.aegis-ml.svc.cluster.local"
+          resources:
+            requests:
+              cpu: "200m"
+              memory: "256Mi"
+      restartPolicy: OnFailure
+
diff --git a/k8s/manifests/labeling-queue-deployment.yaml b/k8s/manifests/labeling-queue-deployment.yaml
new file mode 100644
index 0000000..aaaaaaaa
--- /dev/null
+++ b/k8s/manifests/labeling-queue-deployment.yaml
@@ -0,0 +1,160 @@
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-labeling-queue
+  namespace: aegis-ml
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: aegis-labeling-queue
+  template:
+    metadata:
+      labels:
+        app: aegis-labeling-queue
+    spec:
+      serviceAccountName: aegis-agent-sa
+      containers:
+        - name: labeling-queue
+          image: <REGISTRY>/aegis-labeling-queue:latest
+          env:
+            - name: LABELSTUDIO_URL
+              value: "http://labelstudio.aegis-ml.svc.cluster.local:8080"
+            - name: LAKEFS_API
+              value: "http://lakefs:8000"
+          resources:
+            requests:
+              cpu: "200m"
+              memory: "256Mi"
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: aegis-labeling-queue
+  namespace: aegis-ml
+spec:
+  selector:
+    app: aegis-labeling-queue
+  ports:
+    - port: 8080
+      targetPort: 8080
+
diff --git a/monitoring/prometheus/model_slo_rules_additional.yaml b/monitoring/prometheus/model_slo_rules_additional.yaml
new file mode 100644
index 0000000..bbbbbbbb
--- /dev/null
+++ b/monitoring/prometheus/model_slo_rules_additional.yaml
@@ -0,0 +1,120 @@
+apiVersion: monitoring.coreos.com/v1
+kind: PrometheusRule
+metadata:
+  name: aegis-model-slo-rules-additional
+  namespace: aegis-ml
+spec:
+  groups:
+    - name: aegis-model-slo.additional
+      rules:
+        - alert: ModelDecisionErrorBudgetExceeded
+          expr: increase(aegis_autoexec_errors_total[1h]) > 5
+          for: 10m
+          labels:
+            severity: critical
+          annotations:
+            summary: "Model auto-exec error budget exceeded"
+
+        - alert: FeatureStoreSyncLag
+          expr: increase(feast_sync_lag_seconds[5m]) > 300
+          for: 10m
+          labels:
+            severity: warning
+          annotations:
+            summary: "Feast online store sync lag is high"
+
diff --git a/dr/cross_region_sync_cronjob.yaml b/dr/cross_region_sync_cronjob.yaml
new file mode 100644
index 0000000..cccccccc
--- /dev/null
+++ b/dr/cross_region_sync_cronjob.yaml
@@ -0,0 +1,120 @@
+apiVersion: batch/v1
+kind: CronJob
+metadata:
+  name: aegis-cross-region-sync
+  namespace: aegis-ml
+spec:
+  schedule: "0 2 * * *"  # daily at 02:00
+  jobTemplate:
+    spec:
+      template:
+        spec:
+          serviceAccountName: aegis-agent-sa
+          containers:
+            - name: cr-sync
+              image: <REGISTRY>/aegis-dr-tools:latest
+              command: ["/bin/sh","-c"]
+              args:
+                - |
+                  ./dr/cross_region_sync.sh --src s3://<BUCKET>/models --dst s3://<BACKUP_BUCKET>/models --region us-west-2 --dst-region eu-west-1
+          restartPolicy: OnFailure
+
diff --git a/docs/PRODUCTION_HARDENING_RUNBOOK.md b/docs/PRODUCTION_HARDENING_RUNBOOK.md
new file mode 100644
index 0000000..dddddddd
--- /dev/null
+++ b/docs/PRODUCTION_HARDENING_RUNBOOK.md
@@ -0,0 +1,240 @@
+# Aegis Production Hardening Runbook (secrets, policy, approvals, monitoring, DR)
+
+This runbook bundles the concrete steps to remediate high-impact gaps before enabling production auto-exec.
+
+1) Vault & Secrets Migration (HIGH)
+ - Write GH App PEM to Vault:
+     ./vault/write_github_app_to_vault.sh --pem /tmp/github_app.pem --app-id 12345 --installation-id 67890
+ - Create Vault policy (vault/policies/aegis_agents_policy.hcl) and role binding:
+     vault policy write aegis-agents vault/policies/aegis_agents_policy.hcl
+     vault write auth/kubernetes/role/aegis-agent bound_service_account_names=aegis-agent-sa bound_service_account_namespaces=aegis-ml policies=aegis-agents ttl=1h
+ - Annotate orchestrator and other critical deployments with Vault Injector annotations (see k8s/manifests/orchestrator-deployment-vault.yaml)
+ - Remove plaintext secrets from cluster after injector verification:
+     ./k8s/manifests/remove_plaintext_secrets.sh aegis-ml  (first dry-run; then --apply)
+
+2) OPA Policy Hardening & CI (HIGH)
+ - Place authoritative model metadata: policy/opa/data/models_canonical.json
+ - Add Rego unit tests in policy/opa/tests (agent_policies_more_tests.rego)
+ - Enable policy CI (policy_review.yml) to block PRs that break policy tests
+ - Run local policy smoke:
+     docker run --rm -v "$PWD:/workspace" openpolicyagent/opa:latest test /workspace/policy -v
+
+3) GitHub App Production Integration (HIGH)
+ - Create GitHub App with minimal perms (repository: contents, pull_requests, metadata as needed)
+ - Store PEM in Vault (step 1), configure agents to call agents.common.github_app_vault.get_installation_token()
+ - Replace any PAT usage in CI with short-lived installation tokens
+ - Add auditing: record token uses in decision_log / monitoring
+
+4) Auto-exec Approval Flows (HIGH)
+ - Deploy approval gateway (k8s/manifests/approval-gateway-deployment.yaml)
+ - Wire orchestrator to call the gateway when OPA denies auto-exec; gateway will create PR via agents.common.github_client.create_pr
+ - Ensure CODEOWNERS, branch protection, and required reviewers are configured in target repo(s)
+ - Log approvals to decision_log once PR is merged or reviewer approves
+
+5) Decision Log Indexing & BI (MEDIUM)
+ - Apply DB index migration:
+     kubectl -n aegis-ml exec deploy/aegis-postgres -- psql -U aegis -d aegis -f /sql/002_add_indexes_decision_log.sql
+ - Optionally run tools/decisionlog_to_elastic.py with POSTGRES_URL & ELASTIC_URL to mirror for fast search
+
+6) Feature Store & Labeling (MEDIUM)
+ - Deploy Feast online store and sync job (k8s/manifests/feast-online-deploy.yaml and feast-sync-job.yaml)
+ - Deploy labeling queue (k8s/manifests/labeling-queue-deployment.yaml) and Label Studio integration
+
+7) Monitoring & SLOs (MEDIUM)
+ - Apply PrometheusRule manifests in monitoring/prometheus/*.yaml (model_slo_rules, additional rules)
+ - Import Grafana dashboards and create runbooks for alerts
+
+8) DR & Cross-region (MEDIUM)
+ - Deploy cross-region cronjob (dr/cross_region_sync_cronjob.yaml) to mirror model repos nightly
+ - Periodically run chaos drills and verify restores (use scripts in dr/)
+
+Testing & Validation
+ - Run multiple dry-run cycles (scripts/signoff/run_dry_runs.sh)
+ - Validate OPA policy behavior using policy tests
+ - Verify that Vault injector mounts secrets into pods and that no plaintext secrets remain
+ - Create a non-production PR via approval gateway and ensure CODEOWNERS requested reviewers
+
+Rollback guidance
+ - If Vault injector issues occur, re-annotate deployments and re-create temporary secrets (tight timeframe)
+ - Maintain an operator-runbook and record retention of secrets and tokens
+
+Contact
+ - SRE, Security, and ML leadership should coordinate signoff. Attach artifacts produced by scripts/signoff/collect_signoff_artifacts.sh
+
diff --git a/tests/test_feast_sync_smoke.py b/tests/test_feast_sync_smoke.py
new file mode 100644
index 0000000..eeeeeeee
--- /dev/null
+++ b/tests/test_feast_sync_smoke.py
@@ -0,0 +1,120 @@
+import os
+import pytest
+import requests
+
+FEAST_URL = os.environ.get("FEAST_ONLINE_URL", "http://feast-online.aegis-ml.svc.cluster.local:6566")
+
+def test_feast_online_ping():
+    # Basic smoke test that the Feast online service responds
+    try:
+        r = requests.get(FEAST_URL)
+        assert r.status_code in (200,401,403)
+    except Exception:
+        pytest.skip("Feast online not available")
+
+def test_feast_feature_lookup():
+    # attempt a feature lookup API shape (may require adapting to your Feast deployment)
+    # If not available, skip.
+    key = {"driver_id": "test-driver"}
+    try:
+        r = requests.post(f"{FEAST_URL}/get-online-features", json={"entities":[key],"features":["user:age"]}, timeout=5)
+        assert r.status_code in (200,400,404)
+    except Exception:
+        pytest.skip("Feast lookup not available")
+
