*** Begin Patch
*** Add File:ops/apply_irsa_and_annotate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Apply Terraform IRSA module and annotate Kubernetes ServiceAccounts with the role ARNs.
+# Operator MUST provide terraform/irsa/my.tfvars locally (never commit).
+#
+# Usage:
+#   cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars
+#   # edit terraform/irsa/my.tfvars locally
+#   ./ops/apply_irsa_and_annotate.sh terraform/irsa/my.tfvars
+
+TFVARS=${1:-terraform/irsa/my.tfvars}
+TFDIR="terraform/irsa"
+
+if [ ! -f "${TFVARS}" ]; then
+  echo "ERROR: tfvars not found at ${TFVARS}"
+  exit 2
+fi
+
+echo "[IRSA] Running terraform in ${TFDIR} with ${TFVARS}"
+pushd "${TFDIR}" >/dev/null
+terraform init -input=false
+terraform plan -input=false -var-file="${TFVARS}" -out=tfplan
+terraform apply -input=false -auto-approve tfplan
+terraform output -json > /tmp/irsa_outputs.json
+popd >/dev/null
+
+echo "[IRSA] Terraform outputs written to /tmp/irsa_outputs.json"
+
+if [ -f /tmp/irsa_outputs.json ]; then
+  if [ -x "${PWD}/terraform/irsa/irsa_annotate_sa.sh" ]; then
+    echo "[IRSA] Annotating SAs via terraform/irsa/irsa_annotate_sa.sh"
+    bash terraform/irsa/irsa_annotate_sa.sh /tmp/irsa_outputs.json
+  else
+    echo "[IRSA] Annotation helper terraform/irsa/irsa_annotate_sa.sh missing or not executable."
+    echo "Run manual annotations using values from /tmp/irsa_outputs.json"
+  fi
+else
+  echo "[IRSA] No terraform outputs found at /tmp/irsa_outputs.json — cannot annotate SAs"
+fi
+
+echo "[IRSA] Done."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/terraform_irsa_apply.yml
+name: Terraform IRSA Plan & Apply (OIDC)
+
+on:
+  workflow_dispatch:
+    inputs:
+      auto_approve:
+        description: "Set to true to auto-apply"
+        required: false
+        default: "false"
+
+jobs:
+  plan:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup Terraform
+        uses: hashicorp/setup-terraform@v2
+        with:
+          terraform_version: 1.5.0
+      - name: Configure AWS via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Terraform init & plan
+        working-directory: terraform/irsa
+        run: |
+          terraform init -input=false
+          terraform plan -input=false -var-file=my.tfvars -out=tfplan
+      - name: Upload tfplan
+        uses: actions/upload-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+
+  apply:
+    needs: plan
+    if: ${{ github.event.inputs.auto_approve == 'true' }}
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+    steps:
+      - uses: actions/checkout@v4
+      - name: Configure AWS via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.TERRAFORM_OIDC_ROLE }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Download tfplan
+        uses: actions/download-artifact@v4
+        with:
+          name: irsa-tfplan
+          path: terraform/irsa/tfplan
+      - name: Terraform apply
+        working-directory: terraform/irsa
+        run: terraform apply -input=false -auto-approve tfplan
+
*** End Patch
*** Begin Patch
*** Add File:ops/provision_github_secrets_and_externalsecrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Provision GitHub repository secrets (gh CLI) and apply ExternalSecrets manifests.
+# Required environment variables:
+#   REPO, COSIGN_KMS_ARN, REKOR_URL, EVIDENCE_BUCKET, MLFLOW_TRACKING_URI
+# Optional:
+#   AWS_ROLE_TO_ASSUME, PROVIDER_API_KEYS_JSON, GITHUB_TOKEN (for some operations), NAMESPACE (default: aegis)
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+NAMESPACE=${NAMESPACE:-aegis}
+
+required=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI)
+for v in "${required[@]}"; do
+  if [ -z "${!v:-}" ]; then
+    echo "ERROR: env var ${v} must be set"
+    exit 2
+  fi
+done
+
+echo "[SECRETS] Creating GitHub secrets in ${REPO}"
+gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+gh secret set EVIDENCE_BUCKET --repo "${REPO}" --body "${EVIDENCE_BUCKET}"
+gh secret set MLFLOW_TRACKING_URI --repo "${REPO}" --body "${MLFLOW_TRACKING_URI}"
+if [ -n "${AWS_ROLE_TO_ASSUME:-}" ]; then
+  gh secret set AWS_ROLE_TO_ASSUME --repo "${REPO}" --body "${AWS_ROLE_TO_ASSUME}"
+fi
+if [ -n "${PROVIDER_API_KEYS_JSON:-}" ]; then
+  gh secret set PROVIDER_API_KEYS_JSON --repo "${REPO}" --body "${PROVIDER_API_KEYS_JSON}"
+fi
+
+echo "[SECRETS] Applying ExternalSecrets manifests to k8s"
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/secretstore.aws.yaml || true
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/externalsecret_runtime_values.yaml || true
+
+echo "[SECRETS] Done. Verify: gh secret list --repo ${REPO} and kubectl -n ${NAMESPACE} get externalsecret"
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/secretstore.aws.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: SecretStore
+metadata:
+  name: aws-secrets-manager
+  namespace: aegis
+spec:
+  provider:
+    aws:
+      service: SecretsManager
+      region: REPLACE_AWS_REGION
+      auth:
+        jwt:
+          serviceAccountRef:
+            name: externalsecrets-sa
+            namespace: aegis
+---
+# Note: Create IAM role annotated on externalsecrets-sa with permissions to read Secrets Manager
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/externalsecret_runtime_values.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: aegis-runtime-values
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: aegis-runtime-secrets
+    creationPolicy: Owner
+  data:
+    - secretKey: COSIGN_KMS_ARN
+      remoteRef:
+        key: "aegis/cosign"
+        property: "kms_arn"
+    - secretKey: REKOR_URL
+      remoteRef:
+        key: "aegis/rekor"
+        property: "rekor_url"
+    - secretKey: MLFLOW_TRACKING_URI
+      remoteRef:
+        key: "aegis/mlflow"
+        property: "tracking_uri"
+    - secretKey: GITHUB_TOKEN
+      remoteRef:
+        key: "gitops/github"
+        property: "token"
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_runtime_stack.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install runtime services required by Aegis:
+#  - Argo Workflows
+#  - ArgoCD (Helm)
+#  - Prometheus (kube-prometheus-stack)
+#  - ExternalSecrets operator
+#  - Istio (demo profile) and Knative (optional)
+#
+echo "[RUNTIME] Installing Argo Workflows..."
+kubectl create namespace argo --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/stable/manifests/install.yaml
+
+echo "[RUNTIME] Installing ArgoCD via Helm..."
+bash ops/install_argocd_helm.sh
+
+echo "[RUNTIME] Installing Prometheus (kube-prometheus-stack via Helm)..."
+helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
+helm repo update
+kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install kube-prom prometheus-community/kube-prometheus-stack -n monitoring --wait
+
+echo "[RUNTIME] Installing ExternalSecrets operator..."
+helm repo add external-secrets https://external-secrets.github.io/kubernetes-external-secrets/ || true
+helm repo update
+kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
+helm upgrade --install external-secrets external-secrets/kubernetes-external-secrets -n external-secrets --wait
+
+echo "[RUNTIME] Installing Istio (demo); Knative optional..."
+bash istio/install_istio.sh || true
+bash knative/install_knative.sh || true
+
+echo "[RUNTIME] Runtime stack installed. Confirm pods in argo, argocd, monitoring, external-secrets namespaces."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/ci_registry_kms_validation.yml
+name: CI — Registry & KMS permissions validation
+
+on:
+  workflow_dispatch:
+    inputs:
+      ecr_registry:
+        description: "ECR registry (optional)"
+        required: false
+
+jobs:
+  validate:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+    steps:
+      - name: Configure AWS via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Validate KMS & ECR
+        run: |
+          if [ -z "${{ secrets.COSIGN_KMS_ARN }}" ]; then
+            echo "COSIGN_KMS_ARN not set; fail"
+            exit 1
+          fi
+          aws kms describe-key --key-id "${{ secrets.COSIGN_KMS_ARN }}"
+          if [ -n "${{ github.event.inputs.ecr_registry }}" ]; then
+            aws ecr get-authorization-token --registry-ids "$(echo ${{ github.event.inputs.ecr_registry }} | cut -d. -f1)"
+            echo "ECR auth OK"
+          fi
+
*** End Patch
*** Begin Patch
*** Add File:ops/deploy_promoter_and_metricproxy.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Deploy metric-proxy and gitops promoter into the cluster.
+# Provide GITHUB_TOKEN env var to create the in-cluster promoter secret.
+#
+NAMESPACE=${NAMESPACE:-aegis}
+PROM_URL=${PROM_URL:-"REPLACE_PROMETHEUS_INTERNAL_URL"}
+
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+echo "[DEPLOY] Applying metric-proxy manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/metric-proxy-deployment.yaml
+kubectl -n "${NAMESPACE}" patch deployment metric-proxy --patch "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"proxy\",\"env\":[{\"name\":\"PROMETHEUS_URL\",\"value\":\"${PROM_URL}\"}]}]}}}}"
+
+echo "[DEPLOY] Applying gitops-promoter manifests..."
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-configmap.yaml
+kubectl apply -n "${NAMESPACE}" -f ops/gitops-promoter-deployment.yaml
+
+if [ -n "${GITHUB_TOKEN:-}" ]; then
+  kubectl -n "${NAMESPACE}" create secret generic gitops-promoter-secret --from-literal=github_token="${GITHUB_TOKEN}" --dry-run=client -o yaml | kubectl apply -f -
+  echo "[DEPLOY] gitops-promoter-secret created."
+else
+  echo "[DEPLOY] GITHUB_TOKEN not provided; create gitops-promoter-secret manually to enable PR creation."
+fi
+
+echo "[DEPLOY] Metric-proxy & promoter deployment complete."
+
*** End Patch
*** Begin Patch
*** Add File:ops/promoter_rbac.yaml
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: gitops-promoter
+  namespace: aegis
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: gitops-promoter
+  namespace: aegis
+rules:
+  - apiGroups: [""]
+    resources: ["configmaps"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get"]
+  - apiGroups: ["apps"]
+    resources: ["deployments"]
+    verbs: ["get", "list"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: gitops-promoter-binding
+  namespace: aegis
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: Role
+  name: gitops-promoter
+subjects:
+  - kind: ServiceAccount
+    name: gitops-promoter
+    namespace: aegis
+
+# Note: Promoter uses GitHub token (secret) to operate; limit token scope to only necessary repos & permissions.
+
*** End Patch
*** Begin Patch
*** Add File:argocd/application-gitops-staging.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Application
+metadata:
+  name: aegis-staging
+  namespace: argocd
+spec:
+  project: default
+  source:
+    repoURL: 'https://github.com/REPLACE_GITOPS_OWNER/REPLACE_GITOPS_REPO.git'
+    targetRevision: HEAD
+    path: 'overlays/staging'
+  destination:
+    server: 'https://kubernetes.default.svc'
+    namespace: aegis
+  syncPolicy:
+    automated:
+      prune: true
+      selfHeal: true
+    syncOptions:
+      - CreateNamespace=true
+      - ApplyOutOfSyncOnly=true
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_gatekeeper_and_set_protection.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Gatekeeper constraints and configure branch protection and required checks.
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+echo "[GOV] Installing Gatekeeper..."
+kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+sleep 5
+kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml || true
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "[GOV] GITHUB_TOKEN not set; skipping branch protection."
+  exit 0
+fi
+
+echo "[GOV] Setting branch protection on ${REPO}:${BRANCH}"
+required_contexts='["sanitizer","ci_train_validate_register","image_build_cosign"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "[GOV] Gatekeeper installed and branch protection configured."
+
*** End Patch
*** Begin Patch
*** Add File:ops/upload_legal_signoff_and_enforce_checks.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Upload legal signoff to S3 and update branch protection to require sanitizer and CI checks.
+#
+FILE=${1:-ops/legal_signoff.md}
+EVIDENCE_BUCKET=${EVIDENCE_BUCKET:-REPLACE_EVIDENCE_BUCKET}
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${BRANCH:-main}
+
+if [ ! -f "${FILE}" ]; then
+  echo "ERROR: Legal signoff file not found: ${FILE}"
+  exit 2
+fi
+
+echo "[GOV] Uploading legal signoff to s3://${EVIDENCE_BUCKET}/legal_signoff/"
+aws s3 cp "${FILE}" "s3://${EVIDENCE_BUCKET}/legal_signoff/$(basename "${FILE}")"
+
+if [ -z "${GITHUB_TOKEN:-}" ]; then
+  echo "[GOV] GITHUB_TOKEN not set; skipping branch protection update."
+  exit 0
+fi
+
+echo "[GOV] Enforcing sanitizer + CI checks on ${REPO}:${BRANCH}"
+required_contexts='["sanitizer","ci_train_validate_register","secret-and-deploy-preflight"]'
+gh api --method PUT /repos/${REPO}/branches/${BRANCH}/protection -f required_status_checks.strict=true -f "required_status_checks.contexts=${required_contexts}" -f enforce_admins=true -f required_pull_request_reviews.required_approving_review_count=1
+
+echo "[GOV] Legal signoff uploaded and checks enforced."
+
*** End Patch
*** Begin Patch
*** Add File:ops/tune_and_validate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Tune SLOs, validate metric queries via metric-proxy, and run cost/budget guard rail check.
+#
+P95=${1:-0.5}
+ERROR_RATE=${2:-0.02}
+WINDOW=${3:-60}
+METRIC_PROXY=${METRIC_PROXY:-http://metric-proxy.aegis.svc.cluster.local:8080}
+
+echo "[TUNE] Patching SLO configmap (aegis-slo-config)"
+kubectl -n aegis create configmap aegis-slo-config --from-literal=p95_latency_threshold_seconds="${P95}" --from-literal=canary_error_rate_threshold="${ERROR_RATE}" --from-literal=canary_success_window_minutes="${WINDOW}" -o yaml --dry-run=client | kubectl apply -f -
+
+echo "[TUNE] Querying metric-proxy for sample p95 latency"
+QUERY='histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job="kserve",env="prod"}[5m])) by (le))'
+ENCODED=$(python3 - <<PY
+import urllib.parse
+print(urllib.parse.quote('''${QUERY}'''))
+PY
+)
+curl -s "${METRIC_PROXY}/api/v1/query?query=${ENCODED}" | jq .
+
+echo "[TUNE] Running cost guard-rail check (placeholder)"
+if [ -x ./ops/qpu_cost_estimator_braket_integration.py ]; then
+  python3 ./ops/qpu_cost_estimator_braket_integration.py --dry-run || true
+else
+  echo "[TUNE] No cost estimator found; please run your cost validation tool."
+fi
+
+echo "[TUNE] Tune & validation complete. Adjust thresholds and re-run tests as needed."
+
*** End Patch
*** Begin Patch
*** Add File:docs/operational_hardening.md
+# Operational hardening checklist for Aegis
+
+This document lists operational hardening actions to make the Aegis platform production ready.
+
+1) Least-privilege IAM
+  - Restrict Terraform-created roles to minimal permissions (KMS sign + ECR push only for CI role).
+  - Scope provider roles annotated to SAs to only the APIs they need.
+
+2) Secret rotation & ExternalSecrets
+  - Use ExternalSecrets backed by AWS Secrets Manager or Vault.
+  - Automate rotation and test during rotation events.
+
+3) Monitoring & alerting
+  - Ensure Prometheus alerts for failed promotions, high error rates, retrain failures.
+  - Hook alerts to on-call and PagerDuty.
+
+4) Automated testing & rollback
+  - Simulate failover: test canary rollback path and ArgoCD self-heal.
+  - Add end-to-end integration tests that run on staging overlays.
+
+5) Cost & budget guard rails
+  - Ensure cost estimator runs prior to scheduling expensive QPU jobs.
+  - Enforce budget checks in workflows (reject automatic runs above budget).
+
+6) Governance
+  - Gatekeeper constraints for QPU runs and legal signoff requirement.
+  - Branch protection requiring sanitizer and CI checks before merging.
+
+7) Access controls
+  - Limit GitHub token scope for promoter and rotate tokens periodically.
+  - Use OIDC for Actions where possible instead of long-lived credentials.
+
+8) Disaster recovery
+  - Back up gitops repo, S3 evidence bucket and critical manifests.
+  - Scripted restore steps for ArgoCD and Prometheus.
+
*** End Patch
*** End Patch
