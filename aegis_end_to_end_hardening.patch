*** Begin Patch
*** Add File:terraform/aegis_production/main.tf
+terraform {
+  required_version = ">= 1.2"
+  required_providers {
+    aws = {
+      source  = "hashicorp/aws"
+      version = "~> 5.0"
+    }
+  }
+}
+
+provider "aws" {
+  region = var.aws_region
+}
+
+resource "aws_kms_key" "aegis" {
+  description             = "Aegis KMS key for auto-unseal and cosign"
+  deletion_window_in_days = 30
+}
+
+resource "aws_s3_bucket" "evidence" {
+  bucket = var.evidence_bucket
+  acl    = "private"
+  versioning { enabled = true }
+  server_side_encryption_configuration {
+    rule {
+      apply_server_side_encryption_by_default {
+        sse_algorithm     = "aws:kms"
+        kms_master_key_id = aws_kms_key.aegis.arn
+      }
+    }
+  }
+  lifecycle_rule {
+    enabled = true
+    expiration {
+      days = 3650
+    }
+  }
+}
+
+resource "aws_s3_bucket" "models" {
+  bucket = var.model_bucket
+  acl    = "private"
+  versioning { enabled = true }
+  server_side_encryption_configuration {
+    rule {
+      apply_server_side_encryption_by_default {
+        sse_algorithm     = "aws:kms"
+        kms_master_key_id = aws_kms_key.aegis.arn
+      }
+    }
+  }
+}
+
+output "kms_key_arn" { value = aws_kms_key.aegis.arn }
+output "evidence_bucket" { value = aws_s3_bucket.evidence.bucket }
+output "model_bucket" { value = aws_s3_bucket.models.bucket }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/aegis_production/variables.tf
+variable "aws_region" {
+  type    = string
+  default = "us-west-2"
+}
+variable "evidence_bucket" { type = string }
+variable "model_bucket" { type = string }
+
*** End Patch
*** Begin Patch
*** Add File:deploy/rekor/postgres-statefulset.yaml
+apiVersion: v1
+kind: Secret
+metadata:
+  name: rekor-postgres-secret
+  namespace: aegis
+type: Opaque
+stringData:
+  postgres-user: rekor
+  postgres-password: "REPLACE_WITH_STRONG_PASSWORD"
+
+---
+apiVersion: apps/v1
+kind: StatefulSet
+metadata:
+  name: rekor-postgres
+  namespace: aegis
+spec:
+  serviceName: rekor-postgres
+  replicas: 1
+  selector:
+    matchLabels:
+      app: rekor-postgres
+  template:
+    metadata:
+      labels:
+        app: rekor-postgres
+    spec:
+      containers:
+        - name: postgres
+          image: postgres:15
+          env:
+            - name: POSTGRES_USER
+              valueFrom:
+                secretKeyRef:
+                  name: rekor-postgres-secret
+                  key: postgres-user
+            - name: POSTGRES_PASSWORD
+              valueFrom:
+                secretKeyRef:
+                  name: rekor-postgres-secret
+                  key: postgres-password
+          ports:
+            - containerPort: 5432
+          volumeMounts:
+            - name: pgdata
+              mountPath: /var/lib/postgresql/data
+  volumeClaimTemplates:
+    - metadata:
+        name: pgdata
+      spec:
+        accessModes: ["ReadWriteOnce"]
+        resources:
+          requests:
+            storage: 20Gi
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: rekor-postgres
+  namespace: aegis
+spec:
+  ports:
+    - port: 5432
+      targetPort: 5432
+  selector:
+    app: rekor-postgres
+
*** End Patch
*** Begin Patch
*** Add File:deploy/rekor/rekor-deployment-postgres.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: rekor
+  namespace: aegis
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: rekor
+  template:
+    metadata:
+      labels:
+        app: rekor
+    spec:
+      containers:
+        - name: rekor
+          image: sigstore/rekor-server:latest
+          env:
+            - name: REKOR_STORAGE_TYPE
+              value: "postgres"
+            - name: REKOR_DATABASE_URL
+              value: "postgres://rekor:REPLACE_WITH_STRONG_PASSWORD@rekor-postgres.aegis.svc:5432/rekordb"
+            - name: REKOR_API_PORT
+              value: "3000"
+          ports:
+            - containerPort: 3000
+          readinessProbe:
+            httpGet:
+              path: /health
+              port: 3000
+            initialDelaySeconds: 10
+            periodSeconds: 10
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: rekor
+  namespace: aegis
+spec:
+  selector:
+    app: rekor
+  ports:
+    - name: http
+      port: 3000
+      targetPort: 3000
+
*** End Patch
*** Begin Patch
*** Add File:ops/signing-proxy/hardened-deployment.yaml
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: aegis
+
+---
+apiVersion: v1
+kind: Secret
+metadata:
+  name: signing-proxy-tls
+  namespace: aegis
+type: kubernetes.io/tls
+data:
+  tls.crt: "REPLACE_BASE64_CERT"
+  tls.key: "REPLACE_BASE64_KEY"
+
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: signing-proxy
+  namespace: aegis
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: signing-proxy
+  template:
+    metadata:
+      labels:
+        app: signing-proxy
+    spec:
+      serviceAccountName: signing-proxy-sa
+      containers:
+        - name: signing-proxy
+          image: registry.example.com/aegis/signing-proxy:latest
+          args:
+            - "--addr=0.0.0.0:8443"
+            - "--tls-cert=/tls/tls.crt"
+            - "--tls-key=/tls/tls.key"
+            - "--client-ca=/tls/clients-ca.crt"
+            - "--vault-addr=https://vault.aegis.svc:8200"
+            - "--rekor-url=https://rekor.aegis.svc:3000"
+            - "--audit-bucket=${EVIDENCE_BUCKET}"
+          ports:
+            - containerPort: 8443
+          volumeMounts:
+            - name: tls
+              mountPath: /tls
+              readOnly: true
+      volumes:
+        - name: tls
+          secret:
+            secretName: signing-proxy-tls
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: signing-proxy
+  namespace: aegis
+spec:
+  selector:
+    app: signing-proxy
+  ports:
+    - name: https
+      port: 8443
+      targetPort: 8443
+
+---
+apiVersion: networking.k8s.io/v1
+kind: NetworkPolicy
+metadata:
+  name: signing-proxy-allow-ci
+  namespace: aegis
+spec:
+  podSelector:
+    matchLabels:
+      app: signing-proxy
+  ingress:
+    - from:
+        - namespaceSelector:
+            matchLabels:
+              name: cicd
+        - podSelector:
+            matchLabels:
+              app: github-runner
+      ports:
+        - protocol: TCP
+          port: 8443
+  policyTypes:
+    - Ingress
+
*** End Patch
*** Begin Patch
*** Add File:ops/signing-proxy/service-account-rbac.yaml
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: signing-proxy-sa
+  namespace: aegis
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: Role
+metadata:
+  name: signing-proxy-role
+  namespace: aegis
+rules:
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get"]
+
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: RoleBinding
+metadata:
+  name: signing-proxy-rb
+  namespace: aegis
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: Role
+  name: signing-proxy-role
+subjects:
+  - kind: ServiceAccount
+    name: signing-proxy-sa
+    namespace: aegis
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/cosign_mtls_request.yml
+name: Cosign mTLS Signing Request (via signing-proxy)
+on:
+  workflow_dispatch:
+
+jobs:
+  request-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Prepare client cert & key
+        run: |
+          echo "${{ secrets.SIGNING_CLIENT_CERT }}" > /tmp/client.crt
+          echo "${{ secrets.SIGNING_CLIENT_KEY }}"  > /tmp/client.key
+          echo "${{ secrets.SIGNING_CLIENT_CA }}"   > /tmp/client_ca.crt
+          chmod 600 /tmp/client.key
+      - name: Request signature
+        env:
+          SIGNING_PROXY_URL: ${{ secrets.SIGNING_PROXY_URL }}
+          IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+        run: |
+          curl --cert /tmp/client.crt --key /tmp/client.key --cacert /tmp/client_ca.crt \
+            -H "Content-Type: application/json" \
+            -d "{\"artifact\": \"${IMAGE_NAME}\"}" \
+            "${SIGNING_PROXY_URL}/sign" -o /tmp/sign_res.json -sS || (cat /tmp/sign_res.json && exit 1)
+          cat /tmp/sign_res.json
+      - name: Upload signature to evidence bucket
+        env:
+          EVIDENCE_BUCKET: ${{ secrets.EVIDENCE_BUCKET }}
+        run: |
+          if [ -f /tmp/sign_res.json ]; then
+            aws s3 cp /tmp/sign_res.json s3://${EVIDENCE_BUCKET}/signatures/${{ github.sha }}-sign.json || true
+          fi
+
*** End Patch
*** Begin Patch
*** Add File:artifacts/boot_manifest_template.json
+{
+  "artifact": "model.onnx",
+  "version": "0.0.0",
+  "format": "onnx",
+  "size": 0,
+  "sha256": "",
+  "signature": "",
+  "sbom": "sbom.spdx.json",
+  "trivy_report": "trivy_report.json",
+  "provenance": {
+    "git_sha": "",
+    "build_time": "",
+    "builder": "aegis-ci"
+  },
+  "apply_instructions": {
+    "type": "delta",
+    "rollback": "preserve_previous_artifact"
+  },
+  "acceptance_criteria": {
+    "latency_ms": 50,
+    "accuracy_threshold": 0.90,
+    "deadline_misses_allowed": 0
+  }
+}
+
*** End Patch
*** Begin Patch
*** Add File:argo/promotion/promotion_workflow.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Workflow
+metadata:
+  generateName: artifact-promotion-
+  namespace: aegis
+spec:
+  entrypoint: promote-artifact
+  templates:
+    - name: promote-artifact
+      inputs:
+        parameters:
+          - name: manifest-s3
+      steps:
+        - - name: download-manifest
+            template: download-manifest
+            arguments:
+              parameters:
+                - name: manifest-s3
+                  value: "{{inputs.parameters.manifest-s3}}"
+        - - name: verify-signature
+            template: verify-signature
+        - - name: run-verification
+            template: run-verification
+        - - name: attach-evidence
+            template: attach-evidence
+            arguments:
+              parameters:
+                - name: manifest
+                  value: "{{steps.download-manifest.outputs.parameters.manifest}}"
+
+    - name: download-manifest
+      inputs:
+        parameters:
+          - name: manifest-s3
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - pip install boto3 || true
+            python3 - <<PY
+import boto3,sys
+src="{{inputs.parameters.manifest-s3}}"
+parts=src[5:].split("/",1)
+bucket,key=parts[0],parts[1]
+boto3.client("s3").download_file(bucket,key,"/tmp/manifest.json")
+print("/tmp/manifest.json")
+PY
+      outputs:
+        parameters:
+          - name: manifest
+            valueFrom:
+              path: /tmp/manifest.json
+
+    - name: verify-signature
+      container:
+        image: sigstore/cosign:latest
+        command: [sh, -c]
+        args:
+          - echo "Verifying cosign attestation for manifest (operator: adjust to your schema)"; sleep 1
+
+    - name: run-verification
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - echo "Running verification pipelines (SIL->PIL->HIL) for artifact and collecting results"; sleep 2
+
+    - name: attach-evidence
+      inputs:
+        parameters:
+          - name: manifest
+      container:
+        image: python:3.10-slim
+        command: [sh, -c]
+        args:
+          - python3 scripts/evidence/attach_and_sign.py --manifest "{{inputs.parameters.manifest}}" --out /tmp/evidence_bundle.json || true
+            cat /tmp/evidence_bundle.json || true
+
*** End Patch
*** Begin Patch
*** Add File:scripts/evidence/attach_and_sign.py
+#!/usr/bin/env python3
+"""
+Collect evidence artifacts (SBOM, sim coverage, pil logs, manifest), bundle, sign (cosign KMS) and upload to EVIDENCE_BUCKET.
+"""
+import argparse, json, subprocess, os, tempfile
+
+def bundle_evidence(manifest_path, out):
+    tmp = tempfile.mkdtemp()
+    try:
+        m = json.load(open(manifest_path))
+    except:
+        m = {}
+    subprocess.run(["cp", manifest_path, os.path.join(tmp, "manifest.json")])
+    for p in ["sbom.spdx.json","trivy_report.json","/tmp/sim_coverage.json","/tmp/pil_result.json"]:
+        if os.path.exists(p):
+            subprocess.run(["cp", p, tmp])
+    tar = out
+    subprocess.run(["tar","czf",tar,"-C",tmp,"."], check=True)
+    return tar
+
+def sign_and_upload(tar_path, evidence_bucket):
+    if os.environ.get("COSIGN_KMS_KEY_ARN"):
+        subprocess.run(["cosign","sign","--key",f"awskms://{os.environ['COSIGN_KMS_KEY_ARN']}",tar_path], check=False)
+    if evidence_bucket:
+        subprocess.run(["aws","s3","cp",tar_path,f"s3://{evidence_bucket}/evidence/"], check=False)
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--manifest", required=True)
+    p.add_argument("--out", default="/tmp/evidence_bundle.tgz")
+    args = p.parse_args()
+    tar = bundle_evidence(args.manifest, args.out)
+    sign_and_upload(tar, os.environ.get("EVIDENCE_BUCKET",""))
+    print("Wrote evidence bundle", tar)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:deploy/vault/ha-values-raft.yaml
+# Vault Helm values for HA using Raft storage with KMS auto-unseal and TLS via cert-manager
+server:
+  ha:
+    enabled: true
+  dataStorage:
+    enabled: false
+  standalone:
+    enabled: false
+tls:
+  enabled: true
+  certManager:
+    enabled: true
+    issuerRef:
+      name: vault-ca-issuer
+      kind: ClusterIssuer
+unsealer:
+  aws:
+    enabled: true
+    region: "us-west-2"
+    kmsKeyId: "" # fill with KMS ARN / let terraform output
+server:
+  raft:
+    enabled: true
+resources:
+  requests:
+    cpu: 250m
+    memory: 512Mi
+  limits:
+    cpu: 1
+    memory: 2Gi
+
*** End Patch
*** Begin Patch
*** Add File:deploy/vault/cert-manager-issuer-and-ca.yaml
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: vault-ca-issuer
+spec:
+  selfSigned: {}
+
+---
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: vault-server-tls
+  namespace: aegis
+spec:
+  secretName: vault-server-tls
+  commonName: vault.aegis.svc
+  dnsNames:
+    - vault.aegis.svc
+  issuerRef:
+    name: vault-ca-issuer
+    kind: ClusterIssuer
+
*** End Patch
*** Begin Patch
*** Add File:gatekeeper/staging/enable_dryrun_constraint.yaml
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: aegis-staging
+  labels:
+    env: staging
+
+---
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: RequireCosignAttestation
+metadata:
+  name: cosign-required-staging
+spec:
+  enforcementAction: dryrun
+  match:
+    kinds:
+      - apiGroups: [""]
+        kinds: ["Pod"]
+    namespaces:
+      - "aegis-staging"
+
*** End Patch
*** Begin Patch
*** Add File:gatekeeper/automation/gatekeeper_dryrun_check_and_promote.sh
+#!/usr/bin/env bash
+set -euo pipefail
+PROMOTE=false
+while [[ $# -gt 0 ]]; do
+  case $1 in
+    --constraint) CONSTRAINT="$2"; shift 2;;
+    --namespace) NS="$2"; shift 2;;
+    --promote) PROMOTE=true; shift;;
+    *) shift;;
+  esac
+done
+
+if [ -z "${CONSTRAINT:-}" ] || [ -z "${NS:-}" ]; then
+  echo "Require --constraint and --namespace"
+  exit 2
+fi
+
+echo "Running Gatekeeper dry-run evaluation for constraint ${CONSTRAINT} in namespace ${NS}"
+cat > /tmp/gk_test_pod.yaml <<EOF
+apiVersion: v1
+kind: Pod
+metadata:
+  name: gatekeeper-test-pod
+  namespace: ${NS}
+spec:
+  containers:
+    - name: nginx
+      image: nginx:alpine
+EOF
+
+set +e
+kubectl apply -f /tmp/gk_test_pod.yaml
+RC=$?
+set -e
+
+if [ $RC -eq 0 ]; then
+  echo "Test pod created successfully in dry-run. Gatekeeper NOT blocking. Please review constraint or workload."
+  kubectl delete pod -n "${NS}" gatekeeper-test-pod || true
+else
+  echo "Pod was rejected (good) — Gatekeeper constraint likely effective in dry-run."
+fi
+
+if [ "${PROMOTE}" = true ]; then
+  echo "Promoting constraint ${CONSTRAINT} to enforce mode"
+  kubectl patch constraint "${CONSTRAINT}" --type='merge' -p '{"spec":{"enforcementAction":"deny"}}' || { echo "Patch failed"; exit 1; }
+  echo "Constraint promoted to deny"
+fi
+
+rm -f /tmp/gk_test_pod.yaml
+
*** End Patch
*** Begin Patch
*** Add File:docs/APPLY_GUIDE_QUICKSTART.md
+# Aegis End-to-End Hardening — Quickstart Apply Guide
+
+This guide uses the defaults you confirmed (AWS KMS & S3, cosign KMS, Vault HA (Raft), Rekor Postgres in-cluster). Replace placeholders before applying.
+
+Prereqs:
+- kubectl + helm + terraform + aws CLI + velero CLI on operator machine
+- Kubernetes cluster with sufficient nodes and storage class
+- GitHub repo secrets: EVIDENCE_BUCKET, MODEL_ARTIFACT_BUCKET, AWS_REGION, COSIGN_KMS_KEY_ARN, SIGNING_PROXY_URL, SIGNING_CLIENT_CERT/KEY/CA (for mTLS), REKOR_URL
+
+1) Provision infra (Terraform)
+   cd terraform/aegis_production
+   terraform init
+   terraform apply -var="evidence_bucket=<your-evidence>" -var="model_bucket=<your-model-bucket>"
+   record outputs: kms_key_arn, evidence_bucket, model_bucket
+
+2) Vault HA
+   - Install cert-manager (follow upstream docs)
+   - kubectl apply -f deploy/vault/cert-manager-issuer-and-ca.yaml
+   - Edit deploy/vault/ha-values-raft.yaml: paste kmsKeyId with terraform output
+   - helm upgrade --install vault hashicorp/vault -n aegis -f deploy/vault/ha-values-raft.yaml
+   - (Optional) run deploy/vault/init-vault-job.yaml to verify connectivity
+
+3) Rekor + Postgres
+   - kubectl apply -f deploy/rekor/postgres-statefulset.yaml
+   - kubectl apply -f deploy/rekor/rekor-deployment-postgres.yaml
+   - ensure rekor service is reachable at https://rekor.aegis.svc:3000
+
+4) Signing-proxy (mTLS)
+   - Create TLS secret signing-proxy-tls in aegis namespace (replace base64 placeholders in the manifest)
+   - kubectl apply -f ops/signing-proxy/hardened-deployment.yaml
+   - Create service account & RBAC: kubectl apply -f ops/signing-proxy/service-account-rbac.yaml
+   - Create network policies to restrict access if needed
+   - Configure GitHub secrets for SIGNING_PROXY_URL and SIGNING_CLIENT_CERT/KEY/CA; test .github/workflows/cosign_mtls_request.yml
+
+5) Gatekeeper dry-run
+   - kubectl apply -f gatekeeper/staging/enable_dryrun_constraint.yaml
+   - run gatekeeper/automation/gatekeeper_dryrun_check_and_promote.sh --constraint cosign-required-staging --namespace aegis-staging
+   - tune constraints before promotion
+
+6) CI & Promotion
+   - Ensure .github/workflows/ci_build_sign.yml has secrets set (EVIDENCE_BUCKET, MODEL_ARTIFACT_BUCKET, COSIGN_KMS_KEY_ARN, AWS_REGION, REKOR_URL)
+   - Merge a test change to main; verify SBOM & Trivy artifacts and cosign KMS signing are performed. Confirm Rekor entry.
+   - Use Argo promotion (argo/promotion/promotion_workflow.yaml) to execute promotion and attach evidence.
+
+7) Verification & Backup Drill
+   - Submit Argo verification (argo/verification/full_pipeline_workflow.yaml) to exercise SIL→PIL and capture evidence.
+   - Run scripts/ops/run_restore_drill.sh to validate Velero restore.
+
+Notes & next steps:
+- Replace secret placeholders and rotate credentials after first run.
+- Tune Falco → sidekick for SIEM integration and suppressions.
+- Consider moving Rekor Postgres to RDS for long-term HA and backup.
+
*** End Patch
*** End Patch
