*** Begin Patch
*** Add File: governance/opa/policies/multi_sig.rego
+package aegis.policies
+
+# Multi-sig and approval policies for critical automation actions.
+# Input expected:
+# {
+#   "action": "hsm_rotate" | "promote_model" | "deploy_fleet" | ...,
+#   "approvers": ["alice","bob"],
+#   "required": 2
+# }
+
+default allow = false
+
+allow {
+  input.action != "hsm_rotate"  # non-critical actions allowed by other controls (example)
+}
+
+allow {
+  input.action == "hsm_rotate"
+  count_approvers(input.approvers) >= input.required
+}
+
+# Example: require at least one approver for model promotions (tune as needed)
+allow {
+  input.action == "promote_model"
+  count_approvers(input.approvers) >= 1
+}
+
+count_approvers(arr) = n {
+  n := count({v | arr[_] == v})
+}
+
*** End File
*** Add File: governance/opa/opa_deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: opa-server
+  namespace: ops
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: opa
+  template:
+    metadata:
+      labels:
+        app: opa
+    spec:
+      containers:
+      - name: opa
+        image: openpolicyagent/opa:0.57.0
+        args:
+          - "run"
+          - "--server"
+          - "--set=decision_logs.console=true"
+          - "/policies"
+        ports:
+          - containerPort: 8181
+        volumeMounts:
+          - name: policy-volume
+            mountPath: /policies
+      volumes:
+        - name: policy-volume
+          configMap:
+            name: opa-policies
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: opa
+  namespace: ops
+spec:
+  selector:
+    app: opa
+  ports:
+    - port: 8181
+      targetPort: 8181
+
+---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: opa-policies
+  namespace: ops
+data:
+  multi_sig.rego: |
+    package aegis.policies
+
+    default allow = false
+
+    allow {
+      input.action != "hsm_rotate"
+    }
+
+    allow {
+      input.action == "hsm_rotate"
+      count_approvers(input.approvers) >= input.required
+    }
+
+    count_approvers(arr) = n {
+      n := count({v | arr[_] == v})
+    }
+
*** End File
*** Add File: k8s/rollouts/transaction-manager-rollout.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: AnalysisTemplate
+metadata:
+  name: canary-slo-check
+spec:
+  metrics:
+  - name: error-rate
+    interval: 1m
+    provider:
+      prometheus:
+        address: http://prometheus-operated.monitoring.svc:9090
+        query: |
+          sum(rate(transaction_errors_total[5m])) / sum(rate(transaction_requests_total[5m]))
+    failureLimit: 1
+    successCondition: result < 0.01
+
+---
+apiVersion: argoproj.io/v1alpha1
+kind: Rollout
+metadata:
+  name: transaction-manager
+  namespace: staging
+spec:
+  replicas: 3
+  strategy:
+    canary:
+      steps:
+      - setWeight: 10
+      - pause: {duration: 10m}
+      - analysis:
+          templates:
+          - templateName: canary-slo-check
+      - setWeight: 50
+      - pause: {duration: 30m}
+      - setWeight: 100
+  selector:
+    matchLabels:
+      app: transaction-manager
+  template:
+    metadata:
+      labels:
+        app: transaction-manager
+    spec:
+      containers:
+      - name: tm
+        image: ghcr.io/yourorg/transaction-manager:stable
+        ports:
+        - containerPort: 8080
+
*** End File
*** Add File: .github/workflows/promote_with_rollout.yml
+name: Promote with Argo Rollout (with OPA check)
+on:
+  workflow_dispatch:
+    inputs:
+      image:
+        description: "Image to promote (registry/image:tag)"
+        required: true
+      action:
+        description: "Logical action name for policy (e.g., promote_model)"
+        required: true
+      approvers:
+        description: "Comma-separated list of approvers who have approved"
+        required: true
+      required_approvals:
+        description: "Number of required approvals"
+        required: false
+        default: "1"
+
+jobs:
+  preflight:
+    runs-on: ubuntu-latest
+    steps:
+      - name: OPA policy check
+        env:
+          OPA_URL: ${{ secrets.OPA_URL }} # http://opa.ops.svc.cluster.local:8181/v1/data/aegis/policies/allow
+        run: |
+          APPROVERS="${{ github.event.inputs.approvers }}"
+          REQ="${{ github.event.inputs.required_approvals }}"
+          ACTION="${{ github.event.inputs.action }}"
+          PAYLOAD=$(jq -n --arg action "$ACTION" --argjson approvers "$(jq -R -s -c 'split(",")' <<< "$APPROVERS") --argjson req $REQ '{action: $action, approvers: $approvers, required: ($req|tonumber)}')
+          echo "Payload: $PAYLOAD"
+          RES=$(curl -s -X POST -H "Content-Type: application/json" --data "$PAYLOAD" "${{ secrets.OPA_URL }}")
+          echo "OPA response: $RES"
+          ALLOW=$(echo "$RES" | jq -r '.result.allow // "false"')
+          if [ "$ALLOW" != "true" ]; then
+            echo "OPA denied action. Aborting."
+            exit 1
+          fi
+      - name: Patch Rollout image
+        env:
+          KUBECONFIG: ${{ secrets.KUBECONFIG_STAGING }}
+        run: |
+          IMAGE="${{ github.event.inputs.image }}"
+          kubectl -n staging set image rollout/transaction-manager transaction-manager=$IMAGE
+          echo "Patched rollout image to $IMAGE"
+
*** End File
*** Add File: .github/workflows/multisig_approval_with_opa.yml
+name: Multi-sig Approval with OPA Validation
+on:
+  workflow_dispatch:
+    inputs:
+      issue_number:
+        description: "GitHub issue number requesting approval"
+        required: true
+      action:
+        description: "Action being approved (e.g., hsm_rotate, promote_model)"
+        required: true
+      required_approvals:
+        description: "Number of distinct approvers required"
+        required: false
+        default: "2"
+
+jobs:
+  wait:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Wait for approvals (poll comments)
+        id: wait
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+        run: |
+          ISSUE=${{ github.event.inputs.issue_number }}
+          REQUIRED=${{ github.event.inputs.required_approvals }}
+          REPO=${{ github.repository }}
+          echo "Waiting for $REQUIRED distinct approvers on issue #$ISSUE"
+          for i in $(seq 1 120); do
+            APPROVERS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$REPO/issues/$ISSUE/comments" \
+              | jq -r '.[] | select(.body|test("^/approve$")) | .user.login' | sort -u)
+            COUNT=$(echo "$APPROVERS" | wc -l)
+            echo "Approvals: $COUNT"
+            if [ "$COUNT" -ge "$REQUIRED" ]; then
+              echo "Approvals met: $APPROVERS"
+              echo "::set-output name=approvers::$APPROVERS"
+              exit 0
+            fi
+            sleep 20
+          done
+          echo "Timed out waiting for approvals"
+          exit 1
+      - name: OPA validation
+        if: steps.wait.outputs.approvers != ''
+        env:
+          OPA_URL: ${{ secrets.OPA_URL }}
+        run: |
+          ACTION="${{ github.event.inputs.action }}"
+          APPR=$(echo "${{ steps.wait.outputs.approvers }}" | jq -R -s -c 'split("\n")[:-1]')
+          REQ=${{ github.event.inputs.required_approvals }}
+          PAYLOAD=$(jq -n --arg action "$ACTION" --argjson approvers "$APPR" --argjson required $REQ '{action: $action, approvers: $approvers, required: ($required|tonumber)}')
+          echo "OPA payload: $PAYLOAD"
+          RES=$(curl -s -X POST -H "Content-Type: application/json" --data "$PAYLOAD" "${{ secrets.OPA_URL }}")
+          echo "OPA => $RES"
+          ALLOW=$(echo "$RES" | jq -r '.result.allow // "false"')
+          if [ "$ALLOW" != "true" ]; then
+            echo "OPA denied action."
+            exit 1
+          fi
+
*** End File
*** Add File: monitoring/prometheus/automation_kpis.yaml
+groups:
+- name: automation.kpis
+  rules:
+  - alert: HighAutomationRollbackRate
+    expr: (increase(automation_rollbacks_total[1h]) / increase(automation_deploys_total[1h])) > 0.05
+    for: 30m
+    labels:
+      severity: critical
+    annotations:
+      summary: "Automation rollback rate > 5% (1h)"
+      description: "Rollback rate for automated deploys is above 5% in the last hour."
+
+  - alert: HighAnomalyDetectorFPRate
+    expr: increase(anomaly_false_positives_total[1h]) / increase(anomaly_checks_total[1h]) > 0.15
+    for: 30m
+    labels:
+      severity: warning
+    annotations:
+      summary: "Anomaly detector false positive rate high"
+      description: "False positive rate >15% over last hour."
+
+  - alert: AutomationFailureSpike
+    expr: increase(automation_failures_total[15m]) > 5
+    for: 10m
+    labels:
+      severity: critical
+    annotations:
+      summary: "Automation failures increased"
+      description: "More than 5 automation failures in 15m."
+
*** End File
*** Add File: monitoring/grafana/automation_kpis_dashboard.json
+{
+  "dashboard": {
+    "annotations": { "list": [] },
+    "editable": true,
+    "gnetId": null,
+    "panels": [
+      {
+        "type": "graph",
+        "title": "Automation Success Rate",
+        "targets": [
+          { "expr": "1 - (rate(automation_failures_total[5m]) / rate(automation_runs_total[5m]))", "legendFormat": "success_rate" }
+        ],
+        "id": 1
+      },
+      {
+        "type": "graph",
+        "title": "Rollback Rate (1h)",
+        "targets": [
+          { "expr": "rate(automation_rollbacks_total[1h]) / rate(automation_deploys_total[1h])", "legendFormat": "rollback_rate" }
+        ],
+        "id": 2
+      },
+      {
+        "type": "graph",
+        "title": "Anomaly Detector FP Rate",
+        "targets": [
+          { "expr": "rate(anomaly_false_positives_total[1h]) / rate(anomaly_checks_total[1h])", "legendFormat": "fp_rate" }
+        ],
+        "id": 3
+      }
+    ],
+    "schemaVersion": 16,
+    "title": "Automation KPIs",
+    "uid": "automation-kpis"
+  }
+}
+
*** End File
*** Add File: .github/workflows/anomaly_replay_validation.yml
+name: Anomaly Replay Validation
+on:
+  workflow_dispatch:
+    inputs:
+      metrics_s3_prefix:
+        required: true
+      incidents_s3_key:
+        required: true
+
+jobs:
+  replay:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Install deps
+        run: python -m pip install --upgrade pip && pip install boto3 scikit-learn joblib pandas
+      - name: Download historic metrics & incidents
+        env:
+          COMPLIANCE_BUCKET: ${{ secrets.COMPLIANCE_BUCKET }}
+        run: |
+          aws s3 cp "s3://${COMPLIANCE_BUCKET}/${{ github.event.inputs.metrics_s3_prefix }}" ./metrics.csv
+          aws s3 cp "s3://${COMPLIANCE_BUCKET}/${{ github.event.inputs.incidents_s3_key }}" ./incidents.csv
+      - name: Run replay evaluation
+        run: |
+          python3 ml/anomaly/eval_replay.py --metrics-csv ./metrics.csv --incidents-csv ./incidents.csv --model ml/anomaly/model.joblib
+
*** End File
*** Add File: ml/anomaly/synthetic_dataset_generator.py
+#!/usr/bin/env python3
+"""
+Generate a small synthetic metrics CSV + incidents file for replay validation.
+"""
+import csv
+import random
+import datetime
+
+def gen_metrics(path, n=1000, start_ts=None):
+    start = start_ts or datetime.datetime.utcnow()
+    with open(path, "w", newline='') as f:
+        w = csv.writer(f)
+        w.writerow(["ts","stuck_increase_5m","prepare_fail_rate","commit_fail_rate","tm_restarts","tx_queue"])
+        for i in range(n):
+            t = start + datetime.timedelta(seconds=i*60)
+            row = [
+                t.isoformat(),
+                max(0, random.gauss(0.1, 0.5)),
+                abs(random.gauss(0.01, 0.02)),
+                abs(random.gauss(0.01, 0.02)),
+                abs(int(random.gauss(0,1))),
+                max(0, random.gauss(5,3))
+            ]
+            w.writerow(row)
+
+def gen_incidents(path, metrics_csv, rate=0.01):
+    # naive: mark some timestamps as incidents
+    ts = []
+    with open(metrics_csv) as f:
+        reader = csv.DictReader(f)
+        for r in reader:
+            if random.random() < rate:
+                ts.append(r["ts"])
+    with open(path, "w", newline='') as f:
+        w = csv.writer(f)
+        w.writerow(["ts_iso","label"])
+        for t in ts:
+            w.writerow([t,1])
+
+if __name__ == "__main__":
+    gen_metrics("synthetic_metrics.csv", n=1440)
+    gen_incidents("synthetic_incidents.csv", "synthetic_metrics.csv", rate=0.005)
+    print("Wrote synthetic_metrics.csv and synthetic_incidents.csv")
+
*** End File
*** Add File: services/audit_collector/app.py
+from flask import Flask, request, jsonify
+import os
+import sqlite3
+import time
+import json
+import boto3
+
+DB_PATH = os.environ.get("AUDIT_DB", "/data/audit.db")
+S3_BUCKET = os.environ.get("COMPLIANCE_BUCKET")
+
+def ensure_db():
+    os.makedirs(os.path.dirname(DB_PATH) or ".", exist_ok=True)
+    conn = sqlite3.connect(DB_PATH)
+    c = conn.cursor()
+    c.execute("""CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, ts INTEGER, actor TEXT, action TEXT, payload TEXT)""")
+    conn.commit(); conn.close()
+
+ensure_db()
+app = Flask("audit-collector")
+
+@app.route("/event", methods=["POST"])
+def event():
+    data = request.get_json() or {}
+    actor = data.get("actor")
+    action = data.get("action")
+    payload = data.get("payload", {})
+    ts = int(time.time())
+    conn = sqlite3.connect(DB_PATH)
+    c = conn.cursor()
+    c.execute("INSERT INTO events (ts, actor, action, payload) VALUES (?, ?, ?, ?)", (ts, actor, action, json.dumps(payload)))
+    conn.commit()
+    ev_id = c.lastrowid
+    conn.close()
+    # upload to S3 for immutable evidence
+    if S3_BUCKET:
+        s3 = boto3.client("s3")
+        key = f"audit/events/event_{ev_id}_{ts}.json"
+        s3.put_object(Bucket=S3_BUCKET, Key=key, Body=json.dumps({"id": ev_id, "ts": ts, "actor": actor, "action": action, "payload": payload}))
+    return jsonify({"ok": True, "id": ev_id})
+
+@app.route("/health", methods=["GET"])
+def health():
+    return jsonify({"ok": True})
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "8088")))
+
*** End File
*** Add File: services/audit_collector/requirements.txt
+Flask==2.2.5
+boto3==1.26.XXX
+
*** End File
*** Add File: k8s/manifests/audit-collector-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: audit-collector
+  namespace: ops
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: audit-collector
+  template:
+    metadata:
+      labels:
+        app: audit-collector
+    spec:
+      containers:
+      - name: audit-collector
+        image: ghcr.io/yourorg/audit-collector:latest
+        env:
+          - name: COMPLIANCE_BUCKET
+            valueFrom:
+              secretKeyRef:
+                name: aegis-secrets
+                key: compliance_bucket
+        ports:
+          - containerPort: 8088
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: audit-collector
+  namespace: ops
+spec:
+  selector:
+    app: audit-collector
+  ports:
+    - port: 8088
+      targetPort: 8088
+
*** End File
*** Add File: scripts/opa_query_before_action.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Query OPA for permission to perform an action.
+# Usage: ./opa_query_before_action.sh <action> "<approver1,approver2,...>" <required>
+
+ACTION=${1:-}
+APPR_LIST=${2:-""}
+REQUIRED=${3:-1}
+OPA_URL=${OPA_URL:-http://opa.ops.svc.cluster.local:8181/v1/data/aegis/policies/allow}
+
+if [ -z "$ACTION" ]; then
+  echo "Usage: $0 <action> <approvers_csv> <required>"
+  exit 2
+fi
+
+PAYLOAD=$(jq -n --arg action "$ACTION" --argjson approvers "$(jq -R -s -c 'split(",")' <<< "$APPR_LIST") --argjson req $REQUIRED '{action: $action, approvers: $approvers, required: ($req|tonumber)}')
+echo "Querying OPA with payload: $PAYLOAD"
+RES=$(curl -s -X POST -H "Content-Type: application/json" --data "$PAYLOAD" "$OPA_URL")
+echo "OPA response: $RES"
+ALLOW=$(echo "$RES" | jq -r '.result.allow // "false"')
+if [ "$ALLOW" != "true" ]; then
+  echo "OPA: action denied"
+  exit 1
+fi
+echo "OPA: action allowed"
+
*** End File
*** End Patch
