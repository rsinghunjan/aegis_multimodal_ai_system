*** Begin Patch
*** Add File:terraform/irsa/my.tfvars.example
+# Example terraform/irsa/my.tfvars - DO NOT COMMIT real secrets
+cluster_name = "REPLACE_CLUSTER_NAME"
+account_id   = "REPLACE_AWS_ACCOUNT_ID"
+aws_region   = "REPLACE_AWS_REGION"
+oidc_provider_arn = "REPLACE_OIDC_PROVIDER_ARN"
+
+policy_arn_braket = "REPLACE_POLICY_ARN_BRAKET"
+policy_arn_ibm    = "REPLACE_POLICY_ARN_IBM"
+policy_arn_azure  = "REPLACE_POLICY_ARN_AZURE"
+policy_arn_rigetti= "REPLACE_POLICY_ARN_RIGETTI"
+
+# Optional: GitHub OIDC role / KMS ARN for Actions to sign (if using OIDC)
+github_org = "REPLACE_GITHUB_ORG"
+kms_key_arn = "REPLACE_COSIGN_KMS_ARN"
+github_oidc_provider_arn = "REPLACE_GITHUB_OIDC_PROVIDER_ARN"
+
*** End Patch
*** Begin Patch
*** Add File:terraform/irsa/apply_irsa.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run this locally to create IRSA roles. Provide a local my.tfvars (do NOT commit).
+#
+DIR="$(cd "$(dirname "$0")" && pwd)"
+TFVARS="${1:-${DIR}/my.tfvars}"
+
+if [ ! -f "${TFVARS}" ]; then
+  echo "Missing tfvars: ${TFVARS}"
+  echo "Copy the example and edit: cp ${DIR}/my.tfvars.example ${DIR}/my.tfvars"
+  exit 2
+fi
+
+pushd "${DIR}"
+terraform init
+terraform plan -var-file="${TFVARS}"
+terraform apply -auto-approve -var-file="${TFVARS}"
+terraform output -json > /tmp/irsa_outputs.json
+echo "Terraform outputs written to /tmp/irsa_outputs.json"
+popd
+
+echo "Annotating common serviceaccounts (if present)..."
+if command -v jq >/dev/null 2>&1 && [ -f /tmp/irsa_outputs.json ]; then
+  ./irsa_annotate_sa.sh /tmp/irsa_outputs.json || true
+else
+  echo "Skipping annotation step (jq or outputs missing)."
+fi
+
*** End Patch
*** Begin Patch
*** Add File:ops/create_github_secrets_automated.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Create required GitHub repository secrets using gh CLI.
+# Usage:
+#   export REPO="owner/repo"
+#   export COSIGN_KMS_ARN="arn:aws:kms:..."
+#   export REKOR_URL="https://rekor.example.com"
+#   export EVIDENCE_BUCKET="aegis-evidence-123"
+#   export MLFLOW_TRACKING_URI="https://mlflow.example.com"
+#   export AWS_ROLE_TO_ASSUME="arn:aws:iam::123:role/ci-oidc-role"    # optional
+#   ./ops/create_github_secrets_automated.sh
+
+REPO=${REPO:-"REPLACE_GITHUB_REPOSITORY"}
+
+required_vars=(COSIGN_KMS_ARN REKOR_URL EVIDENCE_BUCKET MLFLOW_TRACKING_URI)
+for v in "${required_vars[@]}"; do
+  if [ -z "${!v:-}" ]; then
+    echo "Environment variable ${v} not set. Please export it before running."
+    exit 2
+  fi
+done
+
+echo "Creating secrets in ${REPO}..."
+gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+gh secret set EVIDENCE_BUCKET --repo "${REPO}" --body "${EVIDENCE_BUCKET}"
+gh secret set MLFLOW_TRACKING_URI --repo "${REPO}" --body "${MLFLOW_TRACKING_URI}"
+
+if [ -n "${AWS_ROLE_TO_ASSUME:-}" ]; then
+  gh secret set AWS_ROLE_TO_ASSUME --repo "${REPO}" --body "${AWS_ROLE_TO_ASSUME}"
+fi
+
+echo "Secrets created. Verify in https://github.com/${REPO}/settings/secrets"
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/secretstore.aws.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: SecretStore
+metadata:
+  name: aws-secrets-manager
+  namespace: aegis
+spec:
+  provider:
+    aws:
+      service: SecretsManager
+      region: REPLACE_AWS_REGION
+      auth:
+        jwt:
+          serviceAccountRef:
+            name: externalsecrets-sa
+            namespace: aegis
+          # For IRSA use service account with proper annotation; otherwise you can configure access keys (NOT recommended)
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/externalsecret_runtime_values.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: aegis-runtime-values
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: aegis-runtime-secrets
+    creationPolicy: Owner
+  data:
+    - secretKey: COSIGN_KMS_ARN
+      remoteRef:
+        key: "aegis/cosign"
+        property: "kms_arn"
+    - secretKey: REKOR_URL
+      remoteRef:
+        key: "aegis/rekor"
+        property: "rekor_url"
+    - secretKey: MLFLOW_TRACKING_URI
+      remoteRef:
+        key: "aegis/mlflow"
+        property: "tracking_uri"
+    - secretKey: GITHUB_TOKEN
+      remoteRef:
+        key: "gitops/github"
+        property: "token"
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/ci_oidc_registry_push.yml
+name: CI â€” Push image via OIDC and sign
+
+on:
+  workflow_dispatch:
+
+jobs:
+  build_and_push:
+    runs-on: ubuntu-latest
+    permissions:
+      id-token: write
+      contents: read
+      packages: write
+    steps:
+      - uses: actions/checkout@v4
+      - name: Configure AWS credentials via OIDC
+        uses: aws-actions/configure-aws-credentials@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+          aws-region: REPLACE_AWS_REGION
+      - name: Login to ECR
+        run: |
+          aws ecr get-login-password --region REPLACE_AWS_REGION | docker login --username AWS --password-stdin "${{ secrets.ECR_REGISTRY }}"
+      - name: Build & push
+        run: |
+          docker build -t "${{ secrets.ECR_REGISTRY }}/aegis-quantum:${{ github.sha }}" -f docker/quantum/Dockerfile .
+          docker push "${{ secrets.ECR_REGISTRY }}/aegis-quantum:${{ github.sha }}"
+      - name: Sign image with cosign (awskms)
+        env:
+          COSIGN_KMS_ARN: ${{ secrets.COSIGN_KMS_ARN }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          IMAGE="${{ secrets.ECR_REGISTRY }}/aegis-quantum:${{ github.sha }}"
+          cosign sign --key "awskms://${COSIGN_KMS_ARN}" --rekor-server "${REKOR_URL}" "${IMAGE}"
+      - name: Verify
+        run: |
+          cosign verify --rekor-server "${{ secrets.REKOR_URL }}" "${{ secrets.ECR_REGISTRY }}/aegis-quantum:${{ github.sha }}"
+
*** End Patch
*** Begin Patch
*** Add File:argocd/application-gitops-staging.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Application
+metadata:
+  name: aegis-gitops-staging
+  namespace: argocd
+spec:
+  project: default
+  source:
+    repoURL: 'https://github.com/REPLACE_GITOPS_OWNER/REPLACE_GITOPS_REPO.git'
+    targetRevision: HEAD
+    path: 'overlays/staging'
+  destination:
+    server: 'https://kubernetes.default.svc'
+    namespace: aegis
+  syncPolicy:
+    automated:
+      prune: true
+      selfHeal: true
+    syncOptions:
+      - CreateNamespace=true
+      - ApplyOutOfSyncOnly=true
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_argocd_helm.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install ArgoCD via Helm (preferred for customization)
+kubectl create namespace argocd || true
+helm repo add argo https://argoproj.github.io/argo-helm
+helm repo update
+helm upgrade --install argocd argo/argo-cd -n argocd \
+  --set server.service.type=LoadBalancer \
+  --set server.ingress.enabled=false
+echo "ArgoCD installed via Helm in namespace argocd."
+
*** End Patch
*** Begin Patch
*** Add File:knative/install_knative.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Knative Serving (simple example). Adjust versions as needed.
+kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.8.0/serving-crds.yaml
+kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.8.0/serving-core.yaml
+kubectl apply -f https://github.com/knative/net-istio/releases/download/knative-v1.8.0/release.yaml
+kubectl label namespace aegis istio-injection=enabled --overwrite
+echo "Knative & net-istio installed; namespace 'aegis' labelled for injection."
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_gatekeeper.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Gatekeeper (OPA) and apply baseline constraints for Aegis.
+kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+sleep 5
+kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml
+echo "Gatekeeper installed and constraints applied (review k8s/gatekeeper/*)."
+
*** End Patch
*** Begin Patch
*** Add File:ops/setup_branch_protection.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Set branch protection on TARGET_BRANCH to require checks and approvals.
+# Usage:
+#   export REPO="owner/repo"
+#   export TARGET_BRANCH="main"
+#   ./ops/setup_branch_protection.sh
+
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+BRANCH=${TARGET_BRANCH:-"main"}
+REQUIRED_CONTEXTS=("ci_train_validate_register" "image_build_cosign" "secret-and-deploy-preflight")
+
+echo "Applying branch protection to ${REPO} ${BRANCH}"
+gh api -X PUT /repos/${REPO}/branches/${BRANCH}/protection --silent -f - <<JSON
+{
+  "required_status_checks": {
+    "strict": true,
+    "contexts": ${REQUIRED_CONTEXTS[@]/#/\"}${REQUIRED_CONTEXTS[@]/%/\"}
+  },
+  "enforce_admins": true,
+  "required_pull_request_reviews": {
+    "dismiss_stale_reviews": true,
+    "require_code_owner_reviews": false,
+    "required_approving_review_count": 1
+  },
+  "restrictions": null
+}
+JSON
+
+echo "Branch protection applied. Update contexts list to match your workflow job names if needed."
+
*** End Patch
*** Begin Patch
*** Add File:ops/run_acceptance_tests.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Run quick acceptance tests for Aegis automation (placeholders must be filled)
+#
+IMAGE=${1:-"REPLACE_IMAGE"}
+EVIDENCE_BUCKET=${EVIDENCE_BUCKET:-"REPLACE_EVIDENCE_BUCKET"}
+REKOR_URL=${REKOR_URL:-"REPLACE_REKOR_URL"}
+
+echo "1) Verify cosign signature exists for image (requires cosign installed)"
+if command -v cosign >/dev/null 2>&1; then
+  cosign verify --rekor-server "${REKOR_URL}" "${IMAGE}" || echo "Cosign verify failed (check REKOR_URL/KMS)"
+else
+  echo "cosign not installed; skipping signature check"
+fi
+
+echo "2) Verify Argo workflows are present"
+kubectl -n aegis get wf --no-headers || true
+
+echo "3) Run a sample Argo demo E2E (simulate)"
+argo submit -n aegis demo/e2e_auto_workflow.yaml -p image="${IMAGE}" || echo "Argo submit failed (ensure Argo installed)"
+
+echo "4) Check evidence S3 prefix exists (requires awscli)"
+if command -v aws >/dev/null 2>&1; then
+  aws s3 ls "s3://${EVIDENCE_BUCKET}/" || echo "S3 bucket not accessible or empty"
+else
+  echo "aws cli not installed; skipping S3 check"
+fi
+
+echo "Acceptance tests completed (some steps may be placeholders)."
+
*** End Patch
*** Begin Patch
*** Add File:config/promotion_conditions.defaults.yaml
+# Default promotion condition values (editable)
+promote:
+  p95_latency_threshold: 0.5
+  error_rate_threshold: 0.02
+  success_window_minutes: 60
+
*** End Patch
*** End Patch
