*** Begin Patch
*** Modify File: scripts/ram_bind_and_verify.sh
@@
-#!/usr/bin/env bash
-set -euo pipefail
-#
-# ram_bind_and_verify.sh
-# Create an Alibaba Cloud RAM role for a Kubernetes ServiceAccount and verify via a test Pod.
-#
-# Usage:
-#   ./scripts/ram_bind_and_verify.sh --account-id 1234567890123456 --role-name aegis-ram-role \
-#     --namespace aegis --ksa aegis-operator --bucket my-oss-bucket [--dry-run]
-#
-# Requirements:
-# - aliyun CLI authenticated with appropriate permissions (ram:CreateRole, ram:AttachPolicyToRole, ram:GetRole)
-# - kubectl configured for target cluster
-#
-usage() {
-  cat <<EOF
-Usage: $0 --account-id ACCOUNT --role-name ROLE --namespace K8S_NS --ksa KSA [--policy-arn POLICY_NAME|--policy-file FILE] [--dry-run]
-
-This will:
- 1) Create a RAM Role with a trust policy that allows OIDC/ACK to assume it (you may need to adapt the trust policy for your ACK setup).
- 2) Attach a RAM policy (from a file or managed) to the role.
- 3) Annotate the K8s ServiceAccount with the expected annotation to allow the cluster integration to use the RAM role (annotation name may vary per ACK version).
- 4) Launch a verifier pod to run aliyun CLI sts get-caller-identity and try OSS ls.
-EOF
-}
-
-ACCOUNT_ID=""
-ROLE_NAME=""
-K8S_NS=""
-KSA=""
-POLICY_FILE=""
-POLICY_NAME=""
-DRY_RUN=false
-
-while [ $# -gt 0 ]; do
-  case "$1" in
-    --account-id) ACCOUNT_ID="$2"; shift 2;;
-    --role-name) ROLE_NAME="$2"; shift 2;;
-    --namespace) K8S_NS="$2"; shift 2;;
-    --ksa) KSA="$2"; shift 2;;
-    --policy-file) POLICY_FILE="$2"; shift 2;;
-    --policy-name) POLICY_NAME="$2"; shift 2;;
-    --dry-run) DRY_RUN=true; shift;;
-    -h|--help) usage; exit 0;;
-    *) echo "Unknown arg: $1"; usage; exit 2;;
-  esac
-done
-
-if [ -z "$ACCOUNT_ID" ] || [ -z "$ROLE_NAME" ] || [ -z "$K8S_NS" ] || [ -z "$KSA" ]; then
-  usage
-  exit 2
-fi
-
-set -x
-
-# Note: ACK/Alibaba cluster integration details vary. This script creates a RAM role with a simple assume-role policy placeholder.
-TRUST_POLICY_FILE="$(mktemp)"
-cat > "$TRUST_POLICY_FILE" <<EOF
-{
-  "Statement": [
-    {
-      "Action": "sts:AssumeRole",
-      "Effect": "Allow",
-      "Principal": {
-        "Federation": ["oidc-provider-placeholder"]
-      }
-    }
-  ],
-  "Version": "1"
-}
-EOF
-
-if [ "$DRY_RUN" = true ]; then
-  echo "DRY RUN: aliyun ram CreateRole --RoleName $ROLE_NAME --AssumeRolePolicyDocument file://$TRUST_POLICY_FILE"
-  [ -n "$POLICY_FILE" ] && echo "DRY RUN: aliyun ram CreatePolicy --PolicyName <name> --PolicyDocument file://$POLICY_FILE"
-  echo "DRY RUN: kubectl -n $K8S_NS annotate serviceaccount $KSA aliyun/ram-role=$ROLE_NAME --overwrite"
-  rm -f "$TRUST_POLICY_FILE"
-  exit 0
-fi
-
-echo "Creating RAM role $ROLE_NAME"
-aliyun ram CreateRole --RoleName "$ROLE_NAME" --AssumeRolePolicyDocument "file://$TRUST_POLICY_FILE" >/dev/null
-
-if [ -n "$POLICY_FILE" ]; then
-  echo "Creating RAM policy from file $POLICY_FILE"
-  POLICY_NAME_GEN="${ROLE_NAME}-policy"
-  aliyun ram CreatePolicy --PolicyName "$POLICY_NAME_GEN" --PolicyDocument "file://$POLICY_FILE" >/dev/null
-  aliyun ram AttachPolicyToRole --PolicyType "Custom" --PolicyName "$POLICY_NAME_GEN" --RoleName "$ROLE_NAME"
-elif [ -n "$POLICY_NAME" ]; then
-  echo "Attaching managed policy $POLICY_NAME"
-  aliyun ram AttachPolicyToRole --PolicyName "$POLICY_NAME" --RoleName "$ROLE_NAME"
-fi
-
-echo "Annotating KSA $K8S_NS/$KSA with RAM role reference (annotation name may vary by cluster integration)."
-# Common annotation name in some ACK integrations (replace if your cluster uses a different annotation)
-kubectl -n "$K8S_NS" annotate serviceaccount "$KSA" "aliyun.aliyuncs.com/ram-role=${ROLE_NAME}" --overwrite || true
-
-echo "Launching verifier pod to check STS identity and OSS list (requires aliyun CLI in cluster nodes)"
-POD_NAME="aliyun-verify-$(date +%s)"
-cat <<EOF | kubectl -n "$K8S_NS" apply -f -
-apiVersion: v1
-kind: Pod
-metadata:
-  name: ${POD_NAME}
-spec:
-  serviceAccountName: ${KSA}
-  containers:
-  - name: aliyun
-    image: registry.aliyuncs.com/acs/aliyun-cli:latest
-    command: ["/bin/sh","-c"]
-    args:
-      - aliyun sts GetCallerIdentity || true; echo "Attempting OSS ls (may require OSS CLI plugin)"; sleep 600
-  restartPolicy: Never
-EOF
-
-kubectl -n "$K8S_NS" wait --for=condition=Ready pod/"$POD_NAME" --timeout=120s || true
-kubectl -n "$K8S_NS" logs "$POD_NAME" --tail=200 || true
-kubectl -n "$K8S_NS" delete pod "$POD_NAME" --ignore-not-found
-
-rm -f "$TRUST_POLICY_FILE"
-echo "RAM bind and verify completed. Inspect logs above for caller identity/OSS output."
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# ram_bind_and_verify.sh
+# Create an Alibaba Cloud RAM role for a Kubernetes ServiceAccount and verify via a test Pod.
+#
+# This version builds a concrete trust policy based on an OIDC provider URL and the
+# service account (namespace/ksa). It optionally attaches a policy and annotates the KSA
+# with the provided annotation key used by your ACK cluster integration.
+#
+# Usage:
+#   ./scripts/ram_bind_and_verify.sh \
+#     --role-name aegis-ram-role \
+#     --namespace aegis --ksa aegis-operator \
+#     --oidc-provider https://oidc.provider.example.com \
+#     --annotation-key aliyun.aliyuncs.com/ram-role \
+#     --policy-file ./infra/iam/alibaba/ram_policy.json \
+#     [--dry-run]
+#
+usage() {
+  cat <<EOF
+Usage: $0 --role-name ROLE --namespace K8S_NS --ksa KSA --oidc-provider OIDC_URL --annotation-key ANNOTATION_KEY [--policy-file FILE] [--dry-run]
+
+This script:
+ 1) Generates a trust policy that allows the OIDC provider to assume the role for the specific SA sub claim.
+ 2) Creates the RAM role with that trust policy via aliyun CLI.
+ 3) Attaches a provided policy file (optional) or a managed policy name (optional).
+ 4) Annotates the Kubernetes service account with the cluster-specific annotation key to reference the RAM role.
+ 5) Launches a verifier pod to show STS caller identity and attempt an OSS list (if bucket provided).
+EOF
+}
+
+ROLE_NAME=""
+K8S_NS=""
+KSA=""
+OIDC_PROVIDER=""
+ANNOTATION_KEY=""
+POLICY_FILE=""
+DRY_RUN=false
+OSS_BUCKET=""
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --role-name) ROLE_NAME="$2"; shift 2;;
+    --namespace) K8S_NS="$2"; shift 2;;
+    --ksa) KSA="$2"; shift 2;;
+    --oidc-provider) OIDC_PROVIDER="$2"; shift 2;;
+    --annotation-key) ANNOTATION_KEY="$2"; shift 2;;
+    --policy-file) POLICY_FILE="$2"; shift 2;;
+    --oss-bucket) OSS_BUCKET="$2"; shift 2;;
+    --dry-run) DRY_RUN=true; shift;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg: $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$ROLE_NAME" ] || [ -z "$K8S_NS" ] || [ -z "$KSA" ] || [ -z "$OIDC_PROVIDER" ] || [ -z "$ANNOTATION_KEY" ]; then
+  usage
+  exit 2
+fi
+
+set -x
+
+# Compute OIDC host (strip https://)
+OIDC_HOST="${OIDC_PROVIDER#https://}"
+
+# Build trust policy requiring sub to match the SA:
+TRUST_POLICY_FILE="$(mktemp)"
+cat > "$TRUST_POLICY_FILE" <<EOF
+{
+  "Version": "1",
+  "Statement": [
+    {
+      "Effect": "Allow",
+      "Action": "sts:AssumeRole",
+      "Principal": {
+        "Federation": ["${OIDC_HOST}"]
+      },
+      "Condition": {
+        "StringEquals": {
+          "${OIDC_HOST}:sub": "system:serviceaccount:${K8S_NS}:${KSA}"
+        }
+      }
+    }
+  ]
+}
+EOF
+
+if [ "$DRY_RUN" = true ]; then
+  echo "[DRY RUN] Would run: aliyun ram CreateRole --RoleName $ROLE_NAME --AssumeRolePolicyDocument file://$TRUST_POLICY_FILE"
+  if [ -n "$POLICY_FILE" ]; then
+    echo "[DRY RUN] Would attach policy: aliyun ram CreatePolicy --PolicyName ${ROLE_NAME}-policy --PolicyDocument file://$POLICY_FILE"
+  fi
+  echo "[DRY RUN] Would annotate KSA: kubectl -n $K8S_NS annotate serviceaccount $KSA ${ANNOTATION_KEY}=${ROLE_NAME} --overwrite"
+  rm -f "$TRUST_POLICY_FILE"
+  exit 0
+fi
+
+echo "Creating RAM role $ROLE_NAME with trust policy for OIDC host $OIDC_HOST"
+aliyun ram CreateRole --RoleName "$ROLE_NAME" --AssumeRolePolicyDocument "file://$TRUST_POLICY_FILE" >/dev/null
+
+if [ -n "$POLICY_FILE" ]; then
+  echo "Creating and attaching custom policy from $POLICY_FILE"
+  POLICY_NAME_GEN="${ROLE_NAME}-policy"
+  aliyun ram CreatePolicy --PolicyName "$POLICY_NAME_GEN" --PolicyDocument "file://$POLICY_FILE" >/dev/null
+  aliyun ram AttachPolicyToRole --PolicyType "Custom" --PolicyName "$POLICY_NAME_GEN" --RoleName "$ROLE_NAME"
+fi
+
+echo "Annotating KSA $K8S_NS/$KSA with ${ANNOTATION_KEY}=${ROLE_NAME}"
+kubectl -n "$K8S_NS" annotate serviceaccount "$KSA" "${ANNOTATION_KEY}=${ROLE_NAME}" --overwrite || true
+
+echo "Launching verifier pod to check STS identity and (optionally) OSS list"
+POD_NAME="aliyun-verify-$(date +%s)"
+cat <<EOF | kubectl -n "$K8S_NS" apply -f -
+apiVersion: v1
+kind: Pod
+metadata:
+  name: ${POD_NAME}
+spec:
+  serviceAccountName: ${KSA}
+  containers:
+  - name: aliyun
+    image: registry.aliyuncs.com/acs/aliyun-cli:latest
+    command: ["/bin/sh","-c"]
+    args:
+      - aliyun sts GetCallerIdentity || true; \
+        if [ -n "${OSS_BUCKET}" ]; then echo "Attempting OSS ls for ${OSS_BUCKET}"; aliyun oss ls "oss://${OSS_BUCKET}" || echo "OSS ls failed"; fi; \
+        sleep 600
+  restartPolicy: Never
+EOF
+
+kubectl -n "$K8S_NS" wait --for=condition=Ready pod/"$POD_NAME" --timeout=120s || true
+kubectl -n "$K8S_NS" logs "$POD_NAME" --tail=400 || true
+kubectl -n "$K8S_NS" delete pod "$POD_NAME" --ignore-not-found
+
+rm -f "$TRUST_POLICY_FILE"
+echo "RAM bind and verify completed. Inspect logs above for caller identity/OSS output."
*** End Patch
*** Begin Patch
*** Add File: infra/iam/alibaba/ram_policy_template.json.template
+{
+  "Version": "1",
+  "Statement": [
+    {
+      "Effect": "Allow",
+      "Action": [
+        "oss:PutObject",
+        "oss:GetObject",
+        "oss:ListObjects"
+      ],
+      "Resource": [
+        "acs:oss:*:*:{{OSS_BUCKET}}",
+        "acs:oss:*:*:{{OSS_BUCKET}}/*"
+      ]
+    },
+    {
+      "Effect": "Allow",
+      "Action": [
+        "kms:Encrypt",
+        "kms:Decrypt",
+        "kms:GenerateDataKey",
+        "kms:DescribeKey"
+      ],
+      "Resource": "{{KMS_KEY_ID}}"
+    }
+  ]
+}
+
*** End Patch
*** Begin Patch
*** Add File: scripts/generate_ram_policy_alibaba.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# generate_ram_policy_alibaba.sh
+# Substitute OSS bucket and KMS key id into the RAM policy template.
+#
+# Usage:
+#  ./scripts/generate_ram_policy_alibaba.sh --bucket my-bucket --kms-key-id cn-hangzhou/abc123 --out /tmp/ram_policy.json
+#
+BUCKET=""
+KMS_KEY_ID=""
+OUT="/tmp/ram_policy_alibaba.json"
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --bucket) BUCKET="$2"; shift 2;;
+    --kms-key-id) KMS_KEY_ID="$2"; shift 2;;
+    --out) OUT="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 --bucket BUCKET --kms-key-id KMS_ID [--out FILE]"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$BUCKET" ] || [ -z "$KMS_KEY_ID" ]; then
+  echo "Missing args"
+  exit 2
+fi
+
+TEMPLATE="infra/iam/alibaba/ram_policy_template.json.template"
+if [ ! -f "$TEMPLATE" ]; then
+  echo "Template not found: $TEMPLATE"
+  exit 2
+fi
+
+sed "s|{{OSS_BUCKET}}|${BUCKET}|g; s|{{KMS_KEY_ID}}|${KMS_KEY_ID}|g" "$TEMPLATE" > "$OUT"
+echo "Wrote RAM policy to $OUT"
+
*** End Patch
*** Begin Patch
*** Add File: scripts/update_milvus_alibaba_values.py
+#!/usr/bin/env python3
+"""
+update_milvus_alibaba_values.py
+
+Update infra/overrides/alibaba/milvus-values-ack.yaml with provided bucket/endpoint/kms key.
+"""
+import argparse, sys, yaml, os
+
+VALUES_FILE = "infra/overrides/alibaba/milvus-values-ack.yaml"
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--bucket", required=True)
+    p.add_argument("--endpoint", required=True)
+    p.add_argument("--region", required=True)
+    p.add_argument("--kms-key-id", required=True)
+    p.add_argument("--service-account", default="milvus-backup-sa")
+    p.add_argument("--out", default=VALUES_FILE)
+    args = p.parse_args()
+
+    vals = {}
+    if os.path.exists(args.out):
+        with open(args.out) as fh:
+            vals = yaml.safe_load(fh) or {}
+
+    vals.setdefault("backup", {})
+    vals["backup"]["enabled"] = True
+    vals["backup"].setdefault("alibaba", {})
+    vals["backup"]["alibaba"]["ossBucket"] = args.bucket
+    vals["backup"]["alibaba"]["endpoint"] = args.endpoint
+    vals["backup"]["alibaba"]["region"] = args.region
+    vals.setdefault("backup", {}).setdefault("encryption", {}).setdefault("kms", {})
+    vals["backup"]["encryption"]["kms"]["keyId"] = args.kms_key_id
+    vals.setdefault("serviceAccount", {})
+    vals["serviceAccount"]["create"] = False
+    vals["serviceAccount"]["name"] = args.service_account
+
+    with open(args.out, "w") as fh:
+        yaml.safe_dump(vals, fh, default_flow_style=False)
+    print("Updated", args.out)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File: scripts/update_milvus_alibaba_values_and_create_pr.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# update_milvus_alibaba_values_and_create_pr.sh
+# Wrapper to update milvus-values-ack.yaml and open a PR with the change.
+#
+# Requires:
+# - gh CLI authenticated (GITHUB_TOKEN)
+# - git configured (user.name / user.email)
+#
+usage() {
+  cat <<EOF
+Usage: $0 --bucket BUCKET --endpoint ENDPOINT --region REGION --kms-key-id KMS_ID --branch BRANCH_NAME --pr-title "Title"
+
+This will:
+ - create a branch BRANCH_NAME
+ - update infra/overrides/alibaba/milvus-values-ack.yaml
+ - commit and push
+ - open a PR with gh
+EOF
+}
+
+BUCKET=""
+ENDPOINT=""
+REGION=""
+KMS_KEY_ID=""
+BRANCH=""
+PR_TITLE=""
+SERVICE_ACCOUNT="milvus-backup-sa"
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --bucket) BUCKET="$2"; shift 2;;
+    --endpoint) ENDPOINT="$2"; shift 2;;
+    --region) REGION="$2"; shift 2;;
+    --kms-key-id) KMS_KEY_ID="$2"; shift 2;;
+    --branch) BRANCH="$2"; shift 2;;
+    --pr-title) PR_TITLE="$2"; shift 2;;
+    --service-account) SERVICE_ACCOUNT="$2"; shift 2;;
+    -h|--help) usage; exit 0;;
+    *) echo "Unknown arg: $1"; usage; exit 2;;
+  esac
+done
+
+if [ -z "$BUCKET" ] || [ -z "$ENDPOINT" ] || [ -z "$REGION" ] || [ -z "$KMS_KEY_ID" ] || [ -z "$BRANCH" ] || [ -z "$PR_TITLE" ]; then
+  usage
+  exit 2
+fi
+
+set -x
+
+# create branch
+git checkout -b "$BRANCH"
+
+# update values via Python helper
+chmod +x scripts/update_milvus_alibaba_values.py
+python3 scripts/update_milvus_alibaba_values.py --bucket "$BUCKET" --endpoint "$ENDPOINT" --region "$REGION" --kms-key-id "$KMS_KEY_ID" --service-account "$SERVICE_ACCOUNT"
+
+git add infra/overrides/alibaba/milvus-values-ack.yaml
+git commit -m "chore(alibaba): update milvus values for OSS backup (bucket=$BUCKET)"
+git push --set-upstream origin "$BRANCH"
+
+# open PR
+gh pr create --title "$PR_TITLE" --body "Update Milvus values for Alibaba OSS backups (automated)" --base main --head "$BRANCH"
+
+echo "PR created"
+
*** End Patch
*** Begin Patch
*** Add File: scripts/collect_verification_artifacts.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# collect_verification_artifacts.sh
+# Run verify_oss_access, collect pod logs, kubectl describe, events and save to a timestamped artifact directory.
+#
+# Usage:
+#  ./scripts/collect_verification_artifacts.sh --namespace N --ksa KSA --bucket BUCKET --out /tmp/artifacts
+#
+NAMESPACE=""
+KSA=""
+BUCKET=""
+OUT_DIR=""
+
+while [ $# -gt 0 ]; do
+  case "$1" in
+    --namespace) NAMESPACE="$2"; shift 2;;
+    --ksa) KSA="$2"; shift 2;;
+    --bucket) BUCKET="$2"; shift 2;;
+    --out) OUT_DIR="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 --namespace N --ksa KSA --bucket BUCKET [--out DIR]"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "$NAMESPACE" ] || [ -z "$KSA" ] || [ -z "$BUCKET" ]; then
+  echo "Missing args"
+  exit 2
+fi
+
+TS=$(date -u +"%Y%m%dT%H%M%SZ")
+OUT_DIR=${OUT_DIR:-/tmp/aegis-aliyun-verify-${TS}}
+mkdir -p "$OUT_DIR"
+
+echo "Running verifier pod and capturing artifacts into $OUT_DIR"
+set +e
+./scripts/verify_oss_access.sh --namespace "$NAMESPACE" --ksa "$KSA" --bucket "$BUCKET" > "$OUT_DIR/verifier_stdout.log" 2> "$OUT_DIR/verifier_stderr.log"
+VERIFIER_RET=$?
+set -e
+
+# Collect pods with that SA around time window
+kubectl -n "$NAMESPACE" get pods -o wide > "$OUT_DIR/pods.txt" || true
+
+# Collect events for KSA and recent pods
+kubectl -n "$NAMESPACE" get events --sort-by=.lastTimestamp > "$OUT_DIR/events.txt" || true
+
+# Collect logs for any pods containing 'verify' in name from that namespace
+for p in $(kubectl -n "$NAMESPACE" get pods -o name | grep -E 'verify|aliyun' || true); do
+  name=${p#pod/}
+  kubectl -n "$NAMESPACE" logs "$name" --tail=500 > "$OUT_DIR/pod_${name}_logs.txt" 2>&1 || true
+  kubectl -n "$NAMESPACE" describe pod "$name" > "$OUT_DIR/pod_${name}_describe.txt" 2>&1 || true
+done
+
+echo "Collected artifacts. Verifier exit code: $VERIFIER_RET"
+echo "Artifacts located in: $OUT_DIR"
+echo "Please attach the directory (tarball) or paste the verifier logs for triage."
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/create_alibaba_values_pr.yml
+name: Create Alibaba Milvus Values PR
+
+on:
+  workflow_dispatch:
+    inputs:
+      bucket:
+        description: "OSS bucket name"
+        required: true
+      endpoint:
+        description: "OSS endpoint (e.g., oss-cn-hangzhou.aliyuncs.com)"
+        required: true
+      region:
+        description: "Region (e.g., cn-hangzhou)"
+        required: true
+      kms_key_id:
+        description: "KMS key id"
+        required: true
+      branch:
+        description: "Branch name for PR"
+        required: true
+      pr_title:
+        description: "PR title"
+        required: true
+
+permissions:
+  contents: write
+
+jobs:
+  create-pr:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Setup python
+        uses: actions/setup-python@v4
+        with:
+          python-version: "3.10"
+
+      - name: Update values and create PR
+        env:
+          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+        run: |
+          chmod +x scripts/update_milvus_alibaba_values.py scripts/update_milvus_alibaba_values_and_create_pr.sh
+          ./scripts/update_milvus_alibaba_values_and_create_pr.sh \
+            --bucket "${{ github.event.inputs.bucket }}" \
+            --endpoint "${{ github.event.inputs.endpoint }}" \
+            --region "${{ github.event.inputs.region }}" \
+            --kms-key-id "${{ github.event.inputs.kms_key_id }}" \
+            --branch "${{ github.event.inputs.branch }}" \
+            --pr-title "${{ github.event.inputs.pr_title }}"
+
*** End Patch
*** Begin Patch
*** Add File: docs/alibaba_ack_trust_policy_examples.md
+Alibaba ACK OIDC / RAM trust policy examples
+===========================================
+
+This document shows example trust policies for RAM roles to be assumed by Kubernetes service accounts
+via OIDC provider. The exact "sub" claim format and provider host depends on your ACK setup.
+
+Example trust policy (replace OIDC_HOST, NAMESPACE, KSA):
+{
+  "Version": "1",
+  "Statement": [
+    {
+      "Effect": "Allow",
+      "Action": "sts:AssumeRole",
+      "Principal": {
+        "Federation": [
+          "oidc.eks.example.com"  # the OIDC provider host (strip https://)
+        ]
+      },
+      "Condition": {
+        "StringEquals": {
+          "oidc.eks.example.com:sub": "system:serviceaccount:my-namespace:my-service-account"
+        }
+      }
+    }
+  ]
+}
+
+Notes:
+- If your ACK cluster uses a different issuer or a specific federation name, substitute that in the Federation array.
+- Some ACK integrations expect the annotation key on the ServiceAccount to be different; inspect how other integrations annotate SAs in your cluster.
+
*** End Patch
