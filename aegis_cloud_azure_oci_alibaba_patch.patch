*** Begin Patch
*** Add File:terraform/azure/modules/keyvault/README.md
+# Azure Key Vault Terraform Module (scaffold -> operational)
+
+This module provisions:
+- Key Vault instance (for keys/certificates/secrets)
+- Key (or Key Vault Key) intended for Vault auto-unseal or cosign signing (placeholder)
+
+Operator notes:
+- Replace placeholders with your subscription ID, resource group, and region.
+- Ensure the Service Principal or managed identity used by Terraform has proper RBAC.
+- Validate Key Vault soft-delete and purge protection policies for your retention needs.
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/keyvault/variables.tf
+variable "name" { type = string }
+variable "location" { type = string }
+variable "resource_group_name" { type = string }
+variable "tags" { type = map(string) default = {} }
+variable "sku_name" { type = string default = "standard" }
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/keyvault/main.tf
+terraform {
+  required_providers {
+    azurerm = {
+      source  = "hashicorp/azurerm"
+      version = ">= 3.0"
+    }
+  }
+}
+
+provider "azurerm" {
+  features {}
+}
+
+resource "azurerm_key_vault" "kv" {
+  name                        = "${var.name}-kv"
+  location                    = var.location
+  resource_group_name         = var.resource_group_name
+  tenant_id                   = data.azurerm_client_config.current.tenant_id
+  sku_name                    = var.sku_name
+  purge_protection_enabled    = true
+  soft_delete_retention_days  = 90
+  tags                        = var.tags
+}
+
+data "azurerm_client_config" "current" {}
+
+# Example key (operator may create externally if needed)
+resource "azurerm_key_vault_key" "kv_key" {
+  name         = "${var.name}-sign-key"
+  key_vault_id = azurerm_key_vault.kv.id
+  key_type     = "RSA"
+  key_size     = 2048
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/keyvault/outputs.tf
+output "key_vault_id" { value = azurerm_key_vault.kv.id }
+output "key_vault_key_id" { value = azurerm_key_vault_key.kv_key.id }
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/blob/README.md
+# Azure Blob Storage (Scaffold)
+
+Create storage account and blob container for artifacts (MLflow, checkpoints).
+Operator: set appropriate access tiers, encryption (CMK if required), and lifecycle policies.
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/blob/variables.tf
+variable "name" { type = string }
+variable "location" { type = string }
+variable "resource_group_name" { type = string }
+variable "tags" { type = map(string) default = {} }
+variable "container_name" { type = string default = "aegis-artifacts" }
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/blob/main.tf
+resource "azurerm_storage_account" "sa" {
+  name                     = lower("${var.name}sa")
+  resource_group_name      = var.resource_group_name
+  location                 = var.location
+  account_tier             = "Standard"
+  account_replication_type = "LRS"
+  allow_blob_public_access = false
+  tags                     = var.tags
+}
+
+resource "azurerm_storage_container" "container" {
+  name                  = var.container_name
+  storage_account_name  = azurerm_storage_account.sa.name
+  container_access_type = "private"
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/modules/blob/outputs.tf
+output "storage_account_name" { value = azurerm_storage_account.sa.name }
+output "container_name" { value = azurerm_storage_container.container.name }
+
*** End File
*** Begin Patch
*** Add File:terraform/azure/runbook_azure.md
+# Azure runbook (operator)
+
+Steps to validate and enable production usage:
+1) Fill in Terraform variables in terraform/azure/ with subscription, resource group and names.
+2) Run `./scripts/azure/terraform_validate_and_apply.sh` (script added by patch) in terraform/azure/.
+3) Create a managed identity or service principal for Vault to access Key Vault for auto-unseal; ensure permissions: get, wrapKey, unwrapKey.
+4) Configure cosign signing:
+   - You can use `cosign sign --key azurekms://<vault-name>/keys/<key-name>` ; replace with your actual key URI.
+   - Alternatively, use Vault transit + cosign via experimental vault-transit wrapper.
+5) Configure VM/AKS node pools for GPU and attach network/storage per HPC runbook.
+
+Manual review points:
+- Key Vault access policies & purge_protection
+- Storage encryption with CMK if required by policy
+- Network & NSG rules limiting access to storage & Key Vault
+
*** End File
*** Begin Patch
*** Add File:scripts/azure/terraform_validate_and_apply.sh
+#!/usr/bin/env bash
+set -euo pipefail
+ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
+TF_DIR="$ROOT/terraform/azure"
+
+if [ -z "${ARM_CLIENT_ID:-}" ] || [ -z "${ARM_CLIENT_SECRET:-}" ] || [ -z "${ARM_TENANT_ID:-}" ] || [ -z "${ARM_SUBSCRIPTION_ID:-}" ]; then
+  echo "Please set ARM_CLIENT_ID, ARM_CLIENT_SECRET, ARM_TENANT_ID and ARM_SUBSCRIPTION_ID env vars"
+  exit 2
+fi
+
+pushd "$TF_DIR" >/dev/null
+terraform init
+terraform plan -out=tfplan
+echo "Inspect tfplan then run terraform apply -auto-approve tfplan if validated"
+popd >/dev/null
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/vault/README.md
+# OCI Vault (Vault-as-a-service / OCI Vault) scaffold
+
+This module creates an OCI Vault vault/Key used for Vault auto-unseal or signing.
+Operator: fill compartment OCID, tenancy OCID, and ensure policies permit usage.
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/vault/variables.tf
+variable "compartment_id" { type = string }
+variable "tenancy" { type = string }
+variable "region" { type = string }
+variable "name" { type = string }
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/vault/main.tf
+terraform {
+  required_providers {
+    oci = {
+      source = "hashicorp/oci"
+      version = ">= 4.0"
+    }
+  }
+}
+
+provider "oci" {}
+
+resource "oci_kms_vault" "vault" {
+  compartment_id = var.compartment_id
+  display_name   = var.name
+  vault_type     = "VIRTUAL_PRIVATE"
+}
+
+resource "oci_kms_key" "key" {
+  compartment_id = var.compartment_id
+  display_name   = "${var.name}-key"
+  vault_id       = oci_kms_vault.vault.id
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/vault/outputs.tf
+output "vault_id" { value = oci_kms_vault.vault.id }
+output "key_id" { value = oci_kms_key.key.id }
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/oss/README.md
+# OCI Object Storage (OSS) module
+
+Provision bucket and lifecycle for artifacts.
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/oss/variables.tf
+variable "compartment_id" { type = string }
+variable "namespace" { type = string }
+variable "bucket_name" { type = string }
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/oss/main.tf
+resource "oci_objectstorage_bucket" "bucket" {
+  namespace = var.namespace
+  compartment_id = var.compartment_id
+  name = var.bucket_name
+  metadata = {
+    "project" = "aegis"
+  }
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/oci/modules/oss/outputs.tf
+output "bucket_name" { value = oci_objectstorage_bucket.bucket.name }
+output "namespace" { value = var.namespace }
+
*** End File
*** Begin Patch
*** Add File:scripts/oci/terraform_validate_and_apply.sh
+#!/usr/bin/env bash
+set -euo pipefail
+ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
+TF_DIR="$ROOT/terraform/oci"
+
+if [ -z "${OCI_CLI_CONFIG_FILE:-}" ] && [ -z "${OCI_CLI_PROFILE:-}" ]; then
+  echo "Please ensure OCI CLI is configured or set OCI_CLI_PROFILE env var"
+fi
+
+pushd "$TF_DIR" >/dev/null
+terraform init
+terraform plan -out=tfplan
+echo "Review plan and apply when ready"
+popd >/dev/null
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/kms/README.md
+# Alibaba Cloud KMS module (scaffold)
+
+Creates a KMS key in Alibaba KMS for auto-unseal or signing.
+Operator: ensure RAM policy and region details are correct; Alibaba naming differs from other clouds.
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/kms/variables.tf
+variable "region" { type = string }
+variable "name" { type = string }
+variable "key_spec" { type = string default = "AES_256" }
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/kms/main.tf
+terraform {
+  required_providers {
+    alicloud = {
+      source  = "AlibabaCloud/alicloud"
+      version = ">= 1.150"
+    }
+  }
+}
+provider "alicloud" {
+  region = var.region
+}
+
+resource "alicloud_kms_key" "kmskey" {
+  name = "${var.name}-key"
+  description = "Aegis KMS key"
+  key_spec = var.key_spec
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/kms/outputs.tf
+output "alicloud_kms_key_id" { value = alicloud_kms_key.kmskey.id }
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/oss/README.md
+# Alibaba OSS module (scaffold)
+
+Provision OSS bucket for artifacts and configure lifecycle/replication as needed.
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/oss/variables.tf
+variable "region" { type = string }
+variable "bucket" { type = string }
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/oss/main.tf
+resource "alicloud_oss_bucket" "bucket" {
+  bucket = var.bucket
+  acl    = "private"
+}
+
*** End File
*** Begin Patch
*** Add File:terraform/alibaba/modules/oss/outputs.tf
+output "oss_bucket" { value = alicloud_oss_bucket.bucket.bucket }
+
*** End File
*** Begin Patch
*** Add File:docs/runbook_azure_oci_alibaba.md
+# Runbook: Bring Azure / OCI / Alibaba from scaffold -> operational
+
+Overview
+- This runbook lists the operator steps to make each cloud operational for Aegis, focusing on key management, artifact storage, cosign signing, and verification.
+
+Common pre-reqs
+- Operator API credentials and CLI installed (az cli, oci cli, aliyun cli).
+- Terraform installed and provider plugins available.
+- Vault running and operator has access to create roles/identities.
+
+Azure steps
+1. Fill terraform/azure variables and run scripts/azure/terraform_validate_and_apply.sh
+2. Create a managed identity for Vault (or use Service Principal). Grant Key Vault access policies: get, unwrapKey, wrapKey.
+3. Configure cosign:
+   - Example signing: cosign sign --key azurekms://<vault-name>/keys/<key-name> <image>
+   - Ensure cosign has access to Key Vault key via AAD permissions.
+4. Validate storage:
+   - Confirm blob container access and lifecycle rules.
+
+OCI steps
+1. Fill terraform/oci module vars and run scripts/oci/terraform_validate_and_apply.sh
+2. Create OCI vault key and grant policies to the principal used by Vault or CI
+3. Cosign signing example (operator must replace key URI):
+   - cosign sign --key oci://<key-ocid> <image>
+4. Validate object storage bucket and set proper retention.
+
+Alibaba steps
+1. Fill terraform/alibaba module vars and run scripts/alibaba/terraform_validate_and_apply.sh
+2. Ensure RAM policies allow the operator principal to use KMS keys.
+3. Cosign signing example placeholder:
+   - cosign sign --key alibabakms://<key-identifier> <image>  # vendor-specific URI; operator to verify
+
+Verification
+- Run a test CI job that builds a small image, signs it using the cloud KMS-backed key (or cosign key), pushes it to your registry, and attempts to deploy to staging with Gatekeeper policies (or manual check).
+- Run terraform outputs and confirm IDs/CRNs/OCIDs in outputs.
+
+Manual review & security checks
+- Ensure least-privilege for identities and service principals.
+- Verify audit logging & retention for KMS and storage.
+- Confirm network rules that restrict access to storage and KMS endpoints.
+
*** End File
*** Begin Patch
*** Add File:scripts/alibaba/terraform_validate_and_apply.sh
+#!/usr/bin/env bash
+set -euo pipefail
+ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
+TF_DIR="$ROOT/terraform/alibaba"
+
+if [ -z "${ALICLOUD_ACCESS_KEY:-}" ] || [ -z "${ALICLOUD_SECRET_KEY:-}" ]; then
+  echo "Please set ALICLOUD_ACCESS_KEY and ALICLOUD_SECRET_KEY env vars"
+  exit 2
+fi
+
+pushd "$TF_DIR" >/dev/null
+terraform init
+terraform plan -out=tfplan
+echo "Review plan; terraform apply -auto-approve tfplan to create resources when ready"
+popd >/dev/null
+
*** End File
*** Begin Patch
*** Add File:.github/workflows/cosign_multi_provider_example.yml
+name: Example: Build & Cosign using provider KMS (Azure/OCI/Alibaba placeholders)
+
+on:
+  workflow_dispatch:
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:pr-${{ github.run_id }}
+          docker build -t $IMAGE ./agents/controller
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Push image
+        run: |
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+
+      - name: Cosign sign with provider KMS (placeholder examples)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          # Azure Key Vault example:
+          # cosign sign --key azurekms://<vault-name>/keys/<key-name> $IMAGE
+
+          # OCI KMS example (operator to replace with proper key URI):
+          # cosign sign --key oci://<key-ocid> $IMAGE
+
+          # Alibaba KMS example (operator to validate provider URI):
+          # cosign sign --key alibabakms://<key-id> $IMAGE
+
+          echo "Operator: replace placeholder key URIs with real KMS key URIs and ensure runner has access."
+
*** End File
*** Begin Patch
*** Add File:docs/cloud_support_status_azure_oci_alibaba.md
+# Cloud support status & next steps â€” Azure / OCI / Alibaba
+
+Current state
+- Modules and scaffolds for Key Management and Object Storage added for Azure, OCI, Alibaba.
+- Validation scripts and runbooks provided to assist operator adoption.
+- CI examples show how to sign artifacts using KMS-backed keys (placeholders).
+
+What you must do to reach 'operational' for each cloud
+- Fill terraform variables and apply modules in a staging subscription/compartment/account.
+- Create service principals / managed identities with least privilege and bind them to KMS/key usage.
+- Configure cosign to use provider KMS URIs and test signing in CI.
+- Configure Vault to use provider KMS for auto-unseal (or use Vault transit backed by provider KMS).
+- Validate network rules, audit logging and retention.
+
+Acceptance criteria (per cloud)
+- KMS key exists and operator can sign an artifact via cosign with provider KMS URI.
+- Storage bucket/container accessible from staging cluster and protected by appropriate ACLs.
+- Terraform outputs contain the resource IDs and are stored in secure remote state.
+- A sample image is built, signed, pushed, and deployed in staging using signed-image admission gates.
+
*** End File
*** End Patch
