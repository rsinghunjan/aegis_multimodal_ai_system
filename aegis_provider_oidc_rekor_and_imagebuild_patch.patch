*** Begin Patch
*** Add File: scripts/ci/oci_oidc_exchange.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# oci_oidc_exchange.sh
+#
+# Purpose:
+#  - Retrieve GitHub Actions OIDC token from runner-provided endpoint
+#  - Run an operator-supplied EXCHANGE_CMD to exchange the OIDC token for OCI temporary credentials
+#  - Capture JSON output from the EXCHANGE_CMD and export environment variables for downstream steps:
+#      OCI_TENANT_OCID, OCI_USER_OCID, OCI_REGION, OCI_ACCESS_TOKEN (or other provider-specific fields)
+#
+# Usage (in GitHub Actions):
+#  - Set workflow permission: 'id-token: write'
+#  - Provide a repository secret OCI_EXCHANGE_CMD that is a command string to exchange the OIDC token, e.g.:
+#      "oci sts assume_role_with_oauth_token --token '<<TOKEN>>' --role-id ocid1.role.oc1..xxxxx --duration 3600 --output json"
+#    (Replace with the correct OCI CLI STS command for your tenancy / dynamic group; the example is illustrative.)
+#  - In the workflow, run:
+#      ./scripts/ci/oci_oidc_exchange.sh --env-out /tmp/oci_creds.env
+#
+# The script will substitute the literal '<<TOKEN>>' within EXCHANGE_CMD with the retrieved OIDC id_token.
+#
+OUT_ENV_FILE="/tmp/oci_oidc_creds.env"
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --env-out) OUT_ENV_FILE="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 [--env-out /path/to/file]"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]; then
+  echo "This script must run inside GitHub Actions with 'id-token: write' permission or runner must provide ACTIONS_ID_TOKEN_REQUEST_URL and ACTIONS_ID_TOKEN_REQUEST_TOKEN."
+  exit 2
+fi
+
+if [ -z "${OCI_EXCHANGE_CMD:-}" ]; then
+  echo "Please set OCI_EXCHANGE_CMD env var (preferably as a repo secret) describing the provider-specific exchange command. Example placeholder:"
+  echo "  export OCI_EXCHANGE_CMD=\"oci sts assume_role_with_oauth_token --token '<<TOKEN>>' --role-arn <role> --duration 3600 --output json\""
+  exit 2
+fi
+
+echo "Requesting OIDC token from GitHub Actions endpoint..."
+ID_TOKEN_JSON=$(curl -s -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL")
+ID_TOKEN=$(echo "$ID_TOKEN_JSON" | jq -r .value)
+if [ -z "$ID_TOKEN" ] || [ "$ID_TOKEN" = "null" ]; then
+  echo "Failed to obtain id_token from GitHub Actions endpoint. Response: $ID_TOKEN_JSON"
+  exit 2
+fi
+
+echo "Obtained OIDC token. Running EXCHANGE_CMD..."
+# Replace the placeholder <<TOKEN>> with the actual token for the exchange command
+CMD="${OCI_EXCHANGE_CMD//<<TOKEN>>/$ID_TOKEN}"
+echo "Running exchange command (obscured output)"
+EXCHANGE_OUTPUT=$(bash -lc "$CMD" 2>/dev/null || true)
+if [ -z "$EXCHANGE_OUTPUT" ]; then
+  echo "Exchange command produced no output. Please ensure EXCHANGE_CMD is correct and the tenant is configured for federation."
+  exit 2
+fi
+
+echo "Exchange command output captured. Saving raw output for operator inspection to /tmp/oci_exchange_raw.json"
+echo "$EXCHANGE_OUTPUT" > /tmp/oci_exchange_raw.json
+
+# Attempt to parse common fields (operator must ensure EXCHANGE_CMD outputs JSON with known keys)
+# The script maps common fields; adapt as needed for your exact EXCHANGE_CMD output structure.
+OCI_ACCESS_KEY=$(echo "$EXCHANGE_OUTPUT" | jq -r '.data.token' 2>/dev/null || true)
+OCI_SESSION_TOKEN=$(echo "$EXCHANGE_OUTPUT" | jq -r '.data.stsToken' 2>/dev/null || true)
+
+cat > "$OUT_ENV_FILE" <<EOF
+# OCI OIDC exchanged credentials (generated at $(date -u +"%Y-%m-%dT%H:%M:%SZ"))
+OCI_EXCHANGE_RAW=/tmp/oci_exchange_raw.json
+OCI_ACCESS_OUTPUT=$(echo "$EXCHANGE_OUTPUT" | jq -c '.' 2>/dev/null || echo "")
+EOF
+
+echo "Wrote environment wrapper to $OUT_ENV_FILE. Downstream steps can source this file to pick up credentials."
+echo "NOTE: You must adapt the exchange command to emit usable credentials for cosign KMS access or set up provider-specific cli config to use the session token."
+
*** End Patch
*** Begin Patch
*** Add File: scripts/ci/alibaba_oidc_exchange.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# alibaba_oidc_exchange.sh
+#
+# Purpose:
+#  - Retrieve GitHub Actions OIDC token
+#  - Run an operator-supplied EXCHANGE_CMD that exchanges the OIDC token for Alibaba temporary credentials (via STS)
+#  - Output a small env file that downstream steps can source
+#
+# Usage:
+#  - Provide ALICLOUD_EXCHANGE_CMD as a secret/ENV, e.g.:
+#      "aliyun sts AssumeRoleWithWebIdentity --WebIdentityToken '<<TOKEN>>' --RoleArn 'acs:ram::123456789:role/..' --RoleSessionName gha-oidc --output json"
+#    (Replace with your configured operator-specific command)
+#  - Run in workflow: ./scripts/ci/alibaba_oidc_exchange.sh --env-out /tmp/alibaba_creds.env
+
+OUT_ENV_FILE="/tmp/alibaba_oidc_creds.env"
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --env-out) OUT_ENV_FILE="$2"; shift 2;;
+    -h|--help) echo "Usage: $0 [--env-out /path]"; exit 0;;
+    *) echo "Unknown arg: $1"; exit 2;;
+  esac
+done
+
+if [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]; then
+  echo "This script must run in GitHub Actions with 'id-token: write' permission."
+  exit 2
+fi
+
+if [ -z "${ALICLOUD_EXCHANGE_CMD:-}" ]; then
+  echo "Please set ALICLOUD_EXCHANGE_CMD env var (repo secret). Example:"
+  echo "  export ALICLOUD_EXCHANGE_CMD=\"aliyun sts AssumeRoleWithWebIdentity --WebIdentityToken '<<TOKEN>>' --RoleArn 'acs:ram::12345:role/role' --RoleSessionName gha-oidc --output json\""
+  exit 2
+fi
+
+echo "Requesting OIDC token..."
+ID_TOKEN_JSON=$(curl -s -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL")
+ID_TOKEN=$(echo "$ID_TOKEN_JSON" | jq -r .value)
+if [ -z "$ID_TOKEN" ] || [ "$ID_TOKEN" = "null" ]; then
+  echo "Failed to obtain id_token from GitHub Actions endpoint. Response: $ID_TOKEN_JSON"
+  exit 2
+fi
+
+CMD="${ALICLOUD_EXCHANGE_CMD//<<TOKEN>>/$ID_TOKEN}"
+echo "Running exchange command..."
+EXCHANGE_OUTPUT=$(bash -lc "$CMD" 2>/dev/null || true)
+echo "$EXCHANGE_OUTPUT" > /tmp/alibaba_exchange_raw.json
+
+cat > "$OUT_ENV_FILE" <<EOF
+# Alibaba OIDC exchanged credentials (raw)
+ALICLOUD_EXCHANGE_RAW=/tmp/alibaba_exchange_raw.json
+ALICLOUD_EXCHANGE_OUTPUT=$(echo "$EXCHANGE_OUTPUT" | jq -c '.' 2>/dev/null || echo "")
+EOF
+
+echo "Wrote env file to $OUT_ENV_FILE. Adapt downstream steps to parse the STS response into credentials for cosign usage."
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/build_image_verifier.yml
+name: Build & Publish Aegis Image Verifier
+
+on:
+  workflow_dispatch:
+  push:
+    paths:
+      - "security/image-verifier/**"
+
+permissions:
+  contents: read
+  packages: write
+
+jobs:
+  build-publish:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout repo
+        uses: actions/checkout@v4
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v2
+
+      - name: Log in to GHCR
+        uses: docker/login-action@v2
+        with:
+          registry: ghcr.io
+          username: ${{ github.actor }}
+          password: ${{ secrets.GHCR_PAT }}
+
+      - name: Build and push image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-image-verifier:latest
+          docker build -t $IMAGE ./security/image-verifier
+          docker push $IMAGE
+          echo "PUBLISHED_IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Upload image info
+        uses: actions/upload-artifact@v4
+        with:
+          name: image-verifier-info
+          path: |
+            <<< "$IMAGE"
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/oci_oidc_cosign_sign.yml
+name: Build & Sign (OCI KMS) - OIDC (finalized to use exchange script)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write
+  contents: read
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Install dependencies
+        run: |
+          sudo apt-get update && sudo apt-get install -y jq python3-pip
+          pip3 install --user oci
+
+      - name: Request OIDC and exchange for OCI credentials
+        env:
+          OCI_EXCHANGE_CMD: ${{ secrets.OCI_EXCHANGE_CMD }}   # operator provides command with <<TOKEN>> placeholder
+        run: |
+          chmod +x scripts/ci/oci_oidc_exchange.sh
+          ./scripts/ci/oci_oidc_exchange.sh --env-out /tmp/oci_creds.env
+          cat /tmp/oci_creds.env
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "Pushing $IMAGE"
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image using OCI KMS via cosign (uses provider credentials established above)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+          REKOR_SERVER: ${{ secrets.REKOR_SERVER }}
+          OCI_KEY_URI: ${{ secrets.OCI_KEY_URI }}
+        run: |
+          # Operator: Ensure that your EXCHANGE_CMD configured above set up the OCI CLI to use session credentials or
+          # exported credentials so cosign can access the OCI KMS via the configured OCI CLI environment.
+          if [ -z "$OCI_KEY_URI" ]; then echo "OCI_KEY_URI not set"; exit 1; fi
+          cosign sign --key "$OCI_KEY_URI" --rekor-server "$REKOR_SERVER" $IMAGE
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/alibaba_oidc_cosign_sign.yml
+name: Build & Sign (Alibaba KMS) - OIDC (finalized to use exchange script)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write
+  contents: read
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Install deps
+        run: |
+          sudo apt-get update && sudo apt-get install -y jq python3-pip
+          pip3 install --user aliyun-python-sdk-core aliyun-python-sdk-sts
+
+      - name: Request OIDC and exchange for Alibaba credentials
+        env:
+          ALICLOUD_EXCHANGE_CMD: ${{ secrets.ALICLOUD_EXCHANGE_CMD }}
+        run: |
+          chmod +x scripts/ci/alibaba_oidc_exchange.sh
+          ./scripts/ci/alibaba_oidc_exchange.sh --env-out /tmp/alibaba_creds.env
+          cat /tmp/alibaba_creds.env
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "Pushing $IMAGE"
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image using Alibaba KMS via cosign
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+          REKOR_SERVER: ${{ secrets.REKOR_SERVER }}
+          ALICLOUD_KEY_URI: ${{ secrets.ALICLOUD_KEY_URI }}
+        run: |
+          if [ -z "$ALICLOUD_KEY_URI" ]; then echo "ALICLOUD_KEY_URI not set"; exit 1; fi
+          cosign sign --key "$ALICLOUD_KEY_URI" --rekor-server "$REKOR_SERVER" $IMAGE
+
*** End Patch
*** End Patch
