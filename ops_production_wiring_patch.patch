*** Begin Patch
*** Add File:ops/wire_providers_and_secrets.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Wire provider secrets to GitHub and create ExternalSecrets manifests in cluster.
+# This script DOES NOT write any secret values to git — it pushes secrets to GitHub
+# and creates ExternalSecret CRs that reference Secrets Manager keys (operator must create SM secrets).
+#
+# Required env:
+#   REPO                e.g. owner/repo
+#   OPENAI_API_KEY_ARN  (optional) ARN or name in Secrets Manager referencing OpenAI key
+#   HF_API_TOKEN_ARN    (optional)
+#   S3_EVIDENCE_ARN     (optional)
+#   COSIGN_KMS_ARN      (optional)
+#   REKOR_URL           (optional)
+#   ECR_REGISTRY        (optional) e.g. 123456789012.dkr.ecr.us-east-1.amazonaws.com
+#
+REPO=${REPO:-REPLACE_GITHUB_REPOSITORY}
+NAMESPACE=${NAMESPACE:-aegis}
+
+echo "[wire] Validating environment..."
+if ! command -v gh >/dev/null; then
+  echo "gh CLI not found; install and authenticate first"
+  exit 2
+fi
+
+set +u
+if [ -n "${OPENAI_API_KEY_ARN:-}" ]; then
+  echo "Creating GitHub secret OPENAI_API_KEY (placeholder stored in ExternalSecrets) — not writing secret value here"
+  gh secret set OPENAI_API_KEY --repo "${REPO}" --body "please-set-in-external-secrets"
+fi
+if [ -n "${HF_API_TOKEN_ARN:-}" ]; then
+  gh secret set HF_API_TOKEN --repo "${REPO}" --body "please-set-in-external-secrets"
+fi
+if [ -n "${COSIGN_KMS_ARN:-}" ]; then
+  gh secret set COSIGN_KMS_ARN --repo "${REPO}" --body "${COSIGN_KMS_ARN}"
+fi
+if [ -n "${REKOR_URL:-}" ]; then
+  gh secret set REKOR_URL --repo "${REPO}" --body "${REKOR_URL}"
+fi
+if [ -n "${ECR_REGISTRY:-}" ]; then
+  gh secret set ECR_REGISTRY --repo "${REPO}" --body "${ECR_REGISTRY}"
+fi
+set -u
+
+echo "[wire] Applying ExternalSecrets templates (ensure ExternalSecrets operator is installed)"
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+kubectl apply -n "${NAMESPACE}" -f k8s/external-secrets/providers-externalsecret.yaml || true
+
+echo "[wire] Done. Verify:"
+echo "  gh secret list --repo ${REPO}"
+echo "  kubectl -n ${NAMESPACE} get externalsecret"
+
*** End Patch
*** Begin Patch
*** Add File:k8s/external-secrets/providers-externalsecret.yaml
+apiVersion: external-secrets.io/v1beta1
+kind: SecretStore
+metadata:
+  name: aws-secrets-manager
+  namespace: aegis
+spec:
+  provider:
+    aws:
+      service: SecretsManager
+      region: REPLACE_AWS_REGION
+      auth:
+        jwt:
+          serviceAccountRef:
+            name: externalsecrets-sa
+            namespace: aegis
+
+---
+apiVersion: external-secrets.io/v1beta1
+kind: ExternalSecret
+metadata:
+  name: provider-keys
+  namespace: aegis
+spec:
+  refreshInterval: "1h"
+  secretStoreRef:
+    name: aws-secrets-manager
+    kind: SecretStore
+  target:
+    name: aegis-runtime-secrets
+    creationPolicy: Owner
+  data:
+    - secretKey: OPENAI_API_KEY
+      remoteRef:
+        key: "aegis/keys/openai"
+        property: "api_key"
+    - secretKey: HF_API_TOKEN
+      remoteRef:
+        key: "aegis/keys/hf"
+        property: "api_token"
+    - secretKey: EVIDENCE_BUCKET
+      remoteRef:
+        key: "aegis/s3/evidence"
+        property: "bucket"
+    - secretKey: COSIGN_KMS_ARN
+      remoteRef:
+        key: "aegis/cosign"
+        property: "kms_arn"
+    - secretKey: REKOR_URL
+      remoteRef:
+        key: "aegis/cosign"
+        property: "rekor_url"
+
*** End Patch
*** Begin Patch
*** Add File:terraform/irsa/irsa_annotate_sa.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Annotate Kubernetes ServiceAccounts with IAM Role ARNs returned from terraform output JSON.
+# Usage:
+#   ./irsa_annotate_sa.sh /tmp/irsa_outputs.json
+OUT=${1:-/tmp/irsa_outputs.json}
+if [ ! -f "${OUT}" ]; then
+  echo "Terraform output JSON not found at ${OUT}"
+  exit 2
+fi
+
+echo "Reading terraform outputs..."
+ROLEMAP=$(jq -r 'to_entries[] | [.key, .value.value] | @tsv' "${OUT}" 2>/dev/null || true)
+if [ -z "${ROLEMAP}" ]; then
+  echo "No outputs found to annotate"
+  exit 0
+fi
+
+echo "Annotating ServiceAccounts..."
+while IFS=$'\t' read -r key val; do
+  # Expect output keys like inference_adapter_role_arn => "arn:aws:iam::123:role/..."
+  # Map known keys to SA names:
+  case "${key}" in
+    inference_adapter_role_arn) SA="inference-adapter-sa" ;;
+    rag_service_role_arn) SA="rag-service-sa" ;;
+    externalsecrets_role_arn) SA="externalsecrets-sa" ;;
+    agent_orchestrator_role_arn) SA="agent-orchestrator" ;;
+    sandbox_runner_role_arn) SA="sandbox-runner" ;;
+    *) SA="" ;;
+  esac
+  if [ -n "${SA}" ]; then
+    echo "Annotating SA ${SA} with role ${val} in namespace aegis"
+    kubectl -n aegis annotate serviceaccount "${SA}" eks.amazonaws.com/role-arn="${val}" --overwrite
+  else
+    echo "Skipping unknown key ${key}"
+  fi
+done < <(echo "${ROLEMAP}")
+
+echo "Annotation completed."
+
*** End Patch
*** Begin Patch
*** Add File:k8s/inference/clip-model-server-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: clip-model-server
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: clip-model-server
+  template:
+    metadata:
+      labels:
+        app: clip-model-server
+    spec:
+      serviceAccountName: inference-adapter-sa
+      containers:
+        - name: model-server
+          image: REPLACE_IMAGE_REGISTRY/clip-model-server:latest
+          ports:
+            - containerPort: 8080
+          resources:
+            limits:
+              nvidia.com/gpu: "1"
+              memory: "24Gi"
+              cpu: "4000m"
+            requests:
+              nvidia.com/gpu: "1"
+              memory: "12Gi"
+              cpu: "2000m"
+          env:
+            - name: MODEL_CACHE_PATH
+              value: "/models"
+          volumeMounts:
+            - name: model-cache
+              mountPath: /models
+      volumes:
+        - name: model-cache
+          emptyDir: {}
+      tolerations:
+        - key: "nvidia.com/gpu"
+          operator: "Exists"
+      nodeSelector:
+        accelerator: nvidia
+
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: clip-model-server
+  namespace: aegis
+spec:
+  selector:
+    app: clip-model-server
+  ports:
+    - port: 8080
+      targetPort: 8080
+
*** End Patch
*** Begin Patch
*** Add File:ops/deploy_whisperx_service.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Deploy a WhisperX transcription service as a long-running deployment with an autoscaler.
+# This script applies manifests. Replace REPLACE_IMAGE_REGISTRY with your image.
+kubectl create namespace aegis --dry-run=client -o yaml | kubectl apply -f -
+cat <<EOF | kubectl apply -f -
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: whisperx-transcriber
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: whisperx
+  template:
+    metadata:
+      labels:
+        app: whisperx
+    spec:
+      serviceAccountName: transcriber-sa
+      containers:
+        - name: whisperx
+          image: REPLACE_IMAGE_REGISTRY/whisperx:latest
+          ports:
+            - containerPort: 8085
+          resources:
+            requests:
+              cpu: "1000m"
+              memory: "4Gi"
+            limits:
+              cpu: "4000m"
+              memory: "16Gi"
+EOF
+
+kubectl autoscale deployment/whisperx-transcriber -n aegis --min=1 --max=3 --cpu-percent=70 || true
+echo "WhisperX deployment applied. Configure input S3 bucket or persistent volume and pipeline connectors."
+
*** End Patch
*** Begin Patch
*** Add File:ops/install_weaviate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Install Weaviate via Helm (example). Configure persistence, replicas and API key in env/values.
+NAMESPACE=${NAMESPACE:-aegis}
+helm repo add weaviate https://weaviate.github.io/weaviate-helm-charts || true
+helm repo update
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+cat <<EOF > /tmp/weaviate-values.yaml
+replicaCount: 2
+service:
+  type: ClusterIP
+auth:
+  apiKey: "REPLACE_WEAVIATE_API_KEY"
+persistence:
+  enabled: true
+  size: 50Gi
+resources:
+  requests:
+    cpu: 500m
+    memory: 1Gi
+EOF
+
+helm upgrade --install weaviate weaviate/weaviate -n "${NAMESPACE}" -f /tmp/weaviate-values.yaml --wait
+echo "Weaviate installed. Create schema and classes via Weaviate REST API."
+
*** End Patch
*** Begin Patch
*** Add File:ops/cosign_rekor_workflow.yml
+name: Build, Push & Cosign (KMS) + Rekor
+
+on:
+  push:
+    branches:
+      - main
+
+jobs:
+  build_and_sign:
+    runs-on: ubuntu-latest
+    permissions:
+      contents: read
+      id-token: write
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up QEMU
+        uses: docker/setup-qemu-action@v2
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v2
+      - name: Login to ECR
+        uses: aws-actions/amazon-ecr-login@v2
+        with:
+          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
+      - name: Build and push
+        run: |
+          IMAGE=${{ secrets.ECR_REGISTRY }}/aegis/inference-adapter:${GITHUB_SHA::8}
+          docker build -t $IMAGE -f ops/llm/inference_adapter/Dockerfile .
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+      - name: Cosign sign image (KMS)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          cosign sign --key k8s://$COSIGN_KMS_ARN $IMAGE
+        # Note: set COSIGN_KMS_ARN as a repository secret or ExternalSecret
+
*** End Patch
*** Begin Patch
*** Add File:k8s/admission/carbon-webhook.yaml
+apiVersion: v1
+kind: Service
+metadata:
+  name: carbon-admission
+  namespace: aegis
+spec:
+  ports:
+    - port: 8443
+      targetPort: 8443
+  selector:
+    app: carbon-admission
+
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: carbon-admission
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: carbon-admission
+  template:
+    metadata:
+      labels:
+        app: carbon-admission
+    spec:
+      containers:
+        - name: webhook
+          image: REPLACE_IMAGE_REGISTRY/carbon-admission:latest
+          ports:
+            - containerPort: 8443
+          args: ["--tls-cert-file=/cert/tls.crt","--tls-key-file=/cert/tls.key"]
+          volumeMounts:
+            - name: webhook-certs
+              mountPath: /cert
+              readOnly: true
+      volumes:
+        - name: webhook-certs
+          secret:
+            secretName: carbon-admission-tls
+
*** End Patch
*** Begin Patch
*** Add File:k8s/admission/validatingwebhookconfiguration.yaml
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-carbon-webhook
+webhooks:
+  - name: carbon.aegis.example.com
+    admissionReviewVersions: ["v1"]
+    clientConfig:
+      service:
+        name: carbon-admission
+        namespace: aegis
+        path: /validate
+      caBundle: REPLACE_CA_BUNDLE_BASE64
+    rules:
+      - apiGroups: [""]
+        apiVersions: ["v1"]
+        operations: ["CREATE"]
+        resources: ["pods","jobs"]
+    failurePolicy: Fail
+    sideEffects: None
+    timeoutSeconds: 5
+
*** End Patch
*** Begin Patch
*** Add File:ops/provenance/cosign_sign_and_upload_evidence.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Sign an evidence JSON with cosign (KMS-backed) and upload signed blob and entry to Rekor (cosign does Rekor logging).
+# Then upload the signed blob and metadata to S3 evidence bucket.
+EVIDENCE_FILE=${1:-}
+BUCKET=${EVIDENCE_BUCKET:-REPLACE_EVIDENCE_BUCKET}
+
+if [ -z "${EVIDENCE_FILE}" ]; then
+  echo "Usage: $0 path/to/evidence.json"
+  exit 2
+fi
+
+if [ -z "${COSIGN_KMS_ARN:-}" ]; then
+  echo "COSIGN_KMS_ARN not set; set it in environment or ExternalSecrets"
+  exit 1
+fi
+
+TMP_SIG=$(mktemp)
+echo "Signing ${EVIDENCE_FILE} with cosign (KMS)"
+cosign sign-blob --kms "${COSIGN_KMS_ARN}" -key "${COSIGN_KMS_ARN}" --output-signature "${TMP_SIG}" "${EVIDENCE_FILE}"
+
+echo "Uploading ${EVIDENCE_FILE} and signature to s3://${BUCKET}/evidence/"
+aws s3 cp "${EVIDENCE_FILE}" "s3://${BUCKET}/evidence/$(basename ${EVIDENCE_FILE})"
+aws s3 cp "${TMP_SIG}" "s3://${BUCKET}/evidence/$(basename ${EVIDENCE_FILE}).sig"
+
+echo "Signed evidence uploaded. Rekor entry created by cosign (if configured)."
+
*** End Patch
*** Begin Patch
*** Add File:ops/sanitizer/pii_redact.py
+#!/usr/bin/env python3
+"""
+Basic PII redaction utility.
+Will redact emails, credit-card-like numbers and simple SSN patterns.
+Extend with DLP/ML models for production.
+"""
+import re
+import sys
+import json
+
+EMAIL_RE = re.compile(r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)")
+CC_RE = re.compile(r"\b(?:\d[ -]*?){13,16}\b")
+SSN_RE = re.compile(r"\b\d{3}-\d{2}-\d{4}\b")
+
+def redact(text: str) -> str:
+    text = EMAIL_RE.sub("[REDACTED_EMAIL]", text)
+    text = CC_RE.sub("[REDACTED_CREDIT_CARD]", text)
+    text = SSN_RE.sub("[REDACTED_SSN]", text)
+    return text
+
+def main():
+    if len(sys.argv) < 2:
+        print("Usage: pii_redact.py input.txt [output.txt]")
+        sys.exit(2)
+    fin = sys.argv[1]
+    fout = sys.argv[2] if len(sys.argv) > 2 else None
+    with open(fin, "r") as fh:
+        data = fh.read()
+    red = redact(data)
+    if fout:
+        with open(fout, "w") as fh:
+            fh.write(red)
+    else:
+        print(red)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:ops/tests/run_security_tests.sh
+#!/usr/bin/env bash
+set -euo pipefail
+echo "[tests] Running prompt injection tests..."
+python3 tests/prompt_injection_tests.py
+echo "[tests] Running PII sanitizer tests..."
+python3 - <<PY
+from ops.sanitizer.pii_redact import redact
+sample="Contact me at badguy@example.com or cc 4111 1111 1111 1111 and SSN 123-45-6789"
+red=redact(sample)
+assert "[REDACTED_EMAIL]" in red
+assert "[REDACTED_CREDIT_CARD]" in red
+assert "[REDACTED_SSN]" in red
+print("PII sanitizer test passed")
+PY
+echo "[tests] Security tests completed (basic). Expand with adversarial and pentest suites."
+
*** End Patch
*** Begin Patch
*** Add File:monitoring/alertmanager/alertmanager-config.yaml
+global:
+  resolve_timeout: 5m
+route:
+  receiver: "team-pager"
+receivers:
+  - name: "team-pager"
+    webhook_configs:
+      - url: "https://hooks.slack.com/services/REPLACE/SLACK/HOOK"
+        send_resolved: true
+
*** End Patch
*** Begin Patch
*** Add File:docs/runbooks/production_wiring.md
+# Production Wiring Runbook (concise)
+
+This runbook describes steps to wire providers, deploy inference & transcription services, vector DB, admission webhook, and hardening tests.
+
+1) Wire providers & secrets
+  - Create Secrets Manager entries for:
+    - aegis/keys/openai -> {api_key}
+    - aegis/keys/hf -> {api_token}
+    - aegis/s3/evidence -> {bucket}
+    - aegis/cosign -> {kms_arn, rekor_url}
+  - Set REPO env and run:
+    ./ops/wire_providers_and_secrets.sh
+  - Apply ExternalSecrets and verify aegis-runtime-secrets created.
+
+2) Apply IRSA and annotate SAs
+  - cp terraform/irsa/my.tfvars.example terraform/irsa/my.tfvars (edit locally)
+  - ./ops/apply_irsa_and_annotate.sh terraform/irsa/my.tfvars
+  - ./terraform/irsa/irsa_annotate_sa.sh /tmp/irsa_outputs.json
+
+3) Deploy CLIP model server (GPU)
+  - Build and push GPU model-server image: REPLACE_IMAGE_REGISTRY/clip-model-server:latest
+  - kubectl apply -f k8s/inference/clip-model-server-deployment.yaml
+  - Ensure GPU nodes labeled and Nvidia device plugin installed
+
+4) Deploy WhisperX transcription service
+  - Build/push whisperx image and run:
+    ./ops/deploy_whisperx_service.sh
+
+5) Deploy vector DB (Weaviate)
+  - ./ops/install_weaviate.sh
+  - Create class/schema via Weaviate API and configure API key in ExternalSecrets
+  - Run Argo embed workflows to populate index
+
+6) Enable carbon admission webhook
+  - Create TLS cert secret carbon-admission-tls (use cert-manager recommended)
+  - kubectl apply -f k8s/admission/carbon-webhook.yaml
+  - kubectl apply -f k8s/admission/validatingwebhookconfiguration.yaml (replace CA_BUNDLE)
+
+7) Wire cosign/KMS signing in CI
+  - Add COSIGN_KMS_ARN, REKOR_URL, ECR_REGISTRY secrets to GitHub and enable workflow .github/workflows/cosign_rekor_workflow.yml
+
+8) Run security tests
+  - ./ops/tests/run_security_tests.sh
+
+9) Observability & Alerts
+  - Apply PrometheusRule manifests and import Grafana dashboard (use JSON in k8s/monitoring)
+  - Apply alertmanager config monitoring/alertmanager/alertmanager-config.yaml and configure receivers
+
+10) Provenance signing
+  - Use ops/provenance/cosign_sign_and_upload_evidence.sh to sign and upload evidence artifacts to S3
+
+Notes
+- Replace all REPLACE_* placeholders with your values before applying.
+- Do not commit secrets or tfvars to git.
+- Test each component in staging before promoting to production.
+
*** End Patch
*** End Patch
