*** Begin Patch
*** Add File:terraform/azure/main.tf
+module "keyvault" {
+  source = "./modules/keyvault"
+  name   = var.resource_prefix
+  location = var.location
+  resource_group_name = var.resource_group
+}
+
+module "blob" {
+  source = "./modules/blob"
+  name   = var.resource_prefix
+  location = var.location
+  resource_group_name = var.resource_group
+  container_name = var.container_name
+}
+
+output "key_vault_id" {
+  value = module.keyvault.key_vault_id
+}
+output "key_vault_key_id" {
+  value = module.keyvault.key_vault_key_id
+}
+output "storage_account_name" {
+  value = module.blob.storage_account_name
+}
+output "container_name" {
+  value = module.blob.container_name
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/azure/variables.tf
+variable "resource_prefix" { type = string }
+variable "location" { type = string }
+variable "resource_group" { type = string }
+variable "container_name" { type = string default = "aegis-artifacts" }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/azure/example.tfvars
+resource_prefix = "aegis-demo"
+location        = "eastus"
+resource_group  = "rg-aegis-demo"
+container_name  = "aegis-artifacts"
+
*** End Patch
*** Begin Patch
*** Add File:terraform/oci/main.tf
+module "vault" {
+  source = "./modules/vault"
+  compartment_id = var.compartment_id
+  tenancy = var.tenancy
+  region = var.region
+  name = var.resource_prefix
+}
+
+module "oss" {
+  source = "./modules/oss"
+  compartment_id = var.compartment_id
+  namespace = var.namespace
+  bucket_name = var.bucket_name
+}
+
+output "oci_vault_id" { value = module.vault.vault_id }
+output "oci_kms_key_id" { value = module.vault.key_id }
+output "oci_bucket_name" { value = module.oss.bucket_name }
+output "oci_namespace" { value = module.oss.namespace }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/oci/variables.tf
+variable "compartment_id" { type = string }
+variable "tenancy" { type = string }
+variable "region" { type = string }
+variable "resource_prefix" { type = string }
+variable "namespace" { type = string }
+variable "bucket_name" { type = string }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/oci/example.tfvars
+compartment_id = "ocid1.compartment.oc1..example"
+tenancy = "ocid1.tenancy.oc1..example"
+region = "us-ashburn-1"
+resource_prefix = "aegis-demo"
+namespace = "example-namespace"
+bucket_name = "aegis-artifacts"
+
*** End Patch
*** Begin Patch
*** Add File:terraform/alibaba/main.tf
+module "kms" {
+  source = "./modules/kms"
+  region = var.region
+  name = var.resource_prefix
+}
+
+module "oss" {
+  source = "./modules/oss"
+  region = var.region
+  bucket = var.bucket_name
+}
+
+output "alicloud_kms_key_id" { value = module.kms.alicloud_kms_key_id }
+output "alibaba_oss_bucket" { value = module.oss.oss_bucket }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/alibaba/variables.tf
+variable "region" { type = string }
+variable "resource_prefix" { type = string }
+variable "bucket_name" { type = string }
+
*** End Patch
*** Begin Patch
*** Add File:terraform/alibaba/example.tfvars
+region = "cn-hangzhou"
+resource_prefix = "aegis-demo"
+bucket_name = "aegis-artifacts"
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/azure_cosign_sign.yml
+name: Build & Sign (Azure Key Vault)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  contents: read
+  packages: write
+  id-token: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v2
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Push image
+        run: |
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+
+      - name: Cosign sign with Azure Key Vault (placeholder)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          # Replace with your azure key vault key URI (example: azurekms://vault-name.vault.azure.net/keys/key-name@v1)
+          AZURE_KEY_URI="${{ secrets.AZURE_KEY_URI }}"
+          if [ -z "$AZURE_KEY_URI" ]; then
+            echo "AZURE_KEY_URI secret not set; aborting signing step"
+            exit 1
+          fi
+          cosign sign --key "$AZURE_KEY_URI" $IMAGE
+
+      - name: Export public key (if allowed) and upload artifact
+        run: |
+          mkdir -p artifacts
+          # Attempt to use cosign to create a public key file from key reference (some KMS providers may not allow direct export).
+          # If your provider supports exporting public key via cosign, use the appropriate command here; otherwise, export from Vault or provider console.
+          # Placeholder: no-op but create an empty pub.pem instructing operator to replace it.
+          echo "Operator: replace with provider-specific public key export if available" > artifacts/pub-azure.pem
+          echo "Signed $IMAGE" > artifacts/signed-image.txt
+        shell: bash
+
+      - name: Upload public key artifact (operator: download and create k8s secret)
+        uses: actions/upload-artifact@v4
+        with:
+          name: azure-pubkey
+          path: artifacts/
+
+      - name: Note for operator
+        run: |
+          echo "Download the azure-pubkey artifact from this workflow run and install pub-azure.pem into your cluster as a Secret (ops/aegis-cosign-pub)."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/oci_cosign_sign.yml
+name: Build & Sign (OCI KMS)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  contents: read
+  packages: write
+  id-token: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Push image
+        run: |
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+
+      - name: Cosign sign with OCI KMS (placeholder)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          OCI_KEY_URI="${{ secrets.OCI_KEY_URI }}"
+          if [ -z "$OCI_KEY_URI" ]; then
+            echo "OCI_KEY_URI not set; aborting signing step"
+            exit 1
+          fi
+          cosign sign --key "$OCI_KEY_URI" $IMAGE
+
+      - name: Create artifact placeholder and upload
+        run: |
+          mkdir -p artifacts
+          echo "Operator: export public key from OCI KMS and place into pub-oci.pem" > artifacts/pub-oci.pem
+        uses: actions/upload-artifact@v4
+        with:
+          name: oci-pubkey
+          path: artifacts/
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/alibaba_cosign_sign.yml
+name: Build & Sign (Alibaba KMS)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  contents: read
+  packages: write
+  id-token: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Build image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Push image
+        run: |
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+
+      - name: Cosign sign with Alibaba KMS (placeholder)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          ALICLOUD_KEY_URI="${{ secrets.ALICLOUD_KEY_URI }}"
+          if [ -z "$ALICLOUD_KEY_URI" ]; then
+            echo "ALICLOUD_KEY_URI not set; aborting signing step"
+            exit 1
+          fi
+          cosign sign --key "$ALICLOUD_KEY_URI" $IMAGE
+
+      - name: Create artifact placeholder and upload
+        run: |
+          mkdir -p artifacts
+          echo "Operator: export public key from Alibaba KMS and place into pub-alibaba.pem" > artifacts/pub-alibaba.pem
+        uses: actions/upload-artifact@v4
+        with:
+          name: alibaba-pubkey
+          path: artifacts/
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/README.md
+# Image Verifier Admission Webhook
+
+This component is a simple validating admission webhook that verifies container images are signed with cosign using a public key mounted from a Kubernetes Secret. It is intentionally minimal and intended for operator review and hardening before production use.
+
+Flow
+- CI signs images using provider KMS (cosign sign --key <provider-key-uri>).
+- CI uploads exported public key (if allowed) as artifact; operator downloads and stores it into Kubernetes as Secret `ops/aegis-cosign-pub` (key: pub.pem).
+- The image-verifier webhook reads the public key from the Secret and verifies signatures for container images at admission time using `cosign verify-blob --key` for the image's digest (the wrapper performs cosign verify for the image reference).
+
+Security notes
+- The webhook must be secured with TLS and restricted to cluster internal traffic.
+- If your provider KMS disallows public key export, use Rekor or Vault-based verification paths instead (advanced).
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/server.py
+#!/usr/bin/env python3
+"""
+Simple validating admission webhook that checks cosign signatures for container images.
+Mounts a public key at /keys/pub.pem (from a Kubernetes Secret).
+"""
+import json, os, subprocess
+from http import HTTPStatus
+from fastapi import FastAPI, Request
+from pydantic import BaseModel
+
+PUB_KEY_PATH = os.environ.get("PUB_KEY_PATH", "/keys/pub.pem")
+COSIGN_PATH = os.environ.get("COSIGN_PATH", "cosign")
+
+app = FastAPI()
+
+class AdmissionReview(BaseModel):
+    request: dict
+
+def verify_image_with_cosign(image_ref: str) -> (bool, str):
+    # Use cosign to verify image using public key file
+    if not os.path.exists(PUB_KEY_PATH):
+        return False, f"Public key not found at {PUB_KEY_PATH}"
+    try:
+        # cosign verify <image> --key /keys/pub.pem
+        proc = subprocess.run([COSIGN_PATH, "verify", "--key", PUB_KEY_PATH, image_ref], capture_output=True, text=True, timeout=60)
+        if proc.returncode == 0:
+            return True, proc.stdout
+        else:
+            return False, proc.stderr + proc.stdout
+    except Exception as e:
+        return False, str(e)
+
+@app.post("/validate")
+async def validate(ar: Request):
+    body = await ar.json()
+    # AdmissionReview v1: .request.object.spec.containers[*].image
+    try:
+        req = body.get("request", {})
+        pod = req.get("object", {})
+        containers = pod.get("spec", {}).get("containers", [])
+        for c in containers:
+            image = c.get("image")
+            ok, out = verify_image_with_cosign(image)
+            if not ok:
+                # Deny with message
+                resp = {
+                    "apiVersion": "admission.k8s.io/v1",
+                    "kind": "AdmissionReview",
+                    "response": {
+                        "uid": req.get("uid"),
+                        "allowed": False,
+                        "status": {
+                            "message": f"Image {image} failed cosign verification: {out}"
+                        }
+                    }
+                }
+                return resp
+        # All containers verified
+        resp = {
+            "apiVersion": "admission.k8s.io/v1",
+            "kind": "AdmissionReview",
+            "response": {
+                "uid": req.get("uid"),
+                "allowed": True
+            }
+        }
+        return resp
+    except Exception as e:
+        resp = {
+            "apiVersion": "admission.k8s.io/v1",
+            "kind": "AdmissionReview",
+            "response": {
+                "uid": body.get("request",{}).get("uid"),
+                "allowed": False,
+                "status": {"message": f"Error in admission webhook: {e}"}
+            }
+        }
+        return resp
+
+if __name__ == "__main__":
+    import uvicorn
+    uvicorn.run(app, host="0.0.0.0", port=8443)
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-image-verifier
+  namespace: ops
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: aegis-image-verifier
+  template:
+    metadata:
+      labels:
+        app: aegis-image-verifier
+    spec:
+      containers:
+      - name: image-verifier
+        image: ghcr.io/your-org/aegis-image-verifier:latest  # operator: build & push this image
+        args: ["uvicorn","server:app","--host","0.0.0.0","--port","8443"]
+        ports:
+        - containerPort: 8443
+        volumeMounts:
+        - name: pubkey
+          mountPath: /keys
+          readOnly: true
+      volumes:
+      - name: pubkey
+        secret:
+          secretName: aegis-cosign-pub
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/service.yaml
+apiVersion: v1
+kind: Service
+metadata:
+  name: aegis-image-verifier
+  namespace: ops
+spec:
+  selector:
+    app: aegis-image-verifier
+  ports:
+  - port: 8443
+    targetPort: 8443
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/webhook-configuration.yaml
+# WARNING: Replace caBundle with the base64 CA that signed the TLS cert for the webhook server.
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-image-verifier-webhook
+webhooks:
+  - name: imageverifier.aegis.example
+    clientConfig:
+      service:
+        name: aegis-image-verifier
+        namespace: ops
+        path: /validate
+      # caBundle: <base64-CA-HERE>
+    rules:
+      - apiGroups: [""]
+        apiVersions: ["v1"]
+        operations: ["CREATE","UPDATE"]
+        resources: ["pods","deployments","daemonsets","statefulsets"]
+    admissionReviewVersions: ["v1"]
+    sideEffects: None
+    timeoutSeconds: 10
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/finalize_provider_signing_and_webhook.md
+# Finalize provider KMS signing & admission webhook (operator runbook)
+
+Overview
+- This runbook finalizes end-to-end signing for Azure/OCI/Alibaba and enables image admission verification in the cluster using the image-verifier webhook.
+
+Steps
+1) Terraform apply for your provider modules (Azure/OCI/Alibaba)
+   - Fill example.tfvars in terraform/<provider>/ and run the provider validate scripts:
+     - Azure: scripts/azure/terraform_validate_and_apply.sh
+     - OCI: scripts/oci/terraform_validate_and_apply.sh
+     - Alibaba: scripts/alibaba/terraform_validate_and_apply.sh
+
+2) Configure CI signing workflows
+   - Add provider KMS key URIs as GitHub repository secrets:
+     - AZURE_KEY_URI
+     - OCI_KEY_URI
+     - ALICLOUD_KEY_URI
+   - Ensure the runner has permission to use the KMS via OIDC or provider-specific credential mechanism.
+
+3) Run the relevant workflow (Actions > selected workflow) to build, push, and sign an image.
+   - After the run, download the artifact named `*-pubkey` (if the workflow created a pubkey file).
+   - If the workflow produced a placeholder file, export the provider public key using provider console or provider CLI (example: az keyvault key download/export) and store as pub.pem.
+
+4) Create Kubernetes Secret with public key
+   - Create secret in `ops` namespace:
+     kubectl create secret generic aegis-cosign-pub --from-file=pub.pem -n ops
+
+5) Deploy image-verifier
+   - Build and push the image-verifier container (security/image-verifier).
+   - Update security/image-verifier/deployment.yaml to point to your image and apply:
+     kubectl apply -f security/image-verifier/deployment.yaml
+     kubectl apply -f security/image-verifier/service.yaml
+
+6) Create TLS certificate for webhook and set webhook CA bundle
+   - Create TLS cert for service aegis-image-verifier.ops.svc (e.g., with cert-manager).
+   - Place CA bundle base64 into security/image-verifier/webhook-configuration.yaml `caBundle` field and apply webhook config:
+     kubectl apply -f security/image-verifier/webhook-configuration.yaml
+
+7) Test admission webhook
+   - Try to apply a manifest referencing an unsigned image (should be denied).
+   - Apply a manifest referencing the signed image you built in CI (should be allowed).
+
+Notes & hardening
+- Consider using Rekor or Vault-based verification instead of public-key export if your provider KMS disallows key export.
+- Lock down the webhook service with NetworkPolicy to only accept cluster internal traffic.
+- Rotate the public key/secret when keys are rotated. Automate secret refresh as part of CI if you can export updated public keys securely.
+
*** End Patch
*** End Patch
