*** Begin Patch
*** Add File:docs/operator_runbook_final_populated.md.template
+# Operator Runbook — Aegis Finalized Runbook (Placeholders)
+
+This runbook is a populated template containing cut-and-paste commands and operator steps to finalize Aegis. It intentionally contains REPLACE_* placeholders; operators must replace them locally with secrets/values before running any commands that create cloud resources.
+
+Important security note:
+- Do NOT commit secrets or the final tfvars file to git.
+- Use github secrets, ExternalSecrets or a secrets manager (Vault/SecretsManager) to inject sensitive values at runtime.
+
+ENVIRONMENT VALUES (replace the REPLACE_* tokens locally)
+- GITHUB_REPOSITORY: REPLACE_GITHUB_REPOSITORY
+- TARGET_BRANCH: REPLACE_TARGET_BRANCH
+- PR_BRANCH_NAME: REPLACE_PR_BRANCH_NAME
+- AWS_ACCOUNT_ID: REPLACE_AWS_ACCOUNT_ID
+- CLUSTER_NAME: REPLACE_CLUSTER_NAME
+- AWS_REGION: REPLACE_AWS_REGION
+- OIDC_PROVIDER_ARN: REPLACE_OIDC_PROVIDER_ARN
+- POLICY_ARN_BRAKET: REPLACE_POLICY_ARN_BRAKET
+- POLICY_ARN_IBM: REPLACE_POLICY_ARN_IBM
+- POLICY_ARN_AZURE: REPLACE_POLICY_ARN_AZURE
+- POLICY_ARN_RIGETTI: REPLACE_POLICY_ARN_RIGETTI
+- EVIDENCE_BUCKET: REPLACE_EVIDENCE_BUCKET
+- SANDBOX_QPU_BUDGET_USD: REPLACE_SANDBOX_QPU_BUDGET_USD
+- GHCR_ORG: REPLACE_GHCR_ORG
+- IMAGE_TAG: REPLACE_IMAGE_TAG
+- MLFLOW_TRACKING_URI: REPLACE_MLFLOW_TRACKING_URI
+- REKOR_URL: REPLACE_REKOR_URL
+- TLS_CHOICE: REPLACE_TLS_CHOICE
+- ENABLE_MTLS: REPLACE_ENABLE_MTLS
+- LOGGING_SINK: REPLACE_LOGGING_SINK
+- CLOUDWATCH_LOG_GROUP: REPLACE_CLOUDWATCH_LOG_GROUP
+- OPERATOR_NAMESPACE: REPLACE_OPERATOR_NAMESPACE
+- SUBMITTER_SA: REPLACE_SUBMITTER_SA
+
+Overview
+- This runbook covers:
+  1) Creating a local terraform/irsa/my.tfvars (never commit)
+  2) Running terraform to create IRSA roles
+  3) Creating required GitHub secrets via gh CLI (examples)
+  4) Building, pushing and cosign-signing images
+  5) Deploying Gatekeeper, cert-manager and the hardened submitter
+  6) Post-deploy verification & acceptance checks
+  7) How to open the prepared PR (if you choose to)
+
+Step 0 — Preparation (operator workstation)
+1. Clone the repository and work on a feature branch:
+   git checkout -b REPLACE_PR_BRANCH_NAME
+2. Ensure these CLIs are installed:
+   - git, gh (GitHub CLI), aws, kubectl, eksctl, terraform, docker, cosign, argo (optional)
+
+Step 1 — Create local tfvars (never commit)
+1. Copy the example and replace placeholders locally:
+   cp terraform/irsa/placeholder.tfvars.example terraform/irsa/my.tfvars
+   # Edit terraform/irsa/my.tfvars and replace REPLACE_* tokens with local values
+2. Verify my.tfvars is not staged:
+   git status -- terraform/irsa/my.tfvars
+
+Step 2 — Apply Terraform IRSA (operator)
+1. Initialize & plan:
+   cd terraform/irsa
+   terraform init
+   terraform plan -var-file=my.tfvars
+2. Apply (confirm):
+   terraform apply -var-file=my.tfvars
+3. Capture outputs:
+   terraform output -json > /tmp/irsa_outputs.json
+   # Use these ARNs to annotate ServiceAccounts or populate k8s manifests if needed
+
+Step 3 — Create GitHub repo secrets (example using gh)
+1. Required secrets (set via gh or GitHub UI):
+   - COSIGN_KMS_ARN
+   - REKOR_URL
+   - EVIDENCE_BUCKET
+   - MLFLOW_TRACKING_URI
+   - SANDBOX_QPU_BUDGET_USD
+2. Example (interactive; do NOT paste secrets into git):
+   export REPO="REPLACE_GITHUB_REPOSITORY"
+   gh secret set COSIGN_KMS_ARN --repo "$REPO" --body "REPLACE_COSIGN_KMS_ARN"
+   gh secret set REKOR_URL --repo "$REPO" --body "REPLACE_REKOR_URL"
+   gh secret set EVIDENCE_BUCKET --repo "$REPO" --body "REPLACE_EVIDENCE_BUCKET"
+   gh secret set MLFLOW_TRACKING_URI --repo "$REPO" --body "REPLACE_MLFLOW_TRACKING_URI"
+   gh secret set SANDBOX_QPU_BUDGET_USD --repo "$REPO" --body "REPLACE_SANDBOX_QPU_BUDGET_USD"
+
+Step 4 — Build, push and cosign images
+1. Build and push (example):
+   ./ops/build_and_cosign.sh REPLACE_GHCR_ORG/aegis-quantum REPLACE_IMAGE_TAG
+2. Verify:
+   cosign verify --rekor-server REPLACE_REKOR_URL REPLACE_GHCR_ORG/aegis-quantum:REPLACE_IMAGE_TAG
+
+Step 5 — Deploy Gatekeeper, cert-manager and RBAC
+1. Install cert-manager (if using cert-manager):
+   kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml
+2. Install Gatekeeper:
+   kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+3. Apply Gatekeeper templates & constraints:
+   kubectl apply -f k8s/gatekeeper/constraint_template_qpuapproved.yaml
+   kubectl apply -f k8s/gatekeeper/constraint_qpu_approved.yaml
+4. Apply RBAC for submitter:
+   kubectl apply -f k8s/rbac/argo_quantum_submitter_role.yaml
+
+Step 6 — Deploy hardened submitter
+1. Create operator namespace and secrets:
+   kubectl create ns REPLACE_OPERATOR_NAMESPACE || true
+   # Create secret containing GitHub token for the submitter (or mount via ExternalSecrets)
+   kubectl -n REPLACE_OPERATOR_NAMESPACE create secret generic qpu-github-token --from-literal=token="REPLACE_GITHUB_TOKEN"
+2. Deploy submitter (manifest path):
+   kubectl apply -f k8s/argo/submitter_deployment.yaml
+
+Step 7 — Post-deploy verification & acceptance tests
+1. IRSA verification:
+   kubectl -n aegis run --rm -it irsa-test --restart=Never --serviceaccount=braket-sa --image=amazon/aws-cli -- bash -c "aws braket list-devices || true"
+2. Image verification:
+   cosign verify --rekor-server REPLACE_REKOR_URL REPLACE_GHCR_ORG/aegis-quantum:REPLACE_IMAGE_TAG
+3. Argo simulate run:
+   argo submit -n aegis argo/quantum_braket_workflow.yaml -p run-type=simulate -p image=REPLACE_GHCR_ORG/aegis-quantum:REPLACE_IMAGE_TAG -p circuit-file-s3=s3://REPLACE_EVIDENCE_BUCKET/quantum/circuits/example.py
+4. MLflow validation:
+   python3 mlflow/validate_quantum_mlflow.py --run-id <RUN_ID> --tracking-uri REPLACE_MLFLOW_TRACKING_URI
+5. Audit & Rekor:
+   aws s3 ls s3://REPLACE_EVIDENCE_BUCKET/quantum_results/
+   # Verify .sig and rekor if configured
+
+Operator checklist (pre-merge)
+- terraform/irsa/my.tfvars created locally & not committed
+- GitHub secrets set (see list above)
+- Images built & cosign-signed
+- Gatekeeper + cert-manager applied
+- Submitter deployed and audit S3 accessible
+- Legal signoff file uploaded to s3://REPLACE_EVIDENCE_BUCKET/legal_signoff/
+- Runbook / run acceptance tests and record results in evidence bucket
+
+Appendix: How to rollback
+- To undo the submitter:
+  kubectl -n REPLACE_OPERATOR_NAMESPACE delete deployment <submitter-deployment-name>
+- To remove IRSA roles created by Terraform:
+  cd terraform/irsa
+  terraform destroy -var-file=my.tfvars
+
*** End Patch
*** Begin Patch
*** Add File:ops/create_feature_branch_and_commit.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Create a feature branch, add non-secret files, and push branch.
+# Usage:
+#   ./ops/create_feature_branch_and_commit.sh <branch-name> "<commit-message>"
+#
+BRANCH=${1:-"ops/quantum-finalize"}
+COMMIT_MSG=${2:-"chore: add final operator runbook and PR helpers"}
+
+echo "Creating branch ${BRANCH}"
+git fetch origin
+git checkout -b "${BRANCH}"
+
+echo "Staging non-secret artifacts to commit..."
+# List files that are safe to commit (adjust as needed)
+safe_files=(
+  "docs/operator_runbook_final_populated.md.template"
+  "ops/generate_runbook_populated.sh"
+  "ops/generate_pr_description.sh"
+  "ops/open_pr.sh"
+  "ops/create_feature_branch_and_commit.sh"
+  "ops/pr_checklist.md"
+)
+
+for f in "${safe_files[@]}"; do
+  if [ -f "$f" ]; then
+    git add "$f"
+  else
+    echo "Warning: $f not found; skipping"
+  fi
+done
+
+echo "Commit staged files"
+git commit -m "${COMMIT_MSG}" || { echo "Nothing to commit"; }
+
+echo "Pushing branch to origin"
+git push -u origin "${BRANCH}"
+
+echo "Branch ${BRANCH} pushed. You can now open a PR using ops/open_pr.sh"
+
*** End Patch
*** Begin Patch
*** Add File:ops/generate_runbook_populated.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Generate the populated operator runbook from the template, replacing placeholders
+# Usage:
+#   ./ops/generate_runbook_populated.sh output-file.env
+#
+OUT_FILE=${1:-"docs/operator_runbook_final_populated.md"}
+
+echo "Generating runbook at ${OUT_FILE} from template docs/operator_runbook_final_populated.md.template"
+
+# Replace tokens using environment variables when present, otherwise leave placeholders
+sed_expr=""
+for var in GITHUB_REPOSITORY TARGET_BRANCH PR_BRANCH_NAME AWS_ACCOUNT_ID CLUSTER_NAME AWS_REGION OIDC_PROVIDER_ARN POLICY_ARN_BRAKET POLICY_ARN_IBM POLICY_ARN_AZURE POLICY_ARN_RIGETTI EVIDENCE_BUCKET SANDBOX_QPU_BUDGET_USD GHCR_ORG IMAGE_TAG MLFLOW_TRACKING_URI REKOR_URL TLS_CHOICE ENABLE_MTLS LOGGING_SINK CLOUDWATCH_LOG_GROUP OPERATOR_NAMESPACE SUBMITTER_SA; do
+  val="${!var:-REPLACE_${var}}"
+  # escape slashes
+  esc=$(printf "%s" "$val" | sed -e 's/[\/&]/\\&/g')
+  sed_expr+=" -e s/REPLACE_${var}/${esc}/g"
+done
+
+eval "sed ${sed_expr} docs/operator_runbook_final_populated.md.template > ${OUT_FILE}"
+
+echo "Runbook generated: ${OUT_FILE}"
+
*** End Patch
*** Begin Patch
*** Add File:ops/generate_pr_description.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Generate a PR description markdown file that lists required secrets and operator checklist.
+# Usage:
+#   ./ops/generate_pr_description.sh output.md
+OUT=${1:-pr_description.md}
+
+cat > "${OUT}" <<'PR'
+# Operator PR: Finalize Aegis operator runbook and PR helpers
+
+This PR contains non-secret artifacts to help operators finalize Aegis:
+- Operator runbook template (docs/operator_runbook_final_populated.md.template)
+- Scripts to generate populated runbook, create branch & commit, and open PRs (ops/)
+
+Required secrets (must be set in GitHub repo or ExternalSecrets before merge/deploy):
+- COSIGN_KMS_ARN — KMS key used by cosign to sign images and artifacts
+- REKOR_URL — Rekor server URL (if using Rekor transparency log)
+- EVIDENCE_BUCKET — S3 bucket for signed artifacts & audit logs
+- MLFLOW_TRACKING_URI — MLflow tracking server URI
+- SANDBOX_QPU_BUDGET_USD — budget for nightly sandbox tests
+- GITHUB_TOKEN — GitHub token for automation (only if you wish CI to create PRs to GitOps repo)
+- Provider billing API keys (if using: IBM/AZURE/RIGETTI credentials) — provide via ExternalSecrets
+
+Operator checklist (pre-merge / pre-deploy)
+1. Create terraform/irsa/my.tfvars locally (do NOT commit).
+2. Set GitHub secrets listed above.
+3. Build and cosign images: ./ops/build_and_cosign.sh REPLACE_GHCR_ORG/aegis-quantum REPLACE_IMAGE_TAG
+4. Apply Gatekeeper, cert-manager, and RBAC manifests.
+5. Deploy the hardened submitter (k8s/argo/submitter_deployment.yaml).
+6. Run acceptance tests (Argo simulate, MLflow validation, cosign verification).
+7. Upload legal signoff to s3://REPLACE_EVIDENCE_BUCKET/legal_signoff/
+
+Merge & deploy notes:
+- This PR intentionally does NOT contain terraform/irsa/my.tfvars or any secrets.
+- After merging, operators should follow docs/operator_runbook_final_populated.md.template to perform the operator steps.
+
+PR
+
+echo "PR description written to ${OUT}"
+
*** End Patch
*** Begin Patch
*** Add File:ops/open_pr.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Open a PR using gh CLI
+# Usage:
+#   ./ops/open_pr.sh <repo> <branch> <base> "<title>" pr_description.md
+REPO=${1:-"REPLACE_GITHUB_REPOSITORY"}
+BRANCH=${2:-"ops/quantum-finalize"}
+BASE=${3:-"main"}
+TITLE=${4:-"chore: add operator runbook and PR helpers"}
+BODY_FILE=${5:-"pr_description.md"}
+
+if [ ! -f "${BODY_FILE}" ]; then
+  echo "Body file ${BODY_FILE} not found"
+  exit 2
+fi
+
+echo "Opening PR on ${REPO}: ${BRANCH} -> ${BASE}"
+gh pr create --repo "${REPO}" --base "${BASE}" --head "${BRANCH}" --title "${TITLE}" --body-file "${BODY_FILE}"
+
*** End Patch
*** Begin Patch
*** Add File:ops/pr_checklist.md
+Operator PR checklist (for reviewers)
+
+- Confirm terraform/irsa/my.tfvars is not committed
+- Confirm secrets are not present in any committed files (run ./ops/validate_no_placeholders.sh)
+- Confirm the PR description lists all required secrets and operator actions
+- Verify runbook template docs/operator_runbook_final_populated.md.template contains REPLACE_* placeholders and is not accidentally filled with secrets
+- After merge, an operator must:
+  - create my.tfvars locally and run terraform apply
+  - create GitHub secrets
+  - build & cosign images
+  - deploy Gatekeeper/cert-manager/submitter
+
*** End Patch
*** End Patch
