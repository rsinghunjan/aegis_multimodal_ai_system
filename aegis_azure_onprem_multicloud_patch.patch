*** Begin Patch
*** Add File: terraform/azure/azure_kv_blob_sql.tf
+/*
+Terraform: Azure resources for Aegis signing & storage
+ - Resource Group
+ - Key Vault (with key for cosign)
+ - Storage Account (Blob) for compliance artifacts
+ - Azure Database for PostgreSQL (Flexible Server) example (recommended Private Access)
+ - Output key identifier and storage details for CI
+
+Usage:
+ - populate terraform.tfvars with: azure_subscription_id, azure_location, rg_name, project_prefix, db_admin_password
+ - run: terraform init && terraform apply -auto-approve
+*/
+provider "azurerm" {
+  features = {}
+}
+
+variable "azure_subscription_id" { type = string }
+variable "azure_location" { type = string }
+variable "rg_name" { type = string }
+variable "project_prefix" { type = string }
+variable "db_admin_password" { type = string }
+
+resource "azurerm_resource_group" "aegis" {
+  name     = var.rg_name
+  location = var.azure_location
+}
+
+resource "azurerm_key_vault" "aegis_kv" {
+  name                        = "${var.project_prefix}-kv"
+  location                    = azurerm_resource_group.aegis.location
+  resource_group_name         = azurerm_resource_group.aegis.name
+  enabled_for_disk_encryption = true
+  sku_name                    = "standard"
+  tenant_id                   = data.azurerm_client_config.current.tenant_id
+  soft_delete_retention_days  = 7
+}
+
+data "azurerm_client_config" "current" {}
+
+resource "azurerm_key_vault_key" "cosign_key" {
+  name         = "aegis-cosign-key"
+  key_vault_id = azurerm_key_vault.aegis_kv.id
+  key_type     = "RSA"
+  key_size     = 3072
+  key_opts     = ["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"]
+}
+
+# Storage Account for compliance artifacts (Blob)
+resource "azurerm_storage_account" "compliance" {
+  name                     = lower("${var.project_prefix}compliance")
+  resource_group_name      = azurerm_resource_group.aegis.name
+  location                 = azurerm_resource_group.aegis.location
+  account_tier             = "Standard"
+  account_replication_type = "GRS"
+  enable_https_traffic_only = true
+  blob_properties {
+    delete_retention_policy {
+      days = 3650
+    }
+  }
+}
+
+resource "azurerm_postgresql_flexible_server" "aegis_pg" {
+  name                = "${var.project_prefix}-postgres"
+  resource_group_name = azurerm_resource_group.aegis.name
+  location            = azurerm_resource_group.aegis.location
+  administrator_login = "aegis"
+  administrator_password = var.db_admin_password
+  sku_name            = "Standard_B2ms"
+  storage_mb          = 51200
+  version             = "15"
+  high_availability {
+    mode = "ZoneRedundant"
+  }
+  network {
+    # For production: enable private access via delegated subnet (not shown here)
+  }
+}
+
+output "azure_key_vault_key_id" {
+  value = azurerm_key_vault_key.cosign_key.id
+}
+
+output "azure_storage_account_name" {
+  value = azurerm_storage_account.compliance.name
+}
+
+output "azure_postgres_host" {
+  value = azurerm_postgresql_flexible_server.aegis_pg.fqdn
+}
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_sign_azure_kv.yml
+name: CI: Build & Sign with Azure Key Vault (cosign + Rekor)
+on:
+  push:
+    branches: [ main ]
+
+permissions:
+  contents: read
+  id-token: write
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    env:
+      IMAGE: ${{ secrets.REGISTRY_HOST }}/aegis:${{ github.sha }}
+      REKOR_URL: ${{ secrets.REKOR_URL }}
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Set up Azure login via OIDC (requires federated credentials in Azure AD)
+        uses: azure/login@v1
+        with:
+          client-id: ${{ secrets.AZURE_CLIENT_ID }}
+          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
+          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
+
+      - name: Build image
+        run: |
+          docker build -t "$IMAGE" -f services/serving/Dockerfile .
+          docker push "$IMAGE"
+
+      - name: Get image digest
+        id: image
+        run: |
+          DIG=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" | awk -F@ '{print $2}')
+          echo "digest=$DIG" >> $GITHUB_OUTPUT
+
+      - name: Sign using Azure Key Vault-backed cosign
+        env:
+          AZURE_KEY_VAULT_NAME: ${{ secrets.AZURE_KEY_VAULT_NAME }}
+          AZURE_KEY_NAME: ${{ secrets.AZURE_KEY_NAME }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          # cosign supports azurekms://<vault-name>/<key-name>
+          cosign sign --key "azurekms://${AZURE_KEY_VAULT_NAME}/${AZURE_KEY_NAME}" "${IMAGE}@${{ steps.image.outputs.digest }}"
+
+      - name: Verify cosign + Rekor
+        run: |
+          cosign verify --rekor-url "${REKOR_URL}" "${IMAGE}@${{ steps.image.outputs.digest }}"
+
+      - name: Upload SBOM & Trivy (optional)
+        if: ${{ secrets.COMPLIANCE_BUCKET != '' }}
+        run: |
+          syft "$IMAGE" -o json > sbom.json || true
+          trivy image --format json -o trivy.json "$IMAGE" || true
+          az storage blob upload --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} --container-name compliance --file sbom.json --name "ci/${GITHUB_RUN_ID}/sbom.json" || true
+
*** End Patch
*** Begin Patch
*** Add File: docs/cloud_abstraction.md
+# Cloud Abstraction for Aegis (AWS / GCP / Azure)
+
+Purpose
+- Provide a small abstraction so CI and Terraform can be run against AWS, GCP or Azure with minimal changes.
+
+Key ideas
+- Single variable CLOUD_PROVIDER (aws|gcp|azure) switches behaviors.
+- Terraform: keep provider-specific directories (terraform/aws, terraform/gcp, terraform/azure). Have a thin wrapper script that invokes the chosen provider's terraform.
+- CI: single GitHub Actions workflow (ci_sign_multicloud.yml) inspects secrets.CLOUD_PROVIDER and uses the corresponding signing method:
+  - aws -> awskms://...
+  - gcp -> gcpkms://...
+  - azure -> azurekms://...
+
+Files provided
+- .github/workflows/ci_sign_multicloud.yml  — workflow that selects signing backend
+- scripts/select_kms_env.sh                 — helper to export env variables for local testing
+- terraform/<cloud>/*                      — provider-specific TF modules (already provided)
+
+How to use
+- Set GitHub secret CLOUD_PROVIDER to one of aws|gcp|azure and set provider-specific secrets as documented in provider TF outputs.
+- Run the CI workflow; it will choose the appropriate cosign key reference automatically.
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_sign_multicloud.yml
+name: CI: Multi-cloud sign + Rekor verification
+on:
+  push:
+    branches: [ main ]
+
+permissions:
+  contents: read
+  id-token: write
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    env:
+      IMAGE: ${{ secrets.REGISTRY_HOST }}/aegis:${{ github.sha }}
+      REKOR_URL: ${{ secrets.REKOR_URL }}
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Determine provider
+        run: echo "CLOUD_PROVIDER=${{ secrets.CLOUD_PROVIDER }}" >> $GITHUB_ENV
+
+      - name: Build image
+        run: |
+          docker build -t "$IMAGE" -f services/serving/Dockerfile .
+          docker push "$IMAGE"
+
+      - name: Get image digest
+        id: digest
+        run: |
+          DIG=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" | awk -F@ '{print $2}')
+          echo "digest=$DIG" >> $GITHUB_OUTPUT
+
+      - name: Sign image based on cloud provider
+        env:
+          CLOUD_PROVIDER: ${{ secrets.CLOUD_PROVIDER }}
+          REKOR_URL: ${{ secrets.REKOR_URL }}
+        run: |
+          case "$CLOUD_PROVIDER" in
+            aws)
+              cosign sign --key "awskms://${{ secrets.AWS_KMS_KEY_ARN }}" "${IMAGE}@${{ steps.digest.outputs.digest }}"
+              ;;
+            gcp)
+              cosign sign --key "gcpkms://${{ secrets.GCP_KMS_KEY_REF }}" "${IMAGE}@${{ steps.digest.outputs.digest }}"
+              ;;
+            azure)
+              cosign sign --key "azurekms://${{ secrets.AZURE_KEY_VAULT_NAME }}/${{ secrets.AZURE_KEY_NAME }}" "${IMAGE}@${{ steps.digest.outputs.digest }}"
+              ;;
+            *)
+              echo "Unsupported CLOUD_PROVIDER: $CLOUD_PROVIDER"; exit 1
+              ;;
+          esac
+
+      - name: Verify cosign + Rekor
+        run: |
+          cosign verify --rekor-url "${REKOR_URL}" "${IMAGE}@${{ steps.digest.outputs.digest }}"
+
*** End Patch
*** Begin Patch
*** Add File: scripts/select_kms_env.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Helper to export KMS-related env vars locally for testing CI flows.
+# Usage:
+#   ./scripts/select_kms_env.sh aws|gcp|azure
+CLOUD=${1:-}
+if [ -z "$CLOUD" ]; then
+  echo "Usage: $0 aws|gcp|azure"
+  exit 2
+fi
+if [ "$CLOUD" = "aws" ]; then
+  export CLOUD_PROVIDER=aws
+  export AWS_KMS_KEY_ARN="<paste-kms-arn>"
+  echo "Exported AWS variables. Fill AWS_KMS_KEY_ARN."
+elif [ "$CLOUD" = "gcp" ]; then
+  export CLOUD_PROVIDER=gcp
+  export GCP_KMS_KEY_REF="<paste-gcp-kms-ref>"
+  echo "Exported GCP variables. Fill GCP_KMS_KEY_REF."
+elif [ "$CLOUD" = "azure" ]; then
+  export CLOUD_PROVIDER=azure
+  export AZURE_KEY_VAULT_NAME="<vault-name>"
+  export AZURE_KEY_NAME="<key-name>"
+  echo "Exported AZURE variables. Fill AZURE_KEY_VAULT_NAME and AZURE_KEY_NAME."
+else
+  echo "Unsupported cloud: $CLOUD"
+  exit 2
+fi
+
*** End Patch
*** Begin Patch
*** Add File: docs/azure_cosign_notes.md
+# Notes: Using Azure Key Vault for cosign signing
+
+- cosign supports azurekms://<vault-name>/<key-name> to sign images with Azure Key Vault keys.
+- For GitHub Actions, configure a federated credential in Azure AD to allow GitHub OIDC to assume a workload identity and use the Key Vault.
+- Alternatively, create a service principal and store its JSON as a GitHub secret (less recommended).
+- The CI example .github/workflows/ci_sign_azure_kv.yml demonstrates OIDC signin via azure/login and cosign usage.
+
*** End Patch
*** Begin Patch
*** Add File: scripts/ci_sign_with_pkcs11.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Sign an image using cosign with a PKCS#11 HSM provider (on-prem HSM).
+# Prereqs:
+#  - PKCS#11 library path
+#  - HSM token label & pin
+#  - cosign with PKCS11 provider support
+#
+LIB_PATH=${PKCS11_LIB:-/usr/local/lib/your-pkcs11.so}
+SLOT=${PKCS11_SLOT:-0}
+TOKEN_LABEL=${PKCS11_TOKEN_LABEL:-aegis}
+PIN=${PKCS11_PIN:-}
+KEY_LABEL=${PKCS11_KEY_LABEL:-cosignkey}
+IMAGE=${1:-}
+
+if [ -z "$IMAGE" ]; then
+  echo "Usage: $0 <image:tag-or-digest>"
+  exit 2
+fi
+if [ -z "$PIN" ]; then
+  echo "Please set PKCS11_PIN environment variable"
+  exit 2
+fi
+
+echo "Signing $IMAGE using PKCS#11 HSM provider"
+export COSIGN_PASSWORD="" # ensure cosign uses PKCS11
+cosign sign --key "pkcs11:token=${TOKEN_LABEL};object=${KEY_LABEL};slot-id=${SLOT}?module-path=${LIB_PATH}" "$IMAGE"
+echo "Signed $IMAGE"
+
*** End Patch
*** Begin Patch
*** Add File: helm/vault/values-hsm.yaml
+# Vault Helm values for HSM auto-unseal (PKCS#11 example)
+server:
+  ha:
+    enabled: true
+  extraEnvironmentVars:
+    VAULT_LOCAL_CONFIG: |
+      ui = true
+      listener "tcp" {
+        address = "0.0.0.0:8200"
+        tls_disable = 1
+      }
+      storage "raft" {
+        path = "/vault/data"
+      }
+      seal "pkcs11" {
+        lib = "/usr/local/lib/your-pkcs11.so"
+        slot = "0"
+        key_label = "vaultUnsealKey"
+        pin = "REPLACE_WITH_PIN"
+      }
+  service:
+    type: ClusterIP
+injector:
+  enabled: true
+
*** End Patch
*** Begin Patch
*** Add File: docs/onprem_hsm_readme.md
+# On-Prem HSM & PKCS#11 Signing for Aegis
+
+Contents
+- scripts/ci_sign_with_pkcs11.sh : example to sign images via HSM/PKCS#11
+- helm/vault/values-hsm.yaml : example Vault Helm values to auto-unseal using PKCS#11
+
+Notes
+- Ensure the PKCS#11 library is available to any hosts that run cosign for signing (CI runner or build host).
+- Configure cosign with the correct PKCS#11 URI (token and object labels) and that the HSM allows signing operations.
+- For CI, ensure the runner has access to HSM (e.g., hosted on-prem runner with HSM connectivity) and secrets (PIN) are injected via a secure mechanism (Vault or runner secrets).
+
*** End Patch
*** Begin Patch
*** Add File: terraform/cloud/provider_wrapper.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Thin wrapper to run provider-specific terraform in terraform/<provider>
+# Usage: terraform/cloud/provider_wrapper.sh <aws|gcp|azure> plan|apply
+PROV=${1:-}
+CMD=${2:-plan}
+if [[ -z "$PROV" || -z "$CMD" ]]; then
+  echo "Usage: $0 <aws|gcp|azure> <plan|apply|destroy>"
+  exit 2
+fi
+cd "$(dirname "$0")/.."
+if [[ ! -d "terraform/$PROV" ]]; then
+  echo "Provider terraform not found: terraform/$PROV"
+  exit 2
+fi
+pushd "terraform/$PROV" >/dev/null
+terraform init
+terraform "$CMD" -auto-approve
+popd >/dev/null
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_sign_azure_and_hsm_demo.yml
+name: CI Demo: Sign with Azure KeyVault or PKCS11 (on-prem)
+on:
+  workflow_dispatch:
+    inputs:
+      image:
+        required: true
+        description: "Image to sign (e.g. ghcr.io/yourorg/aegis:sha)"
+      backend:
+        required: true
+        description: "signing backend: azure|pkcs11"
+
+jobs:
+  sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Build (skip if already pushed)
+        run: echo "Assuming image ${{ github.event.inputs.image }} exists"
+      - name: Sign (azure)
+        if: ${{ github.event.inputs.backend == 'azure' }}
+        uses: azure/login@v1
+        with:
+          client-id: ${{ secrets.AZURE_CLIENT_ID }}
+          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
+          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
+      - name: Sign via cosign (azure)
+        if: ${{ github.event.inputs.backend == 'azure' }}
+        run: |
+          cosign sign --key "azurekms://${{ secrets.AZURE_KEY_VAULT_NAME }}/${{ secrets.AZURE_KEY_NAME }}" "${{ github.event.inputs.image }}"
+      - name: Sign via cosign (pkcs11) - for demo only
+        if: ${{ github.event.inputs.backend == 'pkcs11' }}
+        run: |
+          echo "PKCS11 signing requires on-prem runner with HSM; this demo step will fail on hosted runner."
+          cosign sign --key "pkcs11:token=aegis;object=cosignkey;slot-id=0?module-path=/usr/local/lib/your-pkcs11.so" "${{ github.event.inputs.image }}"
+
*** End Patch
*** End Patch
