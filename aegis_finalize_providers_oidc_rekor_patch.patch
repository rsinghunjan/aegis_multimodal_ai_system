*** Begin Patch
*** Add File:terraform/azure/iam/README.md
+# Azure IAM & Key Vault least-privilege example
+
+This folder contains Terraform snippets showing a minimal, least-privilege setup for:
+- Creating a User Assigned Managed Identity for CI/Workload federation
+- Granting Key Vault "unwrapKey", "wrapKey", "get" permissions to that identity so it can use keys for signing/auto-unseal.
+
+Operator tasks:
+- Create an Azure AD App registration with a federated credential that trusts GitHub Actions OIDC for your repo.
+- Map the federated credential to a User Assigned Managed Identity or service principal and use the identity in CI via OIDC token exchange.
+
*** End Patch
*** Begin Patch
*** Add File:terraform/azure/iam/main.tf
+provider "azurerm" {
+  features {}
+}
+
+variable "resource_group_name" { type = string }
+variable "location" { type = string }
+variable "name_prefix" { type = string }
+
+resource "azurerm_user_assigned_identity" "ci_identity" {
+  name                = "${var.name_prefix}-ci-identity"
+  resource_group_name = var.resource_group_name
+  location            = var.location
+}
+
+resource "azurerm_key_vault" "kv" {
+  name                        = "${var.name_prefix}-kv"
+  location                    = var.location
+  resource_group_name         = var.resource_group_name
+  tenant_id                   = data.azurerm_client_config.current.tenant_id
+  sku_name                    = "standard"
+  purge_protection_enabled    = true
+  soft_delete_retention_days  = 90
+}
+
+data "azurerm_client_config" "current" {}
+
+resource "azurerm_key_vault_access_policy" "ci_kv_policy" {
+  key_vault_id = azurerm_key_vault.kv.id
+  tenant_id    = data.azurerm_client_config.current.tenant_id
+  object_id    = azurerm_user_assigned_identity.ci_identity.principal_id
+
+  key_permissions = [
+    "unwrapKey",
+    "wrapKey",
+    "get",
+  ]
+}
+
+output "ci_identity_client_id" {
+  value = azurerm_user_assigned_identity.ci_identity.client_id
+}
+
*** End Patch
*** Begin Patch
*** Add File:terraform/oci/iam/README.md
+# OCI minimal policy example (least privilege)
+
+Example policy to allow a dynamic group (GitHub federation) to use a KMS key for signing.
+Operator must create an Identity Provider + Dynamic Group in OCI and configure federation with GitHub OIDC.
+Example Policy:
+  Allow dynamic-group <your-dynamic-group> to inspect keys in compartment <compartment>
+  Allow dynamic-group <your-dynamic-group> to use keys in compartment <compartment>
+
+Adjust to the minimal set required by your use-case.
+
*** End Patch
*** Begin Patch
*** Add File:terraform/oci/iam/policy-example.tf
+# This file is descriptive only. Use OCI Console / Terraform provider for identity provider & dynamic group setup
+#
+# Example OCI policy statement (apply in tenancy via OCI Console or Terraform):
+# Allow dynamic-group aegis-github-oidc to use keys in compartment aegis-compartment
+# Allow dynamic-group aegis-github-oidc to inspect keys in compartment aegis-compartment
+
*** End Patch
*** Begin Patch
*** Add File:terraform/alibaba/iam/README.md
+# Alibaba RAM policy example (least privilege)
+
+Create a RAM role with a trust policy allowing federation from GitHub OIDC and attach a policy like:
+  "kms:DescribeKey","kms:CreateKey","kms:GetPublicKey","kms:Sign","kms:Encrypt","kms:Decrypt"
+Only grant the subset required for sign operations: GetPublicKey and Sign.
+
+Operator: configure OIDC trust in Alibaba Cloud for GitHub Actions (requires console setup).
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ci/azure_oidc_login.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Exchange GitHub Actions OIDC token for Azure AD access using federated credential
+# Requirements:
+# - You must create an Azure AD app registration and add a federated credential that trusts your GitHub repo.
+# - The app must be configured to allow client credential flow via federated credentials.
+#
+CLIENT_ID="${AZURE_CLIENT_ID:-}"
+TENANT_ID="${AZURE_TENANT_ID:-}"
+
+if [ -z "$CLIENT_ID" ] || [ -z "$TENANT_ID" ]; then
+  echo "Set AZURE_CLIENT_ID and AZURE_TENANT_ID env vars (app registration values)."
+  exit 2
+fi
+
+# GitHub provides OIDC token via environment variable in Actions: $ACTIONS_ID_TOKEN_REQUEST_TOKEN and metadata endpoint
+# On runners, you can request an OIDC token using the workflow's OIDC token exchange; in Actions set up 'id-token: write'
+echo "Fetching GitHub OIDC token..."
+GH_OIDC=$(curl -s --retry 3 --retry-delay 1 -H "Accept: application/json" "http://169.254.169.254/metadata/identity/oauth2/token" || true)
+
+# The above is a placeholder; in GitHub Actions you receive the token via the built-in OIDC integration (use actions/oidc-client or azure/login)
+echo "Operator: In GitHub Actions, use 'azure/login' action with federated credentials for zero-secret auth. This script is a placeholder for local testing."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ci/oci_oidc_login.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# OCI OIDC login placeholder.
+# Operator must configure OCI Identity Provider with GitHub OIDC and create a dynamic group for the federated principal.
+# The exchange step depends on OCI-specific tooling and federation config and is operator-specific.
+echo "OCI OIDC login: operator must configure identity provider & dynamic group, then use the oci cli to assume an STS token."
+echo "This script is a placeholder. Implement provider-specific OIDC token exchange here."
+
*** End Patch
*** Begin Patch
*** Add File:scripts/ci/alibaba_oidc_login.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Alibaba OIDC login placeholder.
+# Operator: configure Alibaba Cloud RAM and OIDC trust for GitHub Actions, then implement token exchange.
+echo "Alibaba OIDC login: operator must configure OIDC trust in Alibaba Cloud. This script is a placeholder."
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/azure_oidc_cosign_sign.yml
+name: Build & Sign (Azure Key Vault) - OIDC
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write   # allow the runner to request an OIDC token
+  contents: read
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Login to Azure using federated credentials (OIDC)
+        uses: azure/login@v1
+        with:
+          client-id: ${{ secrets.AZURE_OIDC_CLIENT_ID }}   # Azure app registration with federated credential
+          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
+          allow-no-subscriptions: true
+
+      - name: Build & push image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "Pushing $IMAGE"
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image using Azure Key Vault (cosign with provider KMS)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+          REKOR_SERVER: ${{ secrets.REKOR_SERVER }}
+        run: |
+          # Use cosign with the azurekms URI (provider must allow client-id OIDC exchange)
+          AZURE_KMS_URI="${{ secrets.AZURE_KEY_URI }}"
+          if [ -z "$AZURE_KMS_URI" ]; then
+            echo "AZURE_KEY_URI is not set. Ensure repository secret AZURE_KEY_URI contains azurekms://<vault>/keys/<key>"
+            exit 1
+          fi
+          cosign sign --key "$AZURE_KMS_URI" --rekor-server "$REKOR_SERVER" $IMAGE
+
+      - name: Upload Rekor verification artifact
+        uses: actions/upload-artifact@v4
+        with:
+          name: rekor-artifacts
+          path: |
+            artifacts || true
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/oci_oidc_cosign_sign.yml
+name: Build & Sign (OCI KMS) - OIDC (placeholder)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write
+  contents: read
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: OCI OIDC login (placeholder)
+        run: |
+          echo "Operator: configure OCI Identity Provider and dynamic group for GitHub OIDC."
+          echo "Implement OIDC token exchange for OCI or add minimal ephemeral credentials for the runner."
+          ./scripts/ci/oci_oidc_login.sh || true
+
+      - name: Build & push image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "Pushing $IMAGE"
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image using OCI KMS (cosign)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+        run: |
+          OCI_KEY_URI="${{ secrets.OCI_KEY_URI }}"
+          REKOR_SERVER="${{ secrets.REKOR_SERVER }}"
+          if [ -z "$OCI_KEY_URI" ]; then echo "OCI_KEY_URI not set"; exit 1; fi
+          cosign sign --key "$OCI_KEY_URI" --rekor-server "$REKOR_SERVER" $IMAGE
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/alibaba_oidc_cosign_sign.yml
+name: Build & Sign (Alibaba KMS) - OIDC (placeholder)
+
+on:
+  workflow_dispatch:
+  push:
+    branches:
+      - main
+
+permissions:
+  id-token: write
+  contents: read
+  packages: write
+
+jobs:
+  build-and-sign:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+
+      - name: Alibaba OIDC login (placeholder)
+        run: |
+          echo "Operator: configure Alibaba OIDC trust and implement token exchange."
+          ./scripts/ci/alibaba_oidc_login.sh || true
+
+      - name: Build & push image
+        run: |
+          IMAGE=ghcr.io/${{ github.repository_owner }}/aegis-sample:${{ github.sha }}
+          docker build -t $IMAGE ./agents/controller
+          echo "Pushing $IMAGE"
+          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
+          docker push $IMAGE
+          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
+
+      - name: Sign image using Alibaba KMS (cosign)
+        env:
+          COSIGN_EXPERIMENTAL: "1"
+          REKOR_SERVER: ${{ secrets.REKOR_SERVER }}
+        run: |
+          ALICLOUD_KEY_URI="${{ secrets.ALICLOUD_KEY_URI }}"
+          if [ -z "$ALICLOUD_KEY_URI" ]; then echo "ALICLOUD_KEY_URI not set"; exit 1; fi
+          cosign sign --key "$ALICLOUD_KEY_URI" --rekor-server "$REKOR_SERVER" $IMAGE
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/Dockerfile
+FROM python:3.10-slim
+RUN apt-get update && apt-get install -y curl git ca-certificates && rm -rf /var/lib/apt/lists/*
+RUN pip install fastapi uvicorn pydantic
+RUN curl -sSL https://github.com/sigstore/cosign/releases/download/v2.1.0/cosign-linux-amd64 -o /usr/local/bin/cosign && chmod +x /usr/local/bin/cosign
+COPY server.py /app/server.py
+WORKDIR /app
+CMD ["uvicorn", "server:app", "--host", "0.0.0.0", "--port", "8443"]
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/server.py
+#!/usr/bin/env python3
+"""
+Validating admission webhook using Rekor-based verification.
+This webhook invokes cosign verify with the configured Rekor server to verify that an image has a valid signature record.
+It avoids requiring public key export by relying on Rekor transparency log entries created by CI.
+Environment variables:
+ - REKOR_SERVER : URL to Rekor server (e.g., https://rekor.example.com)
+ - COSIGN_PATH  : path to cosign binary (default: cosign)
+"""
+import os, subprocess, json
+from fastapi import FastAPI, Request
+
+REKOR_SERVER = os.environ.get("REKOR_SERVER", "")
+COSIGN_PATH = os.environ.get("COSIGN_PATH", "cosign")
+
+app = FastAPI()
+
+def verify_image_with_rekor(image_ref: str) -> (bool, str):
+    if not REKOR_SERVER:
+        return False, "REKOR_SERVER not configured in webhook"
+    try:
+        # cosign verify --rekor-server <rekor> <image>
+        proc = subprocess.run([COSIGN_PATH, "verify", "--rekor-server", REKOR_SERVER, image_ref], capture_output=True, text=True, timeout=60)
+        if proc.returncode == 0:
+            return True, proc.stdout
+        else:
+            return False, proc.stderr + proc.stdout
+    except Exception as e:
+        return False, str(e)
+
+@app.post("/validate")
+async def validate(admreq: Request):
+    body = await admreq.json()
+    req = body.get("request", {})
+    uid = req.get("uid")
+    pod = req.get("object", {})
+    containers = pod.get("spec", {}).get("containers", [])
+    for c in containers:
+        image = c.get("image")
+        ok, out = verify_image_with_rekor(image)
+        if not ok:
+            resp = {
+                "apiVersion": "admission.k8s.io/v1",
+                "kind": "AdmissionReview",
+                "response": {
+                    "uid": uid,
+                    "allowed": False,
+                    "status": {"message": f"cosign rekor verification failed for {image}: {out}"}
+                }
+            }
+            return resp
+    return {
+        "apiVersion": "admission.k8s.io/v1",
+        "kind": "AdmissionReview",
+        "response": {"uid": uid, "allowed": True}
+    }
+
*** End Patch
*** Begin Patch
*** Add File:security/image-verifier/deploy_with_rekor_env.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-image-verifier
+  namespace: ops
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: aegis-image-verifier
+  template:
+    metadata:
+      labels:
+        app: aegis-image-verifier
+    spec:
+      containers:
+      - name: image-verifier
+        image: ghcr.io/your-org/aegis-image-verifier:latest
+        env:
+        - name: REKOR_SERVER
+          valueFrom:
+            secretKeyRef:
+              name: aegis-rekor
+              key: rekor_server
+        - name: COSIGN_PATH
+          value: "/usr/local/bin/cosign"
+        ports:
+        - containerPort: 8443
+        volumeMounts:
+        - name: webhook-tls
+          mountPath: /etc/webhook/certs
+          readOnly: true
+      volumes:
+      - name: webhook-tls
+        secret:
+          secretName: aegis-image-verifier-tls
+
*** End Patch
*** Begin Patch
*** Add File:scripts/validate/end_to_end_validate.sh
+#!/usr/bin/env bash
+set -euo pipefail
+ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
+
+usage() {
+  cat <<EOF
+Run end-to-end validation (operator-run).
+Prereqs:
+ - terraform applied for provider modules and outputs saved
+ - GitHub Actions workflows configured and able to sign images via provider KMS (OIDC)
+ - Rekor server URL in secrets (REKOR_SERVER)
+ - Kubernetes cluster configured and webhook deployed
+
+Usage:
+  ./scripts/validate/end_to_end_validate.sh --image <image:tag>
+EOF
+  exit 1
+}
+
+IMAGE=""
+
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --image) IMAGE="$2"; shift 2;;
+    *) usage;;
+  esac
+done
+
+if [ -z "$IMAGE" ]; then usage; fi
+
+echo "1) Verify Rekor entry for $IMAGE"
+if ! command -v cosign >/dev/null 2>&1; then
+  echo "cosign missing; please install cosign"
+  exit 2
+fi
+
+REKOR_SERVER="${REKOR_SERVER:-}"
+if [ -z "$REKOR_SERVER" ]; then
+  echo "Set REKOR_SERVER env var to your Rekor server URL"
+  exit 2
+fi
+
+echo "Running cosign verify --rekor-server $REKOR_SERVER $IMAGE"
+cosign verify --rekor-server "$REKOR_SERVER" "$IMAGE" || { echo "cosign verify failed"; exit 2; }
+
+echo "2) Try to deploy a pod using $IMAGE to test admission webhook"
+NS="aegis-validate"
+kubectl create ns "$NS" || true
+cat > /tmp/aegis-validate-pod.yaml <<YAML
+apiVersion: v1
+kind: Pod
+metadata:
+  name: aegis-validate-pod
+  namespace: $NS
+spec:
+  containers:
+  - name: app
+    image: $IMAGE
+    command: ["/bin/sh","-c","sleep 300"]
+  restartPolicy: Never
+YAML
+
+set +e
+kubectl apply -f /tmp/aegis-validate-pod.yaml
+APPLY_RC=$?
+set -e
+
+if [ $APPLY_RC -ne 0 ]; then
+  echo "Pod creation denied (expected for unsigned images) or webhook blocking. Check webhook logs."
+  kubectl get events -n $NS --sort-by='.metadata.creationTimestamp'
+  exit 2
+fi
+
+echo "Pod created. Waiting for pod status..."
+kubectl wait --for=condition=ready pod/aegis-validate-pod -n $NS --timeout=60s || true
+kubectl get pod aegis-validate-pod -n $NS -o yaml
+
+echo "Validation finished. Clean up resources if needed: kubectl delete ns $NS"
+
*** End Patch
*** Begin Patch
*** Add File:runbooks/provider_finalization_checklist.md
+# Provider Finalization & OIDC Checklist (Azure / OCI / Alibaba)
+
+Follow these steps to finalize provider integration and validate the end-to-end flow.
+
+Step A — Provider OIDC / Federated credentials
+- Azure:
+  1. Create an Azure AD App registration.
+  2. Under "Certificates & secrets" add a federated credential for GitHub Actions (issuer: https://token.actions.githubusercontent.com, subject: repo:<org>/<repo>:ref:refs/heads/main or appropriate).
+  3. Use azure/login@v1 in workflows with client-id and tenant-id; the action performs OIDC login without long-lived secrets.
+  4. Create a User Assigned Managed Identity and assign Key Vault access policy for unwrapKey, wrapKey, get.
+
+- OCI:
+  1. Create an Identity Provider and configure OIDC trust for GitHub Actions.
+  2. Create a Dynamic Group matching the federation claim.
+  3. Create an IAM Policy allowing the dynamic group to use keys in the compartment (use least-privilege).
+
+- Alibaba:
+  1. Configure RAM OIDC trust and create a role the GitHub OIDC principal can assume.
+  2. Attach a RAM policy allowing kms:Sign and kms:GetPublicKey for the key resource.
+
+Step B — Terraform apply & outputs
+- Run the provider terraform modules (terraform apply) in each provider directory.
+- Save outputs in a secure remote state. Note the key URIs (azurekms://..., oci://..., alibabakms://...).
+
+Step C — CI setup (no long-lived secrets)
+- Add secrets in repo for:
+  - AZURE_OIDC_CLIENT_ID (Azure app client id)
+  - AZURE_TENANT_ID
+  - AZURE_KEY_URI (azurekms://...)
+  - OCI_KEY_URI (oci://...)
+  - ALICLOUD_KEY_URI
+  - REKOR_SERVER (https://rekor.example.com)
+  - GHCR_PAT for pushing images (or use GitHub Packages permissions)
+- Configure repository to allow OIDC federation in provider consoles.
+
+Step D — Run CI workflow to build & sign
+- Trigger the Azure / OCI / Alibaba workflows. They will build the image, push it and cosign sign using provider KMS (and log to Rekor).
+
+Step E — Deploy Rekor-based webhook
+- Create secret aegis-rekor with rekor_server key set to your rekor server URL.
+- Deploy aegis-image-verifier with deploy_with_rekor_env.yaml (adjust image).
+- Create TLS cert and apply ValidatingWebhookConfiguration (set caBundle).
+
+Step F — Validation
+- Use scripts/validate/end_to_end_validate.sh --image <image:tag> to verify cosign/Rekor verification and webhook admission.
+
*** End Patch
*** End Patch
