*** Begin Patch
*** Add File:.github/workflows/promotion_notify_and_release.yml
+name: Promotion Notify & Release
+on:
+  repository_dispatch:
+    types: [promotion_complete]
+  workflow_dispatch:
+
+jobs:
+  promote-and-notify:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Prepare environment
+        run: |
+          python3 -m pip install boto3 requests || true
+
+      - name: Run compliance pack generator
+        env:
+          EVIDENCE_BUCKET: ${{ secrets.EVIDENCE_BUCKET }}
+          COSIGN_KMS_KEY_ARN: ${{ secrets.COSIGN_KMS_KEY_ARN }}
+        run: |
+          python3 compliance/generate_compliance_pack.py || true
+
+      - name: Upload manifest (if present) and create release & comment PR
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          ARGO_PAYLOAD: ${{ toJSON(github.event.client_payload) }}
+          EVIDENCE_BUCKET: ${{ secrets.EVIDENCE_BUCKET }}
+        run: |
+          python3 - <<PY
+import os, json, requests
+payload = json.loads(os.environ.get("ARGO_PAYLOAD","{}"))
+repo = os.environ.get("GITHUB_REPOSITORY")
+token = os.environ.get("GITHUB_TOKEN")
+headers = {"Authorization": "token "+token, "Accept":"application/vnd.github.v3+json"}
+pr = payload.get("pr_number")
+manifest_s3 = payload.get("manifest_s3")
+evidence = payload.get("evidence_s3")
+release_name = "promotion-"+str(payload.get("artifact", "artifact"))
+body = f"Promotion completed. Manifest: {manifest_s3}\\nEvidence: {evidence}"
+# create release
+if repo:
+    owner,repo_name = repo.split("/")
+    r = requests.post(f"https://api.github.com/repos/{owner}/{repo_name}/releases", headers=headers, json={"tag_name": release_name, "name": release_name, "body": body})
+    print("release:", r.status_code)
+# comment on PR if provided
+if pr and repo:
+    r = requests.post(f"https://api.github.com/repos/{owner}/{repo_name}/issues/{pr}/comments", headers=headers, json={"body": "Promotion completed: "+body})
+    print("pr comment:", r.status_code)
+print("Promotion notify done")
+PY
+
*** End Patch
*** Begin Patch
*** Add File:scripts/integrations/webhook_receiver/app.py
+#!/usr/bin/env python3
+"""
+Simple webhook receiver for promotion notifications and Gatekeeper alerts.
+Responsibilities:
+ - Accept JSON payloads (promotion_complete) from Argo or CI
+ - Trigger a GitHub repository_dispatch to run promotion workflows (optional)
+ - Post notifications to Slack and Teams
+ - Create Jira issues for high-severity Gatekeeper events (optional)
+
+Configure via environment variables:
+ - GITHUB_REPO (owner/repo)
+ - GITHUB_TOKEN (PAT with repo scope)
+ - SLACK_WEBHOOK_URL
+ - TEAMS_WEBHOOK_URL
+ - JIRA_URL, JIRA_USER, JIRA_API_TOKEN, JIRA_PROJECT_KEY
+
+This app is intentionally small â€” run in-cluster and secure with NetworkPolicy/auth.
+"""
+import os, json, requests
+from flask import Flask, request, jsonify
+
+app = Flask("aegis-webhook-receiver")
+
+GITHUB_REPO = os.environ.get("GITHUB_REPO")
+GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
+SLACK_WEBHOOK = os.environ.get("SLACK_WEBHOOK_URL")
+TEAMS_WEBHOOK = os.environ.get("TEAMS_WEBHOOK_URL")
+JIRA_URL = os.environ.get("JIRA_URL")
+JIRA_USER = os.environ.get("JIRA_USER")
+JIRA_TOKEN = os.environ.get("JIRA_API_TOKEN")
+JIRA_PROJECT = os.environ.get("JIRA_PROJECT_KEY")
+
+def post_slack(msg):
+    if not SLACK_WEBHOOK:
+        return
+    requests.post(SLACK_WEBHOOK, json={"text": msg}, timeout=5)
+
+def post_teams(msg):
+    if not TEAMS_WEBHOOK:
+        return
+    requests.post(TEAMS_WEBHOOK, json={"text": msg}, timeout=5)
+
+def create_jira_issue(summary, description, priority="Medium"):
+    if not (JIRA_URL and JIRA_USER and JIRA_TOKEN and JIRA_PROJECT):
+        return None
+    url = f"{JIRA_URL}/rest/api/2/issue"
+    auth = (JIRA_USER, JIRA_TOKEN)
+    payload = {"fields": {"project": {"key": JIRA_PROJECT}, "summary": summary, "description": description, "issuetype": {"name":"Task"}, "priority": {"name": priority}}}
+    r = requests.post(url, auth=auth, json=payload, timeout=10)
+    if r.status_code in (200,201):
+        return r.json().get("key")
+    return None
+
+def trigger_repo_dispatch(event_type, client_payload):
+    if not (GITHUB_REPO and GITHUB_TOKEN):
+        return
+    url = f"https://api.github.com/repos/{GITHUB_REPO}/dispatches"
+    headers = {"Authorization": f"token {GITHUB_TOKEN}", "Accept":"application/vnd.github.v3+json"}
+    payload = {"event_type": event_type, "client_payload": client_payload}
+    requests.post(url, headers=headers, json=payload, timeout=10)
+
+@app.route("/health", methods=["GET"])
+def health():
+    return jsonify({"status":"ok"})
+
+@app.route("/notify", methods=["POST"])
+def notify():
+    j = request.get_json(force=True)
+    typ = j.get("type") or j.get("event") or "promotion"
+    if typ == "promotion" or typ == "promotion_complete":
+        artifact = j.get("artifact", "artifact")
+        manifest_s3 = j.get("manifest_s3","")
+        evidence_s3 = j.get("evidence_s3","")
+        pr = j.get("pr_number")
+        msg = f"Promotion complete for {artifact}\nManifest: {manifest_s3}\nEvidence: {evidence_s3}"
+        post_slack(msg)
+        post_teams(msg)
+        # comment on PR and trigger CI
+        trigger_repo_dispatch("promotion_complete", {"artifact": artifact, "manifest_s3": manifest_s3, "evidence_s3": evidence_s3, "pr_number": pr})
+        return jsonify({"status":"ok","msg":"notified"})
+    elif typ == "gatekeeper_violation":
+        summary = j.get("summary","Gatekeeper violation")
+        desc = j.get("details", json.dumps(j))
+        post_slack("Gatekeeper violation: "+summary)
+        key = create_jira_issue(summary, desc)
+        return jsonify({"status":"ok","jira": key})
+    else:
+        post_slack("Received unknown notification: "+json.dumps(j))
+        return jsonify({"status":"ok","note":"unknown"})
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "8080")))
+
*** End Patch
*** Begin Patch
*** Add File:integrations/webhook_receiver/Dockerfile
+FROM python:3.10-slim
+WORKDIR /app
+RUN pip install flask requests
+COPY app.py /app/app.py
+EXPOSE 8080
+CMD ["python","/app/app.py"]
+
*** End Patch
*** Begin Patch
*** Add File:integrations/webhook_receiver/deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: aegis-webhook-receiver
+  namespace: aegis
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: aegis-webhook-receiver
+  template:
+    metadata:
+      labels:
+        app: aegis-webhook-receiver
+    spec:
+      serviceAccountName: aegis-webhook-sa
+      containers:
+        - name: webhook
+          image: registry.example.com/aegis/webhook-receiver:latest
+          env:
+            - name: GITHUB_REPO
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: GITHUB_REPO
+            - name: GITHUB_TOKEN
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: GITHUB_TOKEN
+            - name: SLACK_WEBHOOK_URL
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: SLACK_WEBHOOK_URL
+            - name: TEAMS_WEBHOOK_URL
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: TEAMS_WEBHOOK_URL
+            - name: JIRA_URL
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: JIRA_URL
+            - name: JIRA_USER
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: JIRA_USER
+            - name: JIRA_API_TOKEN
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: JIRA_API_TOKEN
+            - name: JIRA_PROJECT_KEY
+              valueFrom:
+                secretKeyRef:
+                  name: aegis-required-secrets
+                  key: JIRA_PROJECT_KEY
+          ports:
+            - containerPort: 8080
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: aegis-webhook-receiver
+  namespace: aegis
+spec:
+  selector:
+    app: aegis-webhook-receiver
+  ports:
+    - port: 8080
+      targetPort: 8080
+
+---
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: aegis-webhook-sa
+  namespace: aegis
+
*** End Patch
*** Begin Patch
*** Add File:scripts/integrations/gatekeeper_jira_bridge.py
+#!/usr/bin/env python3
+"""
+Bridge to convert Gatekeeper audit/violation outputs into Jira issues and GitHub issues.
+This script reads a Gatekeeper audit JSON file (exported via kubectl or API) and creates Jira issues
+for each new high-severity violation. It keeps a simple local state file to avoid duplicates.
+
+Usage:
+  kubectl get constraints.gatekeeper.sh -o json > /tmp/gatekeeper_audit.json
+  python3 scripts/integrations/gatekeeper_jira_bridge.py /tmp/gatekeeper_audit.json
+
+For production, run as a CronJob that fetches Gatekeeper violations from cluster and posts new issues.
+"""
+import sys, json, os, requests, hashlib
+
+GATEKEEPER_AUDIT_FILE = sys.argv[1] if len(sys.argv)>1 else "/tmp/gatekeeper_audit.json"
+SEEN_FILE = "/tmp/gatekeeper_seen.txt"
+JIRA_URL = os.environ.get("JIRA_URL")
+JIRA_USER = os.environ.get("JIRA_USER")
+JIRA_TOKEN = os.environ.get("JIRA_API_TOKEN")
+JIRA_PROJECT = os.environ.get("JIRA_PROJECT_KEY")
+GITHUB_REPO = os.environ.get("GITHUB_REPO")
+GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
+
+def mark_seen(key):
+    open(SEEN_FILE,"a").write(key+"\n")
+
+def already_seen(key):
+    if not os.path.exists(SEEN_FILE):
+        return False
+    return key+"\n" in open(SEEN_FILE).read()
+
+def create_jira(summary, desc):
+    if not (JIRA_URL and JIRA_USER and JIRA_TOKEN and JIRA_PROJECT):
+        return None
+    url = f"{JIRA_URL}/rest/api/2/issue"
+    auth = (JIRA_USER, JIRA_TOKEN)
+    payload = {"fields":{"project":{"key":JIRA_PROJECT},"summary":summary,"description":desc,"issuetype":{"name":"Bug"}}}
+    r = requests.post(url, auth=auth, json=payload, timeout=10)
+    if r.status_code in (200,201):
+        return r.json().get("key")
+    return None
+
+def create_github_issue(title, body):
+    if not (GITHUB_REPO and GITHUB_TOKEN):
+        return None
+    owner,repo = GITHUB_REPO.split("/")
+    url = f"https://api.github.com/repos/{owner}/{repo}/issues"
+    headers = {"Authorization":"token "+GITHUB_TOKEN, "Accept":"application/vnd.github.v3+json"}
+    r = requests.post(url, headers=headers, json={"title":title,"body":body}, timeout=10)
+    if r.status_code in (200,201):
+        return r.json().get("number")
+    return None
+
+data = json.load(open(GATEKEEPER_AUDIT_FILE))
+# Normalize: look for .items or direct
+items = data.get("items", data)
+count=0
+for it in items if isinstance(items, list) else [items]:
+    # create a digest key
+    text = json.dumps(it, sort_keys=True)
+    key = hashlib.sha256(text.encode()).hexdigest()
+    if already_seen(key):
+        continue
+    # create issues
+    summary = it.get("metadata",{}).get("name", "Gatekeeper violation")
+    desc = "Gatekeeper violation detected:\n\n" + json.dumps(it, indent=2)
+    jira = create_jira(summary, desc)
+    gh = create_github_issue(summary, desc)
+    mark_seen(key)
+    count += 1
+    print("Created issues:", jira, gh)
+
+print("Processed", count, "new gatekeeper items")
+
*** End Patch
*** Begin Patch
*** Add File:scripts/integrations/notify_slack_teams.py
+#!/usr/bin/env python3
+"""
+Utility to post messages to Slack and Teams.
+Usage:
+  python3 scripts/integrations/notify_slack_teams.py --msg "Hello" --level info
+"""
+import argparse, os, requests, json
+
+SLACK_WEBHOOK = os.environ.get("SLACK_WEBHOOK_URL")
+TEAMS_WEBHOOK = os.environ.get("TEAMS_WEBHOOK_URL")
+
+def post_slack(msg):
+    if not SLACK_WEBHOOK:
+        print("No SLACK_WEBHOOK_URL configured")
+        return
+    requests.post(SLACK_WEBHOOK, json={"text": msg}, timeout=5)
+
+def post_teams(msg):
+    if not TEAMS_WEBHOOK:
+        print("No TEAMS_WEBHOOK_URL configured")
+        return
+    requests.post(TEAMS_WEBHOOK, json={"text": msg}, timeout=5)
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--msg", required=True)
+    args = p.parse_args()
+    post_slack(args.msg)
+    post_teams(args.msg)
+    print("Notified Slack/Teams")
+
+if __name__=="__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/weekly_kpi_report.yml
+name: Weekly KPI Report
+on:
+  schedule:
+    - cron: "0 9 * * 1" # every Monday 09:00 UTC
+  workflow_dispatch:
+
+jobs:
+  report:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Query KPI exporter and post to Slack/Teams
+        env:
+          KPI_URL: ${{ secrets.KPI_URL }}
+          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
+          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
+        run: |
+          python3 - <<PY
+import os, requests, json
+KPI_URL=os.environ.get("KPI_URL")
+slack=os.environ.get("SLACK_WEBHOOK_URL")
+teams=os.environ.get("TEAMS_WEBHOOK_URL")
+def get_kpi(k):
+    try:
+        r=requests.get(KPI_URL.rstrip('/')+'/metrics', timeout=10)
+        return r.text[:500]
+    except Exception as e:
+        return str(e)
+msg = f"Aegis KPI report:\\n{get_kpi('metrics')}"
+if slack:
+    requests.post(slack, json={"text": msg})
+if teams:
+    requests.post(teams, json={"text": msg})
+print('Report sent')
+PY
+
*** End Patch
*** Begin Patch
*** Add File:.github/ISSUE_TEMPLATE/model_promotion.md
+name: Model Promotion Request
+about: Request to promote a model artifact through Aegis promotion workflow
+title: "[PROMOTE] {model-name} {version}"
+labels: "promotion"
+assignees: ""
+
+---
+
+## Model
+- Name:
+- Version:
+- Artifact S3 path:
+
+## CI / Evidence
+- Manifest S3:
+- SBOM:
+- Trivy SCA:
+- Cosign attestation (Rekor):
+
+## Acceptance Criteria
+- Unit tests: pass
+- V&V: digital twin smoke pass
+- Safety checks: no blocking findings
+- Performance: latency < threshold
+
+## Reviewer checklist
+- Verify manifest & SBOM
+- Verify evidence in EVIDENCE_BUCKET
+- Verify Rekor entry present
+- Approve promotion
+
*** End Patch
*** Begin Patch
*** Add File:.github/ISSUE_TEMPLATE/vv_checklist.md
+name: V&V Checklist
+about: Verification & Validation checklist for ML artifacts
+title: "[V&V] {artifact}"
+labels: "v&v"
+
+---
+
+## Tests
+- Unit tests: [ ] coverage >= required
+- Integration tests: [ ] pass
+- Digital twin scenarios: [ ] pass
+
+## Safety
+- Adversarial test run attached: [ ] evidence
+- Safety-monitor results: [ ] attached
+
+## Evidence
+- SBOM: [ ]
+- Trivy report: [ ]
+- Signed evidence: [ ]
+
*** End Patch
*** Begin Patch
*** Add File:.github/PULL_REQUEST_TEMPLATE.md
+<!-- Describe the change in this PR related to Aegis platform or model artifacts -->
+
+Summary:
+- What changed and why:
+- Which artifacts were produced (manifest, sbom, evidence):
+
+Checklist:
+- [ ] SBOM generated
+- [ ] Trivy SCA run
+- [ ] Manifest signed (cosign)
+- [ ] Evidence bundle uploaded to EVIDENCE_BUCKET
+- [ ] Rekor attestation present
+- [ ] Associated issue created/updated
+
*** End Patch
*** Begin Patch
*** Add File:scripts/integrations/create_github_project.py
+#!/usr/bin/env python3
+"""
+Create a GitHub Project (v2) or a classic project board for tracking promotion issues.
+Requires GITHUB_TOKEN with repo scope and GITHUB_REPO env (owner/repo).
+"""
+import os, requests, json, sys
+
+GITHUB_REPO = os.environ.get("GITHUB_REPO")
+TOKEN = os.environ.get("GITHUB_TOKEN")
+
+if not (GITHUB_REPO and TOKEN):
+    print("Set GITHUB_REPO and GITHUB_TOKEN")
+    sys.exit(1)
+
+owner, repo = GITHUB_REPO.split("/")
+headers = {"Authorization":"token "+TOKEN, "Accept":"application/vnd.github.v3+json"}
+
+name = "Aegis Promotions"
+# Create classic project (deprecated in some orgs) - fallback to repo projects API
+url = f"https://api.github.com/repos/{owner}/{repo}/projects"
+resp = requests.post(url, headers=headers, json={"name":name, "body":"Project board for Aegis promotions"})
+print("status", resp.status_code, resp.text)
+
*** End Patch
*** Begin Patch
*** Add File:docs/INTEGRATIONS_README.md
+# Aegis Integrations: GitHub/Jira/Slack/Teams
+
+What this patch adds:
+- A webhook receiver service (integrations/webhook_receiver) that accepts promotion and gatekeeper notifications, posts to Slack/Teams, creates Jira issues, and triggers GitHub repository_dispatch.
+- A Gatekeeper->Jira bridge script to convert audit exports into Jira/GitHub issues.
+- GitHub Actions:
+  - promotion_notify_and_release.yml: runs compliance pack, creates GitHub release and comments PR.
+  - weekly_kpi_report.yml: posts weekly KPI snapshot to Slack/Teams.
+- Issue & PR templates to standardize model promotion workflow.
+- Scripts to create a GitHub Project board.
+
+Operator notes:
+- Create a Kubernetes secret aegis-required-secrets containing required integration secrets (Jira, Slack, Teams, GitHub PAT).
+- Build and push the webhook_receiver image and deploy the Kubernetes deployment/service.
+- Configure Argo/CI to POST to the webhook receiver /notify endpoint on promotion completion using the payload:
+  { "type":"promotion_complete", "artifact":"...", "manifest_s3":"s3://...", "evidence_s3":"s3://...", "pr_number": 123 }
+- Run the Gatekeeper audit export periodically and feed to scripts/integrations/gatekeeper_jira_bridge.py to open issues automatically.
+
*** End Patch
*** End Patch
