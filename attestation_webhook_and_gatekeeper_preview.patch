*** Begin Patch
*** Add File: scripts/create_webhook_certs.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Create a self-signed CA and a server certificate for the attestation service,
+# create a TLS secret in Kubernetes, and print the CA bundle (base64) to embed
+# into a ValidatingWebhookConfiguration caBundle field.
+#
+# Usage:
+#   ./scripts/create_webhook_certs.sh <namespace> <service-name> <secret-name>
+# Example:
+#   ./scripts/create_webhook_certs.sh ops attestation attestation-tls
+#
+NS=${1:-ops}
+SVC=${2:-attestation}
+SECRET=${3:-attestation-tls}
+
+TMPDIR=$(mktemp -d)
+pushd "$TMPDIR" >/dev/null
+
+CA_KEY="$TMPDIR/ca.key.pem"
+CA_CERT="$TMPDIR/ca.cert.pem"
+SERVER_KEY="$TMPDIR/server.key.pem"
+SERVER_CSR="$TMPDIR/server.csr.pem"
+SERVER_CERT="$TMPDIR/server.cert.pem"
+CSR_CONF="$TMPDIR/csr.conf"
+
+echo "Generating CA private key and self-signed cert..."
+openssl genpkey -algorithm RSA -out "$CA_KEY" -pkeyopt rsa_keygen_bits:2048
+openssl req -x509 -new -nodes -key "$CA_KEY" -sha256 -days 3650 -subj "/CN=aegis-webhook-ca" -out "$CA_CERT"
+
+echo "Generating server private key..."
+openssl genpkey -algorithm RSA -out "$SERVER_KEY" -pkeyopt rsa_keygen_bits:2048
+
+cat > "$CSR_CONF" <<EOF
+[req]
+distinguished_name = req_distinguished_name
+req_extensions = v3_req
+[req_distinguished_name]
+
+[v3_req]
+subjectAltName = @alt_names
+
+[alt_names]
+DNS.1 = ${SVC}
+DNS.2 = ${SVC}.${NS}
+DNS.3 = ${SVC}.${NS}.svc
+EOF
+
+echo "Creating CSR..."
+openssl req -new -key "$SERVER_KEY" -subj "/CN=${SVC}.${NS}.svc" -out "$SERVER_CSR" -config "$CSR_CONF"
+
+echo "Signing server certificate with CA..."
+openssl x509 -req -in "$SERVER_CSR" -CA "$CA_CERT" -CAkey "$CA_KEY" -CAcreateserial -out "$SERVER_CERT" -days 365 -sha256 -extensions v3_req -extfile "$CSR_CONF"
+
+echo "Creating Kubernetes TLS secret ${SECRET} in namespace ${NS}..."
+kubectl create secret tls "$SECRET" \
+  --cert="$SERVER_CERT" \
+  --key="$SERVER_KEY" \
+  -n "$NS" --dry-run=client -o yaml | kubectl apply -f -
+
+CA_BUNDLE=$(base64 -w0 < "$CA_CERT")
+
+echo
+echo "CA bundle (base64) to paste into ValidatingWebhookConfiguration caBundle:"
+echo
+echo "$CA_BUNDLE"
+echo
+echo "You can optionally clean up temporary files in $TMPDIR"
+popd >/dev/null
+
*** End Patch
*** Begin Patch
*** Add File: k8s/attestation/attestation-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: attestation
+  namespace: ops
+  labels:
+    app: attestation
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: attestation
+  template:
+    metadata:
+      labels:
+        app: attestation
+    spec:
+      containers:
+      - name: attestation
+        image: ghcr.io/yourorg/attestation-service:latest
+        ports:
+          - containerPort: 8443
+        env:
+          - name: COSIGN_BIN
+            value: "cosign"
+          - name: REKOR_URL
+            value: "https://rekor.sigstore.dev"
+        volumeMounts:
+          - name: tls
+            mountPath: /tls
+            readOnly: true
+      volumes:
+        - name: tls
+          secret:
+            secretName: attestation-tls
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: attestation
+  namespace: ops
+spec:
+  selector:
+    app: attestation
+  ports:
+    - port: 8443
+      targetPort: 8443
+
*** End Patch
*** Begin Patch
*** Add File: k8s/webhook/attestation-validatingwebhook.yaml
+apiVersion: admissionregistration.k8s.io/v1
+kind: ValidatingWebhookConfiguration
+metadata:
+  name: aegis-attestation-webhook
+webhooks:
+  - name: attestation.aegis.local
+    sideEffects: None
+    admissionReviewVersions: ["v1"]
+    clientConfig:
+      service:
+        name: attestation
+        namespace: ops
+        path: /verify
+      caBundle: "" # <-- replace with base64 CA bundle printed by create_webhook_certs.sh
+    rules:
+      - operations: ["CREATE", "UPDATE"]
+        apiGroups: ["apps", ""]
+        apiVersions: ["v1"]
+        resources: ["deployments", "pods"]
+    failurePolicy: Fail
+    timeoutSeconds: 10
+    matchPolicy: Equivalent
+
*** End Patch
*** Begin Patch
*** Add File: governance/gatekeeper/constrainttemplate_require_attested.yaml
+apiVersion: templates.gatekeeper.sh/v1beta1
+kind: ConstraintTemplate
+metadata:
+  name: k8srequireattested
+spec:
+  crd:
+    spec:
+      names:
+        kind: K8sRequireAttested
+  targets:
+    - target: admission.k8s.gatekeeper.sh
+      rego: |
+        package k8srequireattested
+
+        violation[{"msg": msg}] {
+          input.review.kind.kind == "Deployment"
+          metadata := input.review.object.metadata
+          annotations := metadata.annotations
+          not attested(annotations)
+          msg := "Deployment is missing required attestation annotation 'aegis.attested=true'"
+        }
+
+        attested(annotations) {
+          annotations["aegis.attested"] == "true"
+        }
+
*** End Patch
*** Begin Patch
*** Add File: governance/gatekeeper/constraint_require_attested_constraint.yaml
+apiVersion: constraints.gatekeeper.sh/v1beta1
+kind: K8sRequireAttested
+metadata:
+  name: require-attestation-annotation
+spec:
+  match:
+    kinds:
+      - apiGroups: ["apps"]
+        kinds: ["Deployment"]
+    namespaces: ["staging", "ops"]
+  parameters: {}
+
*** End Patch
*** Begin Patch
*** Add File: scripts/inject_ca_bundle.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Inject the base64 CA bundle into the ValidatingWebhookConfiguration manifest.
+#
+# Usage:
+#   ./scripts/inject_ca_bundle.sh <validating-webhook-name> <ca-bundle-base64>
+#
+WEBHOOK_NAME=${1:-aegis-attestation-webhook}
+CA_B64=${2:-}
+
+if [ -z "$CA_B64" ]; then
+  echo "Usage: $0 <validating-webhook-name> <ca-bundle-base64>"
+  exit 2
+fi
+
+kubectl get validatingwebhookconfiguration "$WEBHOOK_NAME" -o yaml > /tmp/webhook.yaml
+python3 - <<PY
+import sys, yaml, base64
+f="/tmp/webhook.yaml"
+data=yaml.safe_load(open(f))
+for w in data.get("webhooks",[]):
+    w["clientConfig"]["caBundle"] = "$CA_B64"
+open(f,"w").write(yaml.safe_dump(data))
+print("Wrote /tmp/webhook.yaml")
+PY
+
+kubectl apply -f /tmp/webhook.yaml
+echo "Injected CA bundle into ValidatingWebhookConfiguration/$WEBHOOK_NAME"
+
*** End Patch
*** Begin Patch
*** Add File: tests/unsigned_deploy.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: unsigned-test
+  namespace: staging
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: unsigned-test
+  template:
+    metadata:
+      labels:
+        app: unsigned-test
+    spec:
+      containers:
+      - name: app
+        image: ghcr.io/yourorg/unsigned-image:latest
+        command: ["sleep","3600"]
+
*** End Patch
*** Begin Patch
*** Add File: tests/signed_deploy.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: signed-test
+  namespace: staging
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: signed-test
+  template:
+    metadata:
+      labels:
+        app: signed-test
+      annotations:
+        aegis.attested: "true"   # Gatekeeper constraint requires this annotation; attestation webhook still validates signature
+    spec:
+      containers:
+      - name: app
+        image: REPLACE_WITH_SIGNED_IMAGE@sha256:REPLACE_DIGEST
+        command: ["sleep","3600"]
+
*** End Patch
*** Begin Patch
*** Add File: scripts/attestation_smoke_test.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Smoke test for attestation + Gatekeeper enforcement.
+# Requirements:
+#  - kubectl configured to target cluster
+#  - cosign installed and available in PATH
+#  - a container registry you can push to (REGISTRY env var)
+#  - create_webhook_certs.sh applied, attestation deployment up, and ValidatingWebhookConfiguration patched with CA bundle
+#
+# Steps:
+# 1) Attempt to apply unsigned deployment (should be rejected by webhook or Gatekeeper)
+# 2) Build a tiny image, push to registry, sign it with cosign using ephemeral key, apply signed deployment (should succeed)
+#
+REGISTRY=${REGISTRY:-}
+NAMESPACE=${NAMESPACE:-staging}
+
+if [ -z "$REGISTRY" ]; then
+  echo "Please set REGISTRY environment variable (e.g., REGISTRY=ghcr.io/yourorg)"
+  exit 2
+fi
+
+echo "1) Test unsigned deployment (expected: rejection)"
+if kubectl apply -f tests/unsigned_deploy.yaml; then
+  echo "ERROR: unsigned deployment was accepted (expected rejection)"
+  kubectl delete -f tests/unsigned_deploy.yaml --ignore-not-found
+  exit 1
+else
+  echo "OK: unsigned deployment rejected as expected"
+fi
+
+echo "2) Build a tiny image and push to registry"
+TMPDIR=$(mktemp -d)
+cat > "$TMPDIR/Dockerfile" <<EOF
+FROM busybox
+CMD ["sleep","3600"]
+EOF
+IMAGE="$REGISTRY/attestation-test:$(date +%s)"
+docker build -t "$IMAGE" "$TMPDIR"
+docker push "$IMAGE"
+
+echo "Generating ephemeral cosign keypair for test signing..."
+COSIGN_KEY="$TMPDIR/cosign.key"
+COSIGN_PUB="$TMPDIR/cosign.pub"
+cosign generate-key-pair -password "" -key "$COSIGN_KEY"
+
+echo "Signing image with cosign (local key)..."
+cosign sign --key "$COSIGN_KEY" "$IMAGE"
+
+DIGEST=$(skopeo inspect --raw "docker://$IMAGE" | sha256sum | awk '{print $1}')
+# Note: retrieving digest in CI might differ; attempt to read via docker inspect as fallback
+if [ -z "$DIGEST" ]; then
+  DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" | awk -F@ '{print $2}' || true)
+fi
+
+if [ -z "$DIGEST" ]; then
+  echo "Could not determine image digest; you may need to adapt this step for your registry."
+  echo "Applying signed deployment using image tag instead (may still be validated by attestation)."
+  S_IMAGE="$IMAGE"
+else
+  S_IMAGE="$IMAGE@$DIGEST"
+fi
+
+echo "Preparing signed deployment manifest..."
+sed "s|REPLACE_WITH_SIGNED_IMAGE|$IMAGE|; s|REPLACE_DIGEST|$DIGEST|g" tests/signed_deploy.yaml > /tmp/signed_deploy.yaml
+
+echo "Applying signed deployment (expected: accepted)"
+kubectl apply -f /tmp/signed_deploy.yaml
+echo "Waiting briefly for pod creation..."
+sleep 5
+kubectl get deploy signed-test -n "$NAMESPACE"
+echo "Cleanup: deleting signed deployment..."
+kubectl delete -f /tmp/signed_deploy.yaml --ignore-not-found
+
+echo "Smoke test complete. Note: If the attestation webhook verifies Rekor/cosign with KMS, adapt signing step to use cosign with KMS instead of local key."
+
*** End Patch
*** Begin Patch
*** Add File: runbooks/attestation_deploy_runbook.md
+# Attestation Webhook & Gatekeeper Runbook
+
+Purpose
+- Deploy an attestation service that verifies cosign signatures and Rekor entries, enforce attestation via a Kubernetes ValidatingWebhookConfiguration, and add a Gatekeeper constraint requiring an attestation annotation.
+
+Prerequisites
+- kubectl configured to target the target cluster (staging).
+- cosign installed locally for testing.
+- docker and a registry you can push to (or use GitHub Container Registry with appropriate auth).
+- Gatekeeper installed (if not present, instructions below).
+
+Files included in this preview
+- scripts/create_webhook_certs.sh  — create CA, server cert, create TLS secret, prints CA bundle
+- k8s/attestation/attestation-deployment.yaml — Attestation service Deployment + Service
+- k8s/webhook/attestation-validatingwebhook.yaml — ValidatingWebhookConfiguration (caBundle placeholder)
+- governance/gatekeeper/constrainttemplate_require_attested.yaml — Gatekeeper ConstraintTemplate (annotation check)
+- governance/gatekeeper/constraint_require_attested_constraint.yaml — Gatekeeper constraint instance
+- scripts/inject_ca_bundle.sh — helper to patch webhook caBundle
+- tests/unsigned_deploy.yaml, tests/signed_deploy.yaml — test manifests
+- scripts/attestation_smoke_test.sh — automated smoke test harness
+
+High-level steps
+1) Install Gatekeeper (if not already)
+   kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
+
+2) Deploy attestation service and TLS secret
+   ./scripts/create_webhook_certs.sh ops attestation attestation-tls
+   # copy the printed CA bundle string
+   kubectl apply -f k8s/attestation/attestation-deployment.yaml
+
+3) Patch ValidatingWebhookConfiguration with the CA bundle
+   # take base64 CA from previous step and inject
+   ./scripts/inject_ca_bundle.sh aegis-attestation-webhook <BASE64_CA_BUNDLE>
+   kubectl apply -f k8s/webhook/attestation-validatingwebhook.yaml
+
+4) Deploy Gatekeeper ConstraintTemplate and Constraint
+   kubectl apply -f governance/gatekeeper/constrainttemplate_require_attested.yaml
+   kubectl apply -f governance/gatekeeper/constraint_require_attested_constraint.yaml
+
+5) Test (manual)
+- Unsigned deploy: kubectl apply -f tests/unsigned_deploy.yaml
+  - Expected: Rejected (admission failure). Check: kubectl get events -n staging | tail -n 50
+- Signed deploy: Build & push an image to your registry, sign with cosign (prefer KMS in CI), update tests/signed_deploy.yaml with image@digest and apply:
+  - kubectl apply -f tests/signed_deploy.yaml
+  - Expected: Accepted and deployed
+
+6) Automated smoke test
+   REGISTRY=ghcr.io/yourorg ./scripts/attestation_smoke_test.sh
+
+Notes & troubleshooting
+- If webhook reports TLS errors, confirm the caBundle matches the CA that signed the server cert (use create_webhook_certs.sh output).
+- ValidatingWebhookConfiguration clientConfig.service must point to the Service name and namespace where the attestation service runs.
+- If Gatekeeper is blocking unexpected resources, inspect Gatekeeper logs and constraint status via:
+  kubectl get constraint -A
+  kubectl describe <constraint> -n <namespace>
+
+Security notes
+- For production, use cert-manager with proper CA and short-lived certs or use a central CA.
+- Use cosign with KMS/HSM from CI; the test harness uses a local key for convenience only.
+- The attestation service must run with TLS and should be configured to limit access (e.g., namespace NetworkPolicy).
+
+Acceptance tests (pass/fail)
+- Unsigned deployment must fail admission (Fail = PASS).
+- Signed, attested deployment must be accepted and the Deployment annotated aegis.attested=true (PASS).
+- Gatekeeper constraint must reject any Deployment without aegis.attested=true in staging & ops namespaces (PASS).
+
+Next steps (after success)
+- Migrate CI to sign using KMS-backed cosign (Terraform example in repo).
+- Extend attestation service to require Rekor entry and SBOM policy checks (rescan for critical CVEs).
+- Add automated checks in pre-deploy pipelines that call the attestation service before kubectl apply.
+
*** End Patch
*** End Patch
