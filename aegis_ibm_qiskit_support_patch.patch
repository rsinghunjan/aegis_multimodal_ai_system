*** Begin Patch
*** Add File: services/quantum_controller/adapters/ibm_adapter.py
+"""
+IBM Quantum (Qiskit) adapter for Aegis Quantum Job Controller.
+ - Supports local simulation with Qiskit Aer (if installed).
+ - Supports remote execution on IBM Quantum backends via qiskit-ibm-runtime when IBM_API_TOKEN and IBM_PROJECT are provided.
+ - Writes artifacts (counts/result JSON) into `artifacts_dir` and returns a JSON-able dict.
+
+Usage:
+ - Ensure qiskit and qiskit-ibm-runtime are installed in the worker environment (docker/qiskit image provided).
+ - Set IBM_API_TOKEN and optionally IBM_INSTANCE / IBM_PROJECT in env for real IBMQ execution.
+ - The `circuit` can be an OpenQASM string, or a Python script that defines a `build_and_run(params, output_path)` function.
+"""
+import os
+import time
+import json
+import tempfile
+import subprocess
+from pathlib import Path
+
+try:
+    import qiskit
+    from qiskit import Aer, transpile, assemble
+except Exception:
+    qiskit = None
+
+try:
+    # qiskit-ibm-runtime (modern provider)
+    from qiskit_ibm_runtime import IBMRuntimeService, Options, Sampler, Estimator, Session
+except Exception:
+    IBMRuntimeService = None
+
+
+class IBMAdapter:
+    def __init__(self):
+        self.ibm_token = os.environ.get("IBM_API_TOKEN")
+        self.ibm_instance = os.environ.get("IBM_INSTANCE")  # optional IBM Quantum instance url
+        self.ibm_project = os.environ.get("IBM_PROJECT")
+        self.use_ibm = bool(self.ibm_token and IBMRuntimeService is not None)
+
+    def _run_local_qasm(self, qasm: str, params: dict, artifacts_dir: Path):
+        if not qiskit:
+            raise RuntimeError("qiskit not available in this environment")
+        simulator = Aer.get_backend('aer_simulator')
+        try:
+            qc = qiskit.QuantumCircuit.from_qasm_str(qasm)
+        except Exception as e:
+            # attempt via QASM import fallback
+            raise RuntimeError("Failed to parse QASM: " + str(e))
+        shots = int(params.get("shots", 1024))
+        transpiled = transpile(qc, simulator)
+        qobj = assemble(transpiled, backend=simulator, shots=shots)
+        job = simulator.run(qobj)
+        result = job.result()
+        counts = result.get_counts()
+        (artifacts_dir / "counts.json").write_text(json.dumps(counts))
+        return {"counts": counts, "backend": "aer_simulator"}
+
+    def _run_python_script(self, script_text: str, params: dict, artifacts_dir: Path):
+        tf = artifacts_dir / "circuit_ibm.py"
+        tf.write_text(script_text)
+        env = os.environ.copy()
+        env.update({k: str(v) for k, v in (params or {}).items()})
+        proc = subprocess.run(["python3", str(tf)], capture_output=True, text=True, env=env, timeout=1800)
+        out = proc.stdout.strip()
+        if out:
+            try:
+                return json.loads(out)
+            except Exception:
+                pass
+        resf = artifacts_dir / "result.json"
+        if resf.exists():
+            return json.loads(resf.read_text())
+        return {"stdout": proc.stdout, "stderr": proc.stderr, "returncode": proc.returncode}
+
+    def _run_on_ibm_runtime(self, script_text: str, params: dict, artifacts_dir: Path):
+        # Write script to file and run inside a session that has IBM token available via env
+        if not IBMRuntimeService:
+            raise RuntimeError("qiskit-ibm-runtime not installed")
+        # Create runtime service using token (if instance provided, include url)
+        if self.ibm_instance:
+            service = IBMRuntimeService(instance=self.ibm_instance, token=self.ibm_token)
+        else:
+            # default cloud
+            service = IBMRuntimeService(token=self.ibm_token)
+        # For this scaffold we'll run the script locally but in production you'd submit via runtime sessions/tasks
+        # Users should implement runtime submission in the script itself using qiskit-ibm-runtime APIs.
+        return self._run_python_script(script_text, params, artifacts_dir)
+
+    def run(self, circuit: str, params: dict, artifacts_dir):
+        artifacts_dir = Path(artifacts_dir)
+        artifacts_dir.mkdir(parents=True, exist_ok=True)
+        # Heuristic: treat as python script if it contains 'import qiskit' or 'def ' etc.
+        if "import qiskit" in circuit or "def " in circuit or "if __name__" in circuit:
+            # prefer IBM runtime if configured
+            if self.use_ibm:
+                try:
+                    return self._run_on_ibm_runtime(circuit, params, artifacts_dir)
+                except Exception as e:
+                    # fallback to local execution
+                    pass
+            return self._run_python_script(circuit, params, artifacts_dir)
+
+        # otherwise, attempt to run as QASM via local Aer simulator
+        return self._run_local_qasm(circuit, params, artifacts_dir)
+
*** End Patch
*** Begin Patch
*** Add File: docker/qiskit/Dockerfile
+FROM python:3.10-slim
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt-get update && apt-get install -y git build-essential && rm -rf /var/lib/apt/lists/*
+RUN pip install --no-cache-dir qiskit==0.39.0 qiskit-ibm-runtime mlflow requests
+WORKDIR /workspace
+COPY services/quantum_controller/adapters/ibm_adapter.py /workspace/ibm_adapter.py
+COPY examples/qiskit /workspace/examples
+CMD ["bash"]
+
*** End Patch
*** Begin Patch
*** Add File: k8s/simulator/qiskit-simulator-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: qiskit-simulator
+  namespace: staging
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: qiskit-simulator
+  template:
+    metadata:
+      labels:
+        app: qiskit-simulator
+    spec:
+      containers:
+      - name: qiskit-sim
+        image: ghcr.io/yourorg/qiskit-simulator:latest
+        env:
+        - name: MLFLOW_TRACKING_URI
+          value: "http://mlflow.staging.svc.cluster.local:5000"
+        - name: REDIS_URL
+          value: "redis://redis.staging.svc.cluster.local:6379/0"
+        - name: DB_PATH
+          value: "/data/quantum_jobs.db"
+        volumeMounts:
+        - name: data
+          mountPath: /data
+      volumes:
+      - name: data
+        emptyDir: {}
+
*** End Patch
*** Begin Patch
*** Add File: quantum/argo/ibmq_workflow.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Workflow
+metadata:
+  name: ibmq-hybrid-workflow
+  namespace: staging
+spec:
+  entrypoint: submit-and-wait-ibmq
+  templates:
+  - name: submit-and-wait-ibmq
+    steps:
+    - - name: submit
+        template: submit-job
+      - name: wait
+        template: wait-for-completion
+
+  - name: submit-job
+    script:
+      image: curlimages/curl:latest
+      command: [sh]
+      source: |
+        set -eux
+        CONTROLLER=${CONTROLLER:-http://quantum-controller.staging.svc.cluster.local:8080}
+        CIRCUIT=$(cat /workspace/sample_qiskit_script.py | jq -Rs .)
+        PAYLOAD="{\"name\":\"ibmq-argo-job\",\"backend\":\"ibm\",\"circuit\":$CIRCUIT}"
+        resp=$(curl -s -X POST "$CONTROLLER/jobs" -H "Content-Type: application/json" -d "$PAYLOAD")
+        echo "$resp" > /tmp/job.json
+        cat /tmp/job.json
+        jq -r .id /tmp/job.json > /tmp/jobid
+        echo "JOBID=$(cat /tmp/jobid)" >> /tmp/outputs
+      outputs:
+        parameters:
+        - name: jobid
+          valueFrom:
+            path: /tmp/jobid
+
+  - name: wait-for-completion
+    inputs:
+      parameters:
+      - name: jobid
+    script:
+      image: curlimages/curl:latest
+      command: [sh]
+      source: |
+        set -eux
+        CONTROLLER=${CONTROLLER:-http://quantum-controller.staging.svc.cluster.local:8080}
+        JOBID="{{inputs.parameters.jobid}}"
+        for i in $(seq 1 1200); do
+          resp=$(curl -s "$CONTROLLER/jobs/$JOBID")
+          status=$(echo "$resp" | jq -r .status)
+          echo "Status: $status"
+          if [ "$status" = "succeeded" ]; then
+            echo "$resp" | jq .result > /tmp/result.json
+            cat /tmp/result.json
+            exit 0
+          fi
+          if [ "$status" = "failed" ]; then
+            echo "Job failed: $resp"
+            exit 2
+          fi
+          sleep 10
+        done
+        echo "Timeout waiting for job" && exit 3
+
*** End Patch
*** Begin Patch
*** Add File: examples/qiskit/sample_qiskit_script.py
+#!/usr/bin/env python3
+"""
+Sample Qiskit script for IBMQ/Simulator runs.
+This script builds a simple circuit, runs it (locally or via IBM runtime if env variables present),
+and prints a JSON result to stdout.
+"""
+import os
+import json
+
+def build_and_run(params, output_path):
+    try:
+        from qiskit import QuantumCircuit, transpile, Aer, assemble
+        # simple Bell state
+        qc = QuantumCircuit(2, 2)
+        qc.h(0)
+        qc.cx(0,1)
+        qc.measure([0,1],[0,1])
+        shots = int(params.get("shots", 1024))
+        if os.environ.get("IBM_API_TOKEN") and os.environ.get("IBM_INSTANCE"):
+            # In production: implement IBM runtime submission here using qiskit-ibm-runtime API.
+            # For this sample we fallback to local simulator even if IBM env exists.
+            pass
+        simulator = Aer.get_backend('aer_simulator')
+        transpiled = transpile(qc, simulator)
+        qobj = assemble(transpiled, backend=simulator, shots=shots)
+        job = simulator.run(qobj)
+        result = job.result()
+        counts = result.get_counts()
+        out = {"counts": counts}
+        print(json.dumps(out))
+    except Exception as e:
+        print(json.dumps({"error": str(e)}))
+
+if __name__ == "__main__":
+    params = {}
+    build_and_run(params, "/tmp")
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_ibmq_submit.yml
+name: CI: IBMQ job submit (simulator + optional IBM Quantum)
+on:
+  workflow_dispatch:
+    inputs:
+      mode:
+        description: 'submit-mode (simulator|ibm)'
+        required: false
+        default: simulator
+
+permissions:
+  contents: read
+  id-token: write
+
+jobs:
+  submit-ibmq:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.10'
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install qiskit==0.39.0 qiskit-ibm-runtime mlflow requests
+      - name: Run sample Qiskit script (local simulator)
+        if: ${{ github.event.inputs.mode == 'simulator' }}
+        run: |
+          python3 examples/qiskit/sample_qiskit_script.py
+      - name: Configure IBM Quantum credentials (optional)
+        if: ${{ github.event.inputs.mode == 'ibm' }}
+        run: |
+          # Option 1: use IBM_API_TOKEN secret (recommended). This example writes it to env var for the job.
+          echo "IBM_API_TOKEN=${{ secrets.IBM_API_TOKEN }}" >> $GITHUB_ENV
+          echo "IBM_INSTANCE=${{ secrets.IBM_INSTANCE }}" >> $GITHUB_ENV
+      - name: Run sample Qiskit script on IBM (optional)
+        if: ${{ github.event.inputs.mode == 'ibm' }}
+        run: |
+          python3 examples/qiskit/sample_qiskit_script.py
+
*** End Patch
*** Begin Patch
*** Add File: scripts/ibm/setup_ibm_credentials.sh
+#!/usr/bin/env bash
+set -euo pipefail
+#
+# Helper: guide to set IBM Quantum credentials into GitHub secrets or local env
+#
+if [ -z "${1:-}" ]; then
+  echo "Usage: $0 <ibm_api_token> [ibm_instance_url]"
+  exit 2
+fi
+IBM_API_TOKEN="$1"
+IBM_INSTANCE="${2:-https://auth.quantum-computing.ibm.com/api}"
+
+echo "Set these as GitHub secrets in your repo:"
+echo "  IBM_API_TOKEN -> ${IBM_API_TOKEN}"
+echo "  IBM_INSTANCE  -> ${IBM_INSTANCE}"
+echo
+echo "Locally you can export:"
+echo "  export IBM_API_TOKEN='${IBM_API_TOKEN}'"
+echo "  export IBM_INSTANCE='${IBM_INSTANCE}'"
+
*** End Patch
*** Begin Patch
*** Add File: services/quantum_controller/README_IBMQ.md
+# IBM Quantum (Qiskit) Adapter
+
+What this adds
+- A worker adapter (services/quantum_controller/adapters/ibm_adapter.py) that runs circuits via:
+  - Local Qiskit Aer simulator (default/fallback)
+  - IBM Quantum Runtime (if `IBM_API_TOKEN` and optional `IBM_INSTANCE` are provided)
+- Docker image to build (docker/qiskit/Dockerfile) that contains qiskit + qiskit-ibm-runtime
+- K8s deployment for simulator farm and Argo workflow example (quantum/argo/ibmq_workflow.yaml)
+- CI workflow to run sample Qiskit script locally or (optionally) using IBM credentials.
+- Example script: examples/qiskit/sample_qiskit_script.py
+- Helper: scripts/ibm/setup_ibm_credentials.sh
+
+Notes & next steps
+- To use real IBM Quantum backends, provision an IBM Quantum API token and optionally an IBM instance URL (for IBM Cloud integrations).
+- For production use:
+  - Ensure workers run in a secure environment and that IBM tokens are provided via Vault or GitHub Secrets.
+  - Implement result persistence to S3/GCS and robust retry/backoff logic for remote runs.
+  - Sign circuit snapshots and record provenance to Rekor (reuse services/quantum_controller/rekor_sign.py).
+
*** End Patch
*** End Patch
