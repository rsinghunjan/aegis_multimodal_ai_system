*** Begin Patch
*** Add File: services/quantum_controller/adapters/cirq_adapter.py
+"""
+Cirq adapter for Aegis Quantum Job Controller.
+ - Supports local simulation using Cirq (and qsimcirq if available).
+ - Supports Google Quantum Engine (via cirq-google) when GCP credentials are provided.
+ - Expects `circuit` as either:
+     * a Python script text that defines a `build_and_run(params, output_path)` function, or
+     * an OpenQASM string (will attempt to parse via cirq.contrib.qasm_import).
+ - Writes artifacts (counts/result JSON) into `artifacts_dir` and returns a JSON-able dict.
+
+This is a pragmatic scaffold: you can extend the execution model and sandboxing
+to meet your production security posture.
+"""
+import os
+import time
+import json
+import tempfile
+import subprocess
+from pathlib import Path
+
+try:
+    import cirq
+    from cirq.contrib.qasm_import import circuit_from_qasm
+except Exception:
+    cirq = None
+    circuit_from_qasm = None
+
+try:
+    import cirq_google
+except Exception:
+    cirq_google = None
+
+
+class CirqAdapter:
+    def __init__(self):
+        # detect engine config via env
+        self.gcp_project = os.environ.get("GCP_PROJECT")
+        self.engine_use = bool(self.gcp_project and (os.environ.get("CIRQ_USE_ENGINE") or os.environ.get("ENGINE_SA_KEY_PATH")))
+
+    def _run_local_python_script(self, script_text: str, params: dict, artifacts_dir: Path):
+        # write script to temp file and execute in subprocess
+        tf = artifacts_dir / "circuit_script.py"
+        tf.write_text(script_text)
+        # call Python to run script which should emit JSON to stdout or write to artifacts_dir/result.json
+        env = os.environ.copy()
+        env.update({k: str(v) for k, v in (params or {}).items()})
+        proc = subprocess.run(["python3", str(tf)], capture_output=True, text=True, env=env, timeout=600)
+        out = proc.stdout.strip()
+        # try load JSON from stdout or result file
+        if out:
+            try:
+                return json.loads(out)
+            except Exception:
+                pass
+        # fallback to result file
+        resf = artifacts_dir / "result.json"
+        if resf.exists():
+            return json.loads(resf.read_text())
+        return {"stdout": proc.stdout, "stderr": proc.stderr, "returncode": proc.returncode}
+
+    def _run_qasm_via_cirq(self, qasm: str, params: dict, artifacts_dir: Path):
+        if not circuit_from_qasm or not cirq:
+            raise RuntimeError("Cirq or QASM import not available in this environment")
+        qc = circuit_from_qasm(qasm)
+        simulator = cirq.Simulator()
+        shots = int(params.get("shots", 1024))
+        result = simulator.run(qc, repetitions=shots)
+        counts = {}
+        # produce counts in a deterministic way
+        for r in result.measurements.values():
+            # r is array shape (shots, bits)
+            # For simplicity convert each shot to bitstring of first measurement key
+            pass
+        # Simpler: use numpy to count bitstrings from a single named measurement if present
+        try:
+            import numpy as _np
+            # concatenate all measurements columns to bitstrings per shot
+            keys = list(result.measurements.keys())
+            matrix = _np.hstack([result.measurements[k] for k in keys])
+            for row in matrix:
+                b = "".join(str(int(x)) for x in row.tolist())
+                counts[b] = counts.get(b, 0) + 1
+        except Exception:
+            counts = {"shots": shots}
+        out = {"counts": counts}
+        (artifacts_dir / "counts.json").write_text(json.dumps(counts))
+        return out
+
+    def _run_on_engine(self, script_text: str, params: dict, artifacts_dir: Path):
+        # Use cirq_google.Engine (API varies by cirq version). This is a light scaffold.
+        if not cirq_google:
+            raise RuntimeError("cirq_google not installed")
+        # write script to a temp file and run it under a subprocess that has GOOGLE_APPLICATION_CREDENTIALS set
+        tf = artifacts_dir / "circuit_engine.py"
+        tf.write_text(script_text)
+        env = os.environ.copy()
+        proc = subprocess.run(["python3", str(tf)], capture_output=True, text=True, env=env, timeout=1800)
+        out = proc.stdout.strip()
+        if out:
+            try:
+                return json.loads(out)
+            except Exception:
+                pass
+        resf = artifacts_dir / "result.json"
+        if resf.exists():
+            return json.loads(resf.read_text())
+        return {"stdout": proc.stdout, "stderr": proc.stderr, "returncode": proc.returncode}
+
+    def run(self, circuit: str, params: dict, artifacts_dir):
+        artifacts_dir = Path(artifacts_dir)
+        artifacts_dir.mkdir(parents=True, exist_ok=True)
+        # Heuristic: if circuit looks like a Python script (imports or def), run as Python
+        if "import cirq" in circuit or "def " in circuit or "if __name__" in circuit:
+            # If engine is configured, attempt engine run first
+            if self.engine_use:
+                try:
+                    return self._run_on_engine(circuit, params, artifacts_dir)
+                except Exception as e:
+                    # fallback to local script execution
+                    pass
+            return self._run_local_python_script(circuit, params, artifacts_dir)
+
+        # Otherwise, try interpreting as OpenQASM
+        if ("OPENQASM" in circuit.upper() or "qasm" in circuit.lower()) and circuit_from_qasm:
+            return self._run_qasm_via_cirq(circuit, params, artifacts_dir)
+
+        # Last resort: write the circuit to a file and attempt local execution as Python
+        return self._run_local_python_script(circuit, params, artifacts_dir)
+
*** End Patch
*** Begin Patch
*** Add File: docker/cirq-simulator/Dockerfile
+FROM python:3.10-slim
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt-get update && apt-get install -y build-essential git curl && rm -rf /var/lib/apt/lists/*
+RUN pip install --no-cache-dir cirq==0.16.0 qsimcirq mlflow requests
+WORKDIR /workspace
+COPY services/quantum_controller/adapters/cirq_adapter.py /workspace/cirq_adapter.py
+COPY examples/cirq /workspace/examples
+CMD ["bash"]
+
*** End Patch
*** Begin Patch
*** Add File: k8s/simulator/cirq-simulator-deployment.yaml
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: cirq-simulator
+  namespace: staging
+spec:
+  replicas: 2
+  selector:
+    matchLabels:
+      app: cirq-simulator
+  template:
+    metadata:
+      labels:
+        app: cirq-simulator
+    spec:
+      containers:
+      - name: cirq-sim
+        image: ghcr.io/yourorg/cirq-simulator:latest
+        env:
+        - name: MLFLOW_TRACKING_URI
+          value: "http://mlflow.staging.svc.cluster.local:5000"
+        - name: REDIS_URL
+          value: "redis://redis.staging.svc.cluster.local:6379/0"
+        - name: DB_PATH
+          value: "/data/quantum_jobs.db"
+        volumeMounts:
+        - name: data
+          mountPath: /data
+      volumes:
+      - name: data
+        emptyDir: {}
+
*** End Patch
*** Begin Patch
*** Add File: quantum/argo/cirq_workflow.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: Workflow
+metadata:
+  name: cirq-hybrid-workflow
+  namespace: staging
+spec:
+  entrypoint: submit-and-wait-cirq
+  templates:
+  - name: submit-and-wait-cirq
+    steps:
+    - - name: submit
+        template: submit-job
+      - name: wait
+        template: wait-for-completion
+
+  - name: submit-job
+    script:
+      image: curlimages/curl:latest
+      command: [sh]
+      source: |
+        set -eux
+        CONTROLLER=${CONTROLLER:-http://quantum-controller.staging.svc.cluster.local:8080}
+        CIRCUIT=$(cat /workspace/sample_circuit.py | jq -Rs .)
+        PAYLOAD="{\"name\":\"cirq-argo-job\",\"backend\":\"simulator\",\"circuit\":$CIRCUIT}"
+        resp=$(curl -s -X POST "$CONTROLLER/jobs" -H "Content-Type: application/json" -d "$PAYLOAD")
+        echo "$resp" > /tmp/job.json
+        cat /tmp/job.json
+        jq -r .id /tmp/job.json > /tmp/jobid
+        echo "JOBID=$(cat /tmp/jobid)" >> /tmp/outputs
+      outputs:
+        parameters:
+        - name: jobid
+          valueFrom:
+            path: /tmp/jobid
+
+  - name: wait-for-completion
+    inputs:
+      parameters:
+      - name: jobid
+    script:
+      image: curlimages/curl:latest
+      command: [sh]
+      source: |
+        set -eux
+        CONTROLLER=${CONTROLLER:-http://quantum-controller.staging.svc.cluster.local:8080}
+        JOBID="{{inputs.parameters.jobid}}"
+        for i in $(seq 1 600); do
+          resp=$(curl -s "$CONTROLLER/jobs/$JOBID")
+          status=$(echo "$resp" | jq -r .status)
+          echo "Status: $status"
+          if [ "$status" = "succeeded" ]; then
+            echo "$resp" | jq .result > /tmp/result.json
+            cat /tmp/result.json
+            exit 0
+          fi
+          if [ "$status" = "failed" ]; then
+            echo "Job failed: $resp"
+            exit 2
+          fi
+          sleep 5
+        done
+        echo "Timeout waiting for job" && exit 3
+
*** End Patch
*** Begin Patch
*** Add File: examples/cirq/sample_circuit.py
+#!/usr/bin/env python3
+"""
+Sample Cirq circuit script used by the Cirq adapter.
+This script is intentionally simple: it builds a small circuit, simulates it, and prints JSON to stdout.
+In production you'd implement a `build_and_run` function with proper parameter handling and artifact upload.
+"""
+import cirq
+import json
+import sys
+
+def build_and_run(params, output_path):
+    qubits = [cirq.GridQubit(0, i) for i in range(2)]
+    circuit = cirq.Circuit(
+        cirq.H(qubits[0]),
+        cirq.CNOT(qubits[0], qubits[1]),
+        cirq.measure(*qubits, key='m')
+    )
+    simulator = cirq.Simulator()
+    shots = int(params.get("shots", 1024))
+    result = simulator.run(circuit, repetitions=shots)
+    # convert to counts
+    counts = {}
+    for r in result.measurements['m']:
+        b = "".join(str(int(x)) for x in r.tolist())
+        counts[b] = counts.get(b, 0) + 1
+    out = {"counts": counts}
+    print(json.dumps(out))
+
+if __name__ == "__main__":
+    # read params from env or defaults
+    params = {}
+    build_and_run(params, "/tmp")
+
*** End Patch
*** Begin Patch
*** Add File: .github/workflows/ci_cirq_submit.yml
+name: CI: Cirq job submit (simulator + optional Google Engine)
+on:
+  workflow_dispatch:
+    inputs:
+      mode:
+        description: 'submit-mode (simulator|engine)'
+        required: false
+        default: simulator
+
+permissions:
+  contents: read
+  id-token: write
+
+jobs:
+  submit-cirq:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.10'
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install cirq==0.16.0 pennylane mlflow requests
+      - name: Run sample Cirq script (local simulator)
+        if: ${{ github.event.inputs.mode == 'simulator' }}
+        run: |
+          python3 examples/cirq/sample_circuit.py
+      - name: Authenticate to GCP (optional)
+        if: ${{ github.event.inputs.mode == 'engine' }}
+        uses: google-github-actions/auth@v1
+        with:
+          # configure a workload identity or use a service account key stored in secrets
+          workload_identity_provider: ${{ secrets.GCP_WOID_PROVIDER }}
+          service_account: ${{ secrets.GCP_SA_EMAIL }}
+      - name: Run Cirq script against Engine (optional)
+        if: ${{ github.event.inputs.mode == 'engine' }}
+        env:
+          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
+          BRAKET_DEVICE_ARN: ${{ secrets.BRAKET_DEVICE_ARN }}
+        run: |
+          python3 examples/cirq/sample_circuit.py
+
*** End Patch
*** Begin Patch
*** Add File: iam/gcp/cirq_iam_snippet.tf
+// Terraform snippet: Example IAM roles & bindings for GCP Quantum Engine usage.
+// Replace placeholders and attach the policy to the CI service account or GKE Workload Identity.
+resource "google_project_iam_member" "quantum_service_account" {
+  project = var.gcp_project
+  role    = "roles/iam.serviceAccountUser"
+  member  = "serviceAccount:${var.quantum_service_account_email}"
+}
+
+// Storage access for result artifacts
+resource "google_project_iam_member" "quantum_sa_storage" {
+  project = var.gcp_project
+  role    = "roles/storage.objectAdmin"
+  member  = "serviceAccount:${var.quantum_service_account_email}"
+}
+
*** End Patch
*** Begin Patch
*** Add File: services/quantum_controller/README_CIRQ.md
+# Cirq Integration for Aegis Quantum Orchestration
+
+This directory adds Cirq support to the Aegis Quantum Job Controller:
+- services/quantum_controller/adapters/cirq_adapter.py : adapter supporting local Cirq simulation and Google Engine execution.
+- docker/cirq-simulator/Dockerfile : container image with Cirq + qsimcirq for simulator farm.
+- k8s/simulator/cirq-simulator-deployment.yaml : simulator deployment manifest.
+- quantum/argo/cirq_workflow.yaml : Argo workflow to submit a Cirq job to the controller and wait for completion.
+- examples/cirq/sample_circuit.py : simple Cirq circuit example that prints JSON counts.
+- .github/workflows/ci_cirq_submit.yml : CI dispatchable workflow to run sample circuit locally or (optionally) via Google Engine.
+- iam/gcp/cirq_iam_snippet.tf : example IAM snippet for GCP resources.
+
+Quickstart (local):
+1. Start Redis and the Quantum Controller (see services/quantum_controller/README_QUANTUM.md).
+2. Start a worker that includes the cirq adapter (ensure cirq is installed).
+3. Submit the sample circuit using the controller or run the Argo workflow on a cluster with the controller service accessible.
+
+Notes:
+- Google Engine support requires cirq_google / cirq-google and appropriate GCP credentials; the adapter will fall back to local execution if Engine is not configured.
+- Harden execution of arbitrary Python circuit scripts before allowing untrusted inputs (sandboxing, policy enforcement).
+
*** End Patch
*** End Patch
