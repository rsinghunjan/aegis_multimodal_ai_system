*** Begin Patch
*** Add File:ops/carbon/job_wrapper_improved.py
+#!/usr/bin/env python3
+"""
+Improved job wrapper for precise per-job attribution.
+ - Records start/end timestamps, team, workload, release_id, region, instance_type and node name.
+ - Emits Pushgateway metrics if configured.
+ - Writes job metadata and annotation files consumed by emissions calculator v2.
+ Usage:
+   python ops/carbon/job_wrapper_improved.py --job-id=bench-123 --team=rl --workload=train --release myrel-1 --instance g4dn.xlarge --region us-west-2 -- \
+       python train.py --epochs 10
+"""
+import os
+import sys
+import json
+import time
+import argparse
+import subprocess
+from datetime import datetime
+
+OUT_DIR = os.environ.get("AEGIS_JOB_DIR", "/tmp/aegis_jobs")
+PUSHGATEWAY = os.environ.get("PUSHGATEWAY_URL", "")
+NODE_NAME = os.environ.get("NODE_NAME", os.environ.get("HOSTNAME", "localnode"))
+
+def push_metric(job_id, metric, value):
+    if not PUSHGATEWAY:
+        return
+    payload = f'# TYPE {metric} gauge\n{metric}{{job="{job_id}"}} {value}\n'
+    try:
+        subprocess.check_call(["curl","-sS","-X","POST","--data-binary","@-", f"{PUSHGATEWAY}/metrics/job/{job_id}"], input=payload.encode(), stdout=subprocess.DEVNULL)
+    except Exception:
+        pass
+
+def main():
+    p = argparse.ArgumentParser()
+    p.add_argument("--job-id", required=True)
+    p.add_argument("--team", default="unknown")
+    p.add_argument("--workload", default="batch")
+    p.add_argument("--namespace", default="aegis-retriever")
+    p.add_argument("--release", default=None)
+    p.add_argument("--instance", default=None)
+    p.add_argument("--region", default=None)
+    p.add_argument("cmd", nargs=argparse.REMAINDER)
+    args = p.parse_args()
+
+    job_id = args.job_id
+    os.makedirs(OUT_DIR, exist_ok=True)
+    meta = {
+        "job_id": job_id,
+        "team": args.team,
+        "workload": args.workload,
+        "namespace": args.namespace,
+        "cmd": args.cmd,
+        "release_id": args.release,
+        "instance_type": args.instance,
+        "region": args.region,
+        "node": NODE_NAME,
+        "start_ts": datetime.utcnow().isoformat()+"Z"
+    }
+    meta_path = os.path.join(OUT_DIR, f"{job_id}.json")
+    with open(meta_path, "w") as fh:
+        json.dump(meta, fh)
+    push_metric(job_id, "aegis_job_start_ts", int(time.time()))
+
+    try:
+        rc = subprocess.call(args.cmd)
+    except Exception:
+        rc = 1
+    meta["end_ts"] = datetime.utcnow().isoformat()+"Z"
+    meta["exit_code"] = rc
+    with open(meta_path, "w") as fh:
+        json.dump(meta, fh)
+    push_metric(job_id, "aegis_job_end_ts", int(time.time()))
+
+    # Annotation for emissions calculator v2
+    ann = {
+        "job_id": job_id,
+        "namespace": args.namespace,
+        "pod_label_selector": f'job="{job_id}"',
+        "region": args.region,
+        "node": NODE_NAME
+    }
+    ann_path = os.path.join(OUT_DIR, f"{job_id}.annot.json")
+    with open(ann_path, "w") as fh:
+        json.dump(ann, fh)
+    sys.exit(rc)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:k8s/daemonsets/node_power_exporter_daemonset.yaml
+apiVersion: apps/v1
+kind: DaemonSet
+metadata:
+  name: node-power-exporter
+  namespace: aegis-retriever
+  labels:
+    app: node-power-exporter
+spec:
+  selector:
+    matchLabels:
+      app: node-power-exporter
+  template:
+    metadata:
+      labels:
+        app: node-power-exporter
+    spec:
+      hostPID: true
+      tolerations:
+        - operator: "Exists"
+      containers:
+        - name: node-power-exporter
+          image: aegis/node-power-exporter:latest
+          imagePullPolicy: IfNotPresent
+          env:
+            - name: NODE_POWER_INTERVAL_S
+              value: "15"
+            - name: NODE_POWER_DIR
+              value: "/var/lib/aegis/node_power"
+          volumeMounts:
+            - name: lib
+              mountPath: /var/lib/aegis
+      volumes:
+        - name: lib
+          hostPath:
+            path: /var/lib/aegis
+            type: DirectoryOrCreate
+
*** End Patch
*** Begin Patch
*** Add File:ops/carbon/region_mapping.py
+#!/usr/bin/env python3
+"""
+Map Kubernetes node / job metadata to electricityMap zones or region identifiers.
+ - Uses k8s API to inspect node labels (e.g., topology.kubernetes.io/region) and returns a zone string
+ - Provides get_zone_for_job(job_meta) to be used by emissions pipeline
+"""
+import os
+try:
+    from kubernetes import client, config
+except Exception:
+    client = None
+
+def _load_k8s():
+    if not client:
+        return None
+    try:
+        config.load_incluster_config()
+    except Exception:
+        config.load_kube_config()
+    return client.CoreV1Api()
+
+def get_zone_for_node(node_name):
+    api = _load_k8s()
+    if not api:
+        return None
+    try:
+        n = api.read_node(node_name)
+        labels = n.metadata.labels or {}
+        # common label keys
+        for key in ("topology.kubernetes.io/region", "failure-domain.beta.kubernetes.io/region", "region"):
+            if key in labels:
+                return labels[key]
+        # fallback to provider-specific
+        return labels.get("cloud.google.com/region") or labels.get("failure-domain.beta.kubernetes.io/zone")
+    except Exception:
+        return None
+
+def get_zone_for_job(job_meta):
+    # job_meta may include region or node
+    if not job_meta:
+        return None
+    if job_meta.get("region"):
+        return job_meta["region"]
+    node = job_meta.get("node")
+    if node:
+        zone = get_zone_for_node(node)
+        return zone
+    return None
+
+if __name__ == "__main__":
+    import sys
+    print(get_zone_for_node(sys.argv[1]) if len(sys.argv)>1 else "usage: node")
+
*** End Patch
*** Begin Patch
*** Add File:k8s/argo/workflow-templates/carbon-aware-submit-workflow.yaml
+apiVersion: argoproj.io/v1alpha1
+kind: WorkflowTemplate
+metadata:
+  name: carbon-aware-submit
+  namespace: aegis-retriever
+spec:
+  entrypoint: submit
+  templates:
+    - name: submit
+      inputs:
+        parameters:
+          - name: manifest-path
+          - name: max-intensity
+          - name: defer-minutes
+      container:
+        image: aegis/carbon-tools:latest
+        command: ["/bin/sh", "-c"]
+        args:
+          - |
+            python /opt/carbon/submit_job_carbon_aware.py --manifest {{inputs.parameters.manifest-path}} --max-intensity {{inputs.parameters.max-intensity}} --defer-minutes {{inputs.parameters.defer-minutes}} --auto-opt
+
*** End Patch
*** Begin Patch
*** Add File:ops/carbon/budget_sql.py
+#!/usr/bin/env python3
+"""
+SQLite-based carbon budget manager for stronger consistency.
+ - DB schema: teams (team TEXT PRIMARY KEY, budget REAL), consumption (id INTEGER PK, team, kg, job_id, ts)
+ - File path default: /var/lib/aegis/carbon_budget.db
+"""
+import os
+import sqlite3
+from datetime import datetime
+
+DB = os.environ.get("CARBON_BUDGET_DB", "/var/lib/aegis/carbon_budget.db")
+
+def _conn():
+    os.makedirs(os.path.dirname(DB), exist_ok=True)
+    c = sqlite3.connect(DB, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)
+    return c
+
+def init():
+    c = _conn()
+    cur = c.cursor()
+    cur.execute("CREATE TABLE IF NOT EXISTS teams(team TEXT PRIMARY KEY, budget REAL)")
+    cur.execute("CREATE TABLE IF NOT EXISTS consumption(id INTEGER PRIMARY KEY AUTOINCREMENT, team TEXT, kg REAL, job_id TEXT, ts TEXT)")
+    c.commit()
+    c.close()
+
+def set_team_budget(team, monthly_kg):
+    c = _conn()
+    cur = c.cursor()
+    cur.execute("INSERT OR REPLACE INTO teams(team,budget) VALUES (?,?)", (team, monthly_kg))
+    c.commit()
+    c.close()
+
+def record_consumption(team, kg, job_id):
+    c = _conn()
+    cur = c.cursor()
+    cur.execute("INSERT INTO consumption(team,kg,job_id,ts) VALUES (?,?,?,?)", (team, kg, job_id, datetime.utcnow().isoformat()+"Z"))
+    c.commit()
+    c.close()
+
+def team_consumption_month(team, year_month):
+    # year_month as 'YYYY-MM'
+    c = _conn()
+    cur = c.cursor()
+    cur.execute("SELECT SUM(kg) FROM consumption WHERE team=? AND substr(ts,1,7)=?", (team, year_month))
+    r = cur.fetchone()[0] or 0.0
+    c.close()
+    return r
+
+def check_budget(team, kg):
+    c = _conn()
+    cur = c.cursor()
+    cur.execute("SELECT budget FROM teams WHERE team=?", (team,))
+    row = cur.fetchone()
+    if not row:
+        return False, {"reason":"team_missing"}
+    allowed = row[0]
+    month = datetime.utcnow().strftime("%Y-%m")
+    consumed = team_consumption_month(team, month)
+    return (consumed + kg) <= allowed, {"consumed": consumed, "allowed": allowed}
+
+if __name__ == "__main__":
+    init()
+    set_team_budget("rl", 100.0)
+    print(check_budget("rl", 1.0))
+
*** End Patch
*** Begin Patch
*** Add File:ops/carbon/audit_packager.py
+#!/usr/bin/env python3
+"""
+Assemble an auditable carbon package for third-party review:
+ - Collects calibration DB, validation report, methodology docs and sample carbon reports for a release
+ - Writes a zip archive ready for upload
+"""
+import os
+import json
+import zipfile
+from datetime import datetime
+
+OUT_DIR = os.environ.get("CARBON_RELEASE_REPORTS", "/tmp/release_reports")
+CALIB = os.environ.get("CARBON_CALIB_PATH", "/etc/aegis/carbon_calibration.json")
+VALID = os.environ.get("CARBON_VALIDATION_PATH", "/tmp/carbon_validation.json")
+METH = os.environ.get("CARBON_METHOD_DOC", "docs/carbon_methodology.md")
+ARCHIVE_DIR = os.environ.get("CARBON_ARCHIVE", "/tmp/carbon_reports_archive")
+
+def package(release_id):
+    os.makedirs(OUT_DIR, exist_ok=True)
+    out = os.path.join(OUT_DIR, f"carbon_audit_{release_id}.zip")
+    with zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as z:
+        if os.path.exists(CALIB):
+            z.write(CALIB, arcname="calibration.json")
+        if os.path.exists(VALID):
+            z.write(VALID, arcname="validation.json")
+        if os.path.exists(METH):
+            z.write(METH, arcname="methodology.md")
+        # include sample per-release carbon reports
+        for fn in os.listdir(ARCHIVE_DIR) if os.path.exists(ARCHIVE_DIR) else []:
+            path = os.path.join(ARCHIVE_DIR, fn)
+            if fn.endswith(".json"):
+                z.write(path, arcname=f"reports/{fn}")
+    print("Wrote audit package", out)
+    return out
+
+if __name__ == "__main__":
+    import sys
+    if len(sys.argv)<2:
+        print("usage: audit_packager.py <release_id>")
+    else:
+        package(sys.argv[1])
+
*** End Patch
*** Begin Patch
*** Add File:ops/edge/device_agent.py
+#!/usr/bin/env python3
+"""
+Simple device agent exposing /v1/power to return instantaneous power draw.
+Intended to run on edge devices, return JSON: { "power_w": 2.3, "ts": "...", "device_id": "..." }
+"""
+from flask import Flask, jsonify
+import os, time
+
+app = Flask(__name__)
+DEVICE_ID = os.environ.get("DEVICE_ID", "edge-unknown")
+
+def measure_power():
+    # Replace with real measurement code per device (ADC, sysfs, etc.)
+    try:
+        # attempt to use a mock or local sensor
+        return float(os.environ.get("MOCK_DEVICE_POWER_W", "2.5"))
+    except Exception:
+        return 0.0
+
+@app.route("/v1/power")
+def power():
+    return jsonify({"device_id": DEVICE_ID, "power_w": measure_power(), "ts": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())})
+
+if __name__ == "__main__":
+    app.run(host="0.0.0.0", port=int(os.environ.get("DEVICE_AGENT_PORT", "8080")))
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/carbon_enforcement.yml
+name: Carbon Enforcement & Validation (PR gate)
+on:
+  pull_request:
+    types: [opened, synchronize, reopened]
+
+jobs:
+  ensure-carbon-report:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - name: Setup Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.11'
+      - name: Install deps
+        run: python -m pip install --upgrade pip && pip install requests boto3
+      - name: Run carbon gate
+        env:
+          CARBON_REPORT_PATH: /tmp/carbon_report.json
+        run: |
+          # expect CI runner to have produced a carbon_report.json for PR shards; otherwise this step warns.
+          python ops/ci/carbon_evidence_gate.py || exit 1
+      - name: Upload audit package (best-effort)
+        run: |
+          python ops/carbon/audit_packager.py "${{ github.event.pull_request.number }}" || true
+
*** End Patch
*** End Patch
