*** Begin Patch
*** Add File:docs/onboarding_ops_soc.md
+Onboarding & SOC/Ops Checklist — Productionize Aegis Safety Pipeline
+===========================================================
+
+Purpose
+-------
+This document maps the runbooks and scaffolds in the repo to concrete commands, CI settings and operator steps required to move Aegis from scaffold → production for AV safety & validation.
+
+Scope
+-----
+Covers:
+ - Deploying telemetry and calibration
+ - Enforcing job instrumentation and reproducible SIL/HIL
+ - Authoring invariants and running prover pipeline
+ - Evidence packaging and signing (AWS KMS / Vault / PEM)
+ - CI/Argo configuration, secrets and scheduled E2E runs
+
+Prerequisites
+-------------
+ - Cluster admin access (kubectl, helm)
+ - CI admin (GitHub repo admin) to set secrets
+ - Z3 installed on prover runner (or container image with z3)
+ - KMS key (AWS) or Vault transit key or PEM private key for signing
+ - HIL access (or HIL runner) for hardware validation
+
+Fast path checklist (operators)
+--------------------------------
+1) Telemetry & Carbon
+  - Deploy node power exporter Helm chart to production clusters:
+    - helm upgrade --install node-power-exporter charts/node-power-exporter -n aegis-retriever --create-namespace
+  - Verify: kubectl get ds -n aegis-retriever -l app=node-power-exporter
+  - Ensure Prometheus scrapes ServiceMonitor and metrics appear at /metrics
+  - Run calibration collection after some jobs produce samples:
+    - python ops/carbon/calibration_collector.py
+  - Confirm CARBON_CALIB_PATH exists and contains instance stats:
+    - cat /etc/aegis/carbon_calibration.json
+
+2) Enforce job wrapper in CI / Argo
+  - Ensure .github/workflows/enforce_job_wrapper.yml is enabled on PRs
+  - Update Argo/CI job templates to call job_wrapper_improved.py for heavy jobs
+  - Command to test locally:
+    - python ops/ci/enforce_job_wrapper.py
+
+3) Reproducible SIL/HIL
+  - Pin images in Argo/Helm manifests: run ops/ci/check_reproducibility.py to check
+    - python ops/ci/check_reproducibility.py --model-dir models/toy-model --tests models/toy-model/tests --seed 42
+  - Ensure SIL runner accepts --seed and prints seed to logs
+  - For HIL: record firmware versions, ECU IDs, and replay inputs to guarantee deterministic test harnesses
+
+4) Invariants & Prover
+  - Deploy example invariants to prover SMT dir:
+    - python ops/formal/deploy_sample_invariants.py
+  - Run prover orchestrator (requires z3 in PATH):
+    - python ops/formal/prover_orchestrator.py
+  - Inspect proof artifacts:
+    - ls /tmp/verifier_logs
+  - Use ops/formal/invariant_authoring_tool.py to add real invariants (domain expert step)
+
+5) Evidence packaging & signing
+  - Provision signing backend (choose one):
+    - AWS KMS: create asymmetric key (Sign) and grant CI role kms:Sign,kms:GetPublicKey
+    - Vault Transit: enable transit engine and create key, grant CI token sign permission
+    - PEM: upload private key to secure store (least preferred)
+  - Set secrets in GitHub:
+    - For AWS KMS: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION, AWS_KMS_KEY_ID
+    - For Vault: VAULT_ADDR, VAULT_TOKEN, VAULT_TRANSIT_KEY
+    - For PEM: EVIDENCE_PRIVATE_KEY (path on runner) or secret containing key
+  - Test signing locally:
+    - EVIDENCE_SIGN_BACKEND=aws AWS_KMS_KEY_ID=... python ops/evidence/sign_with_kms_or_vault.py /tmp/safety_evidence/toy-model_evidence_*.zip
+
+6) Schedule CI & E2E
+  - Enable GitHub Actions workflows:
+    - .github/workflows/safety_e2e_prover.yml (weekly scheduled)
+    - .github/workflows/reasoning_benchmark.yml
+    - .github/workflows/reproducibility_check.yml (PR hook)
+  - For scheduled E2E, ensure runners (self-hosted if required) have Z3 and KMS/Vault access
+
+7) Production rollout policy
+  - Only artifacts in safety registry allowed for safety deployments
+  - Safety deployments must include monitor_agent sidecar and invariants.json
+  - Safety Controller must be reachable by monitor_agent (SAFETY_CONTROLLER_URL)
+  - Define canary → limited → full rollout with checklists and manual approver gates
+
+Operational SOC checklist (incident & audit)
+------------------------------------------
+On safety violation (monitor_agent alert):
+ - Step 1: Safety Controller may quiesce deployment automatically (check logs)
+   - kubectl get deployment -n aegis-retriever model-serving-<model>
+ - Step 2: Triage: gather evidence bundle and verifier/prover logs
+   - ls /tmp/safety_evidence; ls /tmp/verifier_logs
+ - Step 3: Create incident ticket, attach evidence, notify Safety Owner & Incident Commander
+ - Step 4: If rollback required, follow staged rollback steps and record actions in incident log
+
+Audit readiness
+---------------
+ - Evidence bundle must include:
+   - provenance.json (git_commit, builder image digests)
+   - metadata.json (owner, approver, dataset_snapshot, tests)
+   - verification.json (NLI/CAS outputs)
+   - proof_certificate.json (if proofs obtained)
+   - SIL/HIL logs and scenario definitions
+   - signature (.sig) and public key (.pub.pem) when using KMS/PEM
+ - To reproduce: supply artifact, evidence bundle and run instructions in audit ticket. CI should be able to reproduce SIL deterministically using pinned images and seed.
+
+Appendix: Common commands (quick)
+--------------------------------
+ - Run E2E check locally (toy model):
+     python ops/ci/run_end_to_end_safety_check.py --model toy-model
+ - Deploy node-power-exporter:
+     helm upgrade --install node-power-exporter charts/node-power-exporter -n aegis-retriever --create-namespace
+ - Add invariant and run prover:
+     python ops/formal/invariant_authoring_tool.py --id my_inv --expr "speed <= 30" --tactic interval
+     python ops/formal/prover_orchestrator.py
+ - Sign evidence with KMS (CI runner):
+     python ops/evidence/sign_with_kms_or_vault.py /tmp/safety_evidence/<artifact>.zip
+
+End of onboarding & SOC/Ops checklist.
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_examples/control_latency_bound.smt2
+; SMT-LIB: control_latency_bound.smt2
+; Prove: total control latency (sensor + compute + actuator) <= 0.5s under given component bounds
+(set-logic QF_NRA)
+(declare-fun sensor_latency () Real)
+(declare-fun compute_latency () Real)
+(declare-fun actuator_latency () Real)
+(declare-fun total_latency () Real)
+
+; component bounds (domain-specific)
+(assert (<= 0 sensor_latency))
+(assert (<= sensor_latency 0.15))    ; sensor latency <= 150ms
+(assert (<= 0 compute_latency))
+(assert (<= compute_latency 0.2))    ; compute latency <= 200ms
+(assert (<= 0 actuator_latency))
+(assert (<= actuator_latency 0.15))  ; actuator latency <= 150ms
+
+(assert (= total_latency (+ sensor_latency compute_latency actuator_latency)))
+
+; property negation: total_latency > 0.5 (should be unsat)
+(assert (> total_latency 0.5))
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_examples/collision_avoidance_min_distance.smt2
+; SMT-LIB: collision_avoidance_min_distance.smt2
+; Toy model: relative speed and time-to-collision produce stopping distance; guarantee min clearance >= 2m
+(set-logic QF_NRA)
+(declare-fun rel_speed () Real)       ; relative closing speed (m/s)
+(declare-fun time_to_collision () Real)
+(declare-fun stopping_distance () Real)
+(declare-fun min_clearance () Real)
+
+; assumptions
+(assert (<= 0 rel_speed))
+(assert (<= rel_speed 30))            ; up to 30 m/s closing rate
+(assert (<= 0 time_to_collision))
+(assert (<= time_to_collision 10))
+
+; model: stopping_distance approx rel_speed * time_to_collision (toy)
+(assert (= stopping_distance (* rel_speed time_to_collision)))
+(assert (= min_clearance (- time_to_collision stopping_distance)))
+
+; require min_clearance >= 2 -> negation min_clearance < 2
+(assert (< min_clearance 2))
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_examples/braking_accel_linearized.smt2
+; SMT-LIB: braking_accel_linearized.smt2
+; Uses linearization tactic for braking model around operating point
+(set-logic QF_NRA)
+(declare-fun speed () Real)
+(declare-fun decel () Real)           ; deceleration (m/s^2), positive value
+(declare-fun reaction_time () Real)
+(declare-fun stopping_dist () Real)
+
+; assumptions
+(assert (<= 0 speed))
+(assert (<= speed 60))
+(assert (<= 0 decel))
+(assert (<= decel 9.0))               ; decel <= 9 m/s^2 (approx)
+(assert (<= 0 reaction_time))
+(assert (<= reaction_time 2))
+
+; approximate stopping distance ignoring quadratic term via linearization: stopping_dist = speed * reaction_time + 0.5 * speed * (1/decel)
+(assert (= stopping_dist (+ (* speed reaction_time) (* 0.5 speed (/ 1.0 decel)))))
+
+; property to prove: stopping_dist <= 150 (toy)
+(assert (> stopping_dist 150))
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_tactics_readme.md
+SMT Tactics & Guidance (interval / linearization / overapprox)
+------------------------------------------------------------
+
+This short readme describes the tactics referenced in registry entries and how to convert them into SMT encodings or solver tactics.
+
+Tactics:
+ - interval: use interval arithmetic style bounds, assert ranges for variables and check negated property for unsat.
+   - Best for monotonic relations and bounded numeric variables.
+ - linearization: linearize nonlinear relations around operating points; replace quadratic/complex terms with conservative linear bounds.
+   - Use when prover struggles with nonlinear polynomials; conservative linear bounds may be easier to discharge.
+ - overapprox: compute sound overapproximations of sets (e.g., bounding nonlinears) and prove property on overapproximation.
+   - Use for reachability-like properties where exact encoding is expensive.
+
+How to author:
+ 1. Start with domain equations and identify variables with safe bounds.
+ 2. Express the property as `assert (negation)` so Z3 should return unsat when property holds.
+ 3. Add comments explaining units and assumptions to help reviewers.
+ 4. For nonlinear terms, prefer linearization or interval approximations for initial automated proof attempts.
+
+Where to place:
+ - Put SMT files under ops/formal/smt_examples/ and add entries to ops/formal/invariant_registry.json or use invariant_authoring_tool.py to register.
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/evidence_signing_enable.yml
+name: Evidence Packaging and Signing (example)
+on:
+  workflow_dispatch:
+
+jobs:
+  package-and-sign:
+    runs-on: ubuntu-latest
+    env:
+      EVIDENCE_ROOT: /tmp/safety_evidence
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.11'
+      - name: Install deps
+        run: |
+          python -m pip install --upgrade pip
+          pip install boto3 requests cryptography
+      - name: Generate sample evidence (toy)
+        run: |
+          python ops/example/generate_sample_evidence.py --model toy-model --artifact models/toy-model/artifact.txt
+      - name: Sign with chosen backend
+        env:
+          EVIDENCE_SIGN_BACKEND: ${{ secrets.EVIDENCE_SIGN_BACKEND }} # aws|vault|pem|stub
+          AWS_KMS_KEY_ID: ${{ secrets.AWS_KMS_KEY_ID }}
+          AWS_REGION: ${{ secrets.AWS_REGION }}
+          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
+          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
+          VAULT_TRANSIT_KEY: ${{ secrets.VAULT_TRANSIT_KEY }}
+        run: |
+          # pick latest artifact zip
+          ART=$(ls /tmp/safety_evidence/*.zip | tail -n1)
+          echo "Signing $ART with backend ${EVIDENCE_SIGN_BACKEND}"
+          python ops/evidence/sign_with_kms_or_vault.py "$ART"
+      - name: Upload signed evidence artifact
+        uses: actions/upload-artifact@v4
+        with:
+          name: signed-evidence
+          path: /tmp/safety_evidence
+
*** End Patch
*** Begin Patch
*** Add File:k8s/argo/configmaps/safety-evidence-configmap.yaml
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: safety-evidence-config
+  namespace: aegis-retriever
+data:
+  # Set these in your Argo environment or reference via Secrets for production
+  EVIDENCE_ROOT: "/tmp/safety_evidence"
+  PROVER_LOG_DIR: "/tmp/verifier_logs"
+  PROVER_SUMMARY_OUT: "/tmp/prover_summary.json"
+  EVIDENCE_SIGN_BACKEND: "stub" # change to "aws" or "vault" in production (use Secrets)
+
*** End Patch
*** Begin Patch
*** Add File:docs/ci_kms_vault_setup.md
+CI Secrets & KMS/Vault Setup — Quick Guide
+-----------------------------------------
+
+Goal: Wire evidence signing into CI with one of three backends:
+ - AWS KMS (recommended on AWS)
+ - HashiCorp Vault Transit
+ - PEM private key (developer / fallback)
+
+GitHub Secrets (recommended names)
+ - EVIDENCE_SIGN_BACKEND: "aws" | "vault" | "pem" | "stub"
+ - For AWS:
+   - AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION
+   - AWS_KMS_KEY_ID (ARN or key id)
+ - For Vault:
+   - VAULT_ADDR, VAULT_TOKEN, VAULT_TRANSIT_KEY
+ - For PEM:
+   - EVIDENCE_PRIVATE_KEY (store key in repo secret; write to file in CI runner step)
+
+IAM (AWS KMS) minimal policy for CI role/user (attach to runner's role or CI user):
+{
+  "Version": "2012-10-17",
+  "Statement": [
+    {
+      "Effect": "Allow",
+      "Action": [
+        "kms:Sign",
+        "kms:GetPublicKey",
+        "kms:DescribeKey"
+      ],
+      "Resource": "arn:aws:kms:REGION:ACCOUNT_ID:key/YOUR_KEY_ID"
+    }
+  ]
+}
+
+Vault (transit) minimal setup
+ - Enable transit: vault secrets enable transit
+ - Create key: vault write -f transit/keys/evidence-sign
+ - Create a CI token with permission to call transit/sign on the key
+ - In CI set VAULT_ADDR and VAULT_TOKEN
+
+CI runner considerations
+ - For AWS KMS: ensure runner has network access to AWS KMS (VPC endpoints recommended)
+ - For Vault: runner must reach Vault endpoint (use TLS, mTLS as appropriate)
+ - Use ephemeral runner service accounts or GitHub OIDC to reduce long-lived secrets where possible
+
+Verification in audits
+ - Publish public key (AWS get_public_key or exported PEM) alongside evidence bundles for auditors.
+ - Include key ID and signing algorithm in evidence metadata.
+
*** End Patch
*** End Patch
