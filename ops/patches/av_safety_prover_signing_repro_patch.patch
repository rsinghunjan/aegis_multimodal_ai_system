*** Begin Patch
*** Add File:ops/formal/smt_examples/braking_distance_bound.smt2
+; SMT-LIB stub: braking distance bound
+; Prove: under given assumptions, stopping_dist <= 200 holds (i.e., negation is unsat)
+(set-logic QF_NRA)
+(declare-fun speed () Real)
+(declare-fun reaction_time () Real)
+(declare-fun brake_distance () Real)
+(declare-fun stopping_dist () Real)
+
+; domain assumptions
+(assert (<= 0 speed))
+(assert (<= 0 reaction_time))
+(assert (<= reaction_time 2))            ; reaction time <= 2s
+(assert (<= 0 brake_distance))
+(assert (<= brake_distance 80))         ; brake_distance <= 80 (vehicle / brake performance bound)
+(assert (= stopping_dist (+ (* speed reaction_time) brake_distance)))
+(assert (<= speed 60))                  ; speed in km/h (toy units)
+
+; negation of property: stopping_dist > 200
+(assert (> stopping_dist 200))
+
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_examples/reaction_time_bound.smt2
+; SMT-LIB stub: reaction time invariant
+; Prove: reaction_time <= 2 under sensor/driver latency assumptions
+(set-logic QF_NRA)
+(declare-fun sensor_latency () Real)
+(declare-fun comm_latency () Real)
+(declare-fun processing_delay () Real)
+(declare-fun reaction_time () Real)
+
+; assumptions: components are non-negative and bounded
+(assert (<= 0 sensor_latency))
+(assert (<= sensor_latency 0.5))
+(assert (<= 0 comm_latency))
+(assert (<= comm_latency 0.3))
+(assert (<= 0 processing_delay))
+(assert (<= processing_delay 1.2))
+(assert (= reaction_time (+ sensor_latency comm_latency processing_delay)))
+
+; negation: reaction_time > 2 should be unsat
+(assert (> reaction_time 2))
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/smt_examples/lateral_deviation_bound.smt2
+; SMT-LIB stub: lateral deviation bound (toy)
+; Prove: lateral_deviation <= 1.5 (meters) given steering and curvature constraints
+(set-logic QF_NRA)
+(declare-fun curvature () Real)
+(declare-fun speed () Real)
+(declare-fun steering_error () Real)
+(declare-fun lateral_deviation () Real)
+
+; assumptions
+(assert (<= 0 curvature))
+(assert (<= curvature 0.02))      ; max curvature
+(assert (<= 0 speed))
+(assert (<= speed 30))            ; m/s or toy units
+(assert (<= (abs steering_error) 0.2))
+
+; simple model: lateral_deviation approximated by curvature * speed * steering_error (toy)
+(assert (= lateral_deviation (* curvature speed (abs steering_error))))
+
+; bound: lateral_deviation <= 1.5
+; negation to check unsat
+(assert (> lateral_deviation 1.5))
+(check-sat)
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/invariant_registry.json
+{
+  "braking_distance_bound": {
+    "id": "braking_distance_bound",
+    "description": "Stopping distance upper bound for speed <= 60 with brake_distance <= 80 and reaction_time <= 2",
+    "smt": "ops/formal/smt_examples/braking_distance_bound.smt2",
+    "tactic": "interval"
+  },
+  "reaction_time_bound": {
+    "id": "reaction_time_bound",
+    "description": "Reaction time is bounded by sum of sensor, comms and processing delays",
+    "smt": "ops/formal/smt_examples/reaction_time_bound.smt2",
+    "tactic": "interval"
+  },
+  "lateral_deviation_bound": {
+    "id": "lateral_deviation_bound",
+    "description": "Lateral deviation stays under threshold for bounded curvature/speed/steering error",
+    "smt": "ops/formal/smt_examples/lateral_deviation_bound.smt2",
+    "tactic": "interval"
+  }
+}
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/deploy_sample_invariants.py
+#!/usr/bin/env python3
+"""
+Copy sample SMT examples into the active SMT directory used by the prover (INVARIANT_SMT_DIR).
+Use this to "wire" example invariants into the prover pipeline for testing/demos.
+"""
+import os
+import shutil
+from glob import glob
+
+SRC_DIR = os.path.dirname(__file__) + "/smt_examples"
+DEST = os.environ.get("INVARIANT_SMT_DIR", "/tmp/invariant_smt")
+
+def deploy():
+    os.makedirs(DEST, exist_ok=True)
+    for fn in glob(os.path.join(SRC_DIR, "*.smt2")):
+        shutil.copy(fn, DEST)
+        print("Copied", fn, "->", DEST)
+
+if __name__ == "__main__":
+    deploy()
+
*** End Patch
*** Begin Patch
*** Add File:docs/runbooks/signing_runbook.md
+Signing runbook: evidence signing (AWS KMS / Vault / PEM)
+--------------------------------------------------------
+
+Purpose
+ - Describe how to productionize evidence signing so evidence bundles are cryptographically signed with either:
+   - AWS KMS asymmetric keys (recommended on AWS)
+   - HashiCorp Vault Transit keys
+   - PEM private key (least preferred)
+
+Overview
+ - The repository includes: ops/evidence/sign_evidence.py (PEM or stub), ops/evidence/sign_with_kms_or_vault.py (AWS KMS & Vault)
+ - Evidence packaging (ops/evidence/evidence_packager.py) can call sign_evidence.py; for KMS/Vault use sign_with_kms_or_vault.py explicitly in CI.
+
+AWS KMS (recommended)
+ - Create an asymmetric KMS key in AWS (RSA_2048 or ECC_SECG_P256K1 depending on your verifier).
+   - Use "Sign" key spec with RSASSA_PSS_SHA_256 or ECDSA_SHA_256.
+ - Grant CI role permission: kms:Sign, kms:GetPublicKey, kms:DescribeKey
+ - In CI:
+   - Set AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION)
+   - Set EVIDENCE_SIGN_BACKEND=aws and AWS_KMS_KEY_ID=arn:aws:kms:...
+ - Use: python ops/evidence/sign_with_kms_or_vault.py /path/to/artifact.zip
+
+HashiCorp Vault (transit)
+ - Enable transit secrets engine on Vault.
+ - Create a named key: vault write -f transit/keys/evidence-sign
+ - Grant CI Vault token with permission to use transit/sign.
+ - Set EVIDENCE_SIGN_BACKEND=vault, VAULT_ADDR, VAULT_TOKEN, VAULT_TRANSIT_KEY=evidence-sign
+ - Use: python ops/evidence/sign_with_kms_or_vault.py /path/to/artifact.zip
+
+PEM (developer/local)
+ - Store PEM private key on the runner (securely).
+ - Set EVIDENCE_SIGN=true and EVIDENCE_PRIVATE_KEY=/path/to/key.pem
+ - This is least secure; use only for dev/test.
+
+CI Integration example (GitHub Actions)
+ - Add a job step after evidence packaging:
+   - name: Sign Evidence (KMS)
+     env:
+       EVIDENCE_SIGN_BACKEND: aws
+       AWS_KMS_KEY_ID: ${{ secrets.AWS_KMS_KEY_ID }}
+       AWS_REGION: us-west-2
+     run: |
+       python ops/evidence/sign_with_kms_or_vault.py /tmp/safety_evidence/toy-model_evidence_*.zip
+
+Operational notes
+ - Always publish the public key or verification endpoint with the release evidence so auditors can verify signatures.
+ - Rotate keys using KMS/Vault processes and keep key IDs in your certificate metadata.
+ - Ensure the signing step runs in an isolated, auditable CI environment with restricted access.
+
*** End Patch
*** Begin Patch
*** Add File:ops/evidence/sign_with_kms_or_vault.py
+#!/usr/bin/env python3
+"""
+Sign an artifact using AWS KMS or HashiCorp Vault Transit or fallback to PEM/stub.
+ - Usage: python ops/evidence/sign_with_kms_or_vault.py /path/to/artifact
+ - Config via env:
+    EVIDENCE_SIGN_BACKEND: aws | vault | pem | stub
+    (aws) AWS_KMS_KEY_ID, AWS_REGION (and AWS creds in env)
+    (vault) VAULT_ADDR, VAULT_TOKEN, VAULT_TRANSIT_KEY
+    (pem) EVIDENCE_PRIVATE_KEY path
+ - Writes <artifact>.sig (base64) and a public-key metadata file if available.
+"""
+import os
+import sys
+import base64
+from datetime import datetime
+
+BACKEND = os.environ.get("EVIDENCE_SIGN_BACKEND", "stub")
+
+def sign_with_aws_kms(path):
+    import boto3, hashlib
+    key_id = os.environ.get("AWS_KMS_KEY_ID")
+    region = os.environ.get("AWS_REGION")
+    if not key_id:
+        raise RuntimeError("AWS_KMS_KEY_ID not set")
+    client = boto3.client("kms", region_name=region)
+    with open(path, "rb") as f:
+        data = f.read()
+    digest = hashlib.sha256(data).digest()
+    # KMS Sign uses Message or MessageDigest depending on key type. Use MessageDigest for explicit SHA-256.
+    resp = client.sign(KeyId=key_id, Message=digest, MessageType="DIGEST", SigningAlgorithm="RSASSA_PSS_SHA_256")
+    sig = resp["Signature"]
+    out = path + ".sig"
+    with open(out, "wb") as fh:
+        fh.write(sig)
+    # get public key for verifier
+    pub = client.get_public_key(KeyId=key_id)
+    pub_out = path + ".pub.pem"
+    with open(pub_out, "wb") as fh:
+        fh.write(pub["PublicKey"])
+    print("Wrote signature", out, "and public key", pub_out)
+    return out, pub_out
+
+def sign_with_vault(path):
+    import requests, hashlib, json
+    addr = os.environ.get("VAULT_ADDR")
+    token = os.environ.get("VAULT_TOKEN")
+    key = os.environ.get("VAULT_TRANSIT_KEY")
+    if not addr or not token or not key:
+        raise RuntimeError("Vault config missing")
+    with open(path, "rb") as f:
+        data = f.read()
+    digest = hashlib.sha256(data).hexdigest()
+    url = addr.rstrip("/") + f"/v1/transit/sign/{key}"
+    payload = {"input": base64.b64encode(data).decode(), "prehashed": False}
+    headers = {"X-Vault-Token": token}
+    r = requests.post(url, json=payload, headers=headers, timeout=30)
+    r.raise_for_status()
+    j = r.json()
+    sig_b64 = j["data"]["signature"]
+    out = path + ".sig"
+    with open(out, "w") as fh:
+        fh.write(sig_b64)
+    print("Wrote vault signature", out)
+    return out, None
+
+def sign_with_pem(path):
+    # delegate to existing sign_evidence.py if available
+    try:
+        import subprocess
+        subprocess.check_call(["python", "ops/evidence/sign_evidence.py", path])
+        return path + ".sig", None
+    except Exception:
+        # fallback stub
+        out = path + ".sig"
+        with open(out, "w") as fh:
+            fh.write(f"stub-signed:{os.environ.get('USER','ci')}@{datetime.utcnow().isoformat()}\n")
+        return out, None
+
+def stub_sign(path):
+    out = path + ".sig"
+    with open(out, "w") as fh:
+        fh.write(f"stub-signed:{os.environ.get('USER','ci')}@{datetime.utcnow().isoformat()}\n")
+    print("Wrote stub signature", out)
+    return out, None
+
+def main():
+    if len(sys.argv) < 2:
+        print("usage: sign_with_kms_or_vault.py <artifact>")
+        sys.exit(2)
+    path = sys.argv[1]
+    if BACKEND == "aws":
+        sig, pub = sign_with_aws_kms(path)
+    elif BACKEND == "vault":
+        sig, pub = sign_with_vault(path)
+    elif BACKEND == "pem":
+        sig, pub = sign_with_pem(path)
+    else:
+        sig, pub = stub_sign(path)
+    print("signature:", sig, "pub:", pub)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:docs/checklists/reproducible_sil_hil.md
+Reproducible SIL/HIL checklist
+------------------------------
+Purpose: ensure SIL and HIL validation runs are reproducible and suitable for evidence bundles.
+
+Before running CI:
+- Pin container images: manifests (Argo, k8s jobs) must not reference "latest". Use full image:tag or digest.
+- Pin software deps: builder image and runtime images should be immutable and recorded in provenance.json.
+- Seeds and randomness: test suites and simulation runners must accept a --seed argument and write it to logs.
+- Artifact hashing: tests should produce deterministic artifact files and the pipeline must compute SHA256 of key outputs.
+- Deterministic hardware: for HIL, record firmware versions, ECU identifiers and hardware clocks; control or record nondeterministic inputs.
+
+CI checks to enforce:
+1) Image pin check: fail CI if manifest files (k8s/, charts/, Argo templates) contain 'image: .*:latest' or lack tag.
+2) Seed presence: fail if tests do not set or expose a seed value (search for seed in test invocation).
+3) Double-run determinism: run SIL twice with same seed and compare output logs/artifact hashes byte-for-byte.
+4) Artifact registry: store evidence bundle and computed SHA256 in artifact store; include signature step.
+
+Runtime/HIL notes:
+- For HIL, schedule runs in a quiescent environment and capture sensor replay inputs; use replay-recorded inputs to guarantee reproducibility.
+- If true hardware nondeterminism exists (thermal, clocks), document expected tolerances and include them in evidence.
+
*** End Patch
*** Begin Patch
*** Add File:ops/ci/check_reproducibility.py
+#!/usr/bin/env python3
+"""
+CI helper to enforce reproducible SIL/HIL runs.
+ - 1) Checks manifests for pinned images (no :latest and tags present)
+ - 2) Runs SIL twice with the same seed and compares logs/artifacts
+ - 3) Emits a reproducibility report JSON
+
+Usage:
+  python ops/ci/check_reproducibility.py --model-dir models/toy-model --tests models/toy-model/tests --seed 42 --out /tmp/repro_report.json
+"""
+import os
+import sys
+import json
+import hashlib
+import subprocess
+from glob import glob
+from datetime import datetime
+
+from ops.simulation.run_sil import run as run_sil
+
+def sha256_file(path):
+    import hashlib
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        for chunk in iter(lambda: f.read(4096), b""):
+            h.update(chunk)
+    return h.hexdigest()
+
+def check_images_pinned(paths):
+    issues = []
+    for p in paths:
+        if not os.path.exists(p):
+            continue
+        with open(p) as fh:
+            txt = fh.read()
+            # naive image: occurrences
+            for line in txt.splitlines():
+                if "image:" in line:
+                    if ":" not in line.split("image:")[-1]:
+                        issues.append({"file": p, "line": line.strip(), "reason": "missing_tag"})
+                    if ":latest" in line:
+                        issues.append({"file": p, "line": line.strip(), "reason": "latest_tag"})
+    return issues
+
+def run_sil_and_capture(model_dir, tests, seed, outdir):
+    os.makedirs(outdir, exist_ok=True)
+    # Set deterministic env for run_sil if it reads env var
+    env = os.environ.copy()
+    env["SIL_SEED"] = str(seed)
+    # run_sil writes logs under /tmp/sil_logs by default; to isolate, set TMP dir
+    prev_tmp = "/tmp/sil_logs"
+    out_path = os.path.join(outdir, f"sil_{seed}_{int(datetime.utcnow().timestamp())}.json")
+    # We call run_sil but redirect its output to a file - run_sil already writes a file and prints path
+    run_sil(model_dir, tests)
+    # find latest file under /tmp/sil_logs matching model_dir name
+    import glob, time
+    candidates = glob.glob(f"/tmp/sil_logs/sil_{os.path.basename(model_dir)}_*.json")
+    if not candidates:
+        return None
+    latest = sorted(candidates)[-1]
+    # copy to out_path
+    import shutil
+    shutil.copy(latest, out_path)
+    return out_path
+
+def main():
+    import argparse
+    p = argparse.ArgumentParser()
+    p.add_argument("--model-dir", required=True)
+    p.add_argument("--tests", required=True)
+    p.add_argument("--seed", type=int, default=42)
+    p.add_argument("--out", default="/tmp/repro_report.json")
+    args = p.parse_args()
+
+    report = {"ts": datetime.utcnow().isoformat()+"Z", "image_checks": [], "runs": [], "deterministic": False}
+    # 1) check manifests under k8s/, charts/, k8s/argo/
+    paths = ["k8s", "charts", "k8s/argo", ".github/workflows"]
+    manifest_files = []
+    for pth in paths:
+        for fn in glob(os.path.join(pth, "**/*.*"), recursive=True):
+            if fn.endswith((".yaml", ".yml")):
+                manifest_files.append(fn)
+    report["image_checks"] = check_images_pinned(manifest_files)[:50]
+
+    # 2) run SIL twice and compare
+    out1 = run_sil_and_capture(args.model_dir, args.tests, args.seed, "/tmp/repro_runs")
+    out2 = run_sil_and_capture(args.model_dir, args.tests, args.seed, "/tmp/repro_runs")
+    if not out1 or not out2:
+        report["error"] = "sil_runs_missing"
+    else:
+        h1 = sha256_file(out1)
+        h2 = sha256_file(out2)
+        report["runs"] = [{"path": out1, "sha256": h1}, {"path": out2, "sha256": h2}]
+        report["deterministic"] = (h1 == h2)
+    with open(args.out, "w") as fh:
+        json.dump(report, fh, indent=2)
+    print("Wrote reproducibility report to", args.out)
+    if not report["deterministic"] or report["image_checks"]:
+        sys.exit(2)
+    sys.exit(0)
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/reproducibility_check.yml
+name: Reproducibility SIL/HIL Check
+on:
+  pull_request:
+    branches:
+      - main
+  workflow_dispatch:
+
+jobs:
+  reproducibility:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.11'
+      - name: Install deps
+        run: |
+          python -m pip install --upgrade pip
+          pip install requests
+      - name: Run reproducibility checks
+        run: |
+          python ops/ci/check_reproducibility.py --model-dir models/toy-model --tests models/toy-model/tests --seed 42 --out /tmp/repro_report.json || true
+      - name: Upload reproducibility report
+        uses: actions/upload-artifact@v4
+        with:
+          name: reproducibility-report
+          path: /tmp/repro_report.json
+
*** End Patch
*** End Patch
