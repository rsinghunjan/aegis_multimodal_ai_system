*** Begin Patch
*** Add File:ops/math/calc_worker.py
+#!/usr/bin/env python3
+"""
+Calculator/CAS worker: run symbolic and high-precision numeric computations using SymPy/mpmath.
+This script is intended to be invoked as a short-lived subprocess with a JSON payload on stdin
+to reduce the attack surface of directly importing SymPy into long-lived services.
+
+Input JSON (stdin):
+{
+  "mode": "eval" | "sympy" | "solve" | "derivative" | "integrate",
+  "expr": "<expression or equation>",
+  "precision": 50   # optional decimal digits for numeric evaluation
+}
+
+Output JSON (stdout):
+{
+  "ok": true|false,
+  "result": "<string>",
+  "repr": "<structured JSON if applicable>",
+  "error": "<error message if any>"
+}
+"""
+import sys
+import json
+import traceback
+
+def main():
+    raw = sys.stdin.read()
+    try:
+        req = json.loads(raw)
+    except Exception as e:
+        print(json.dumps({"ok": False, "error": f"invalid_json: {e}"}))
+        return
+
+    mode = req.get("mode", "eval")
+    expr = req.get("expr", "")
+    precision = int(req.get("precision", 50))
+
+    try:
+        # Import inside function to reduce long-lived attack surface in services
+        import sympy as sp
+        import mpmath as mp
+        mp.mp.dps = precision
+
+        # safe parsing
+        if mode == "eval":
+            # numeric evaluation using mpmath via sympy N
+            s = sp.sympify(expr, evaluate=True)
+            val = sp.N(s, n=precision)
+            out = {"ok": True, "result": str(val), "repr": {"type": "number"}}
+            print(json.dumps(out))
+            return
+        elif mode == "sympy":
+            s = sp.sympify(expr, evaluate=False)
+            simplified = sp.simplify(s)
+            out = {"ok": True, "result": str(simplified), "repr": {"type": "sympy", "simplified": str(simplified)}}
+            print(json.dumps(out))
+            return
+        elif mode == "solve":
+            # expr expected like "x**2 - 2"
+            s = sp.sympify(expr, evaluate=False)
+            vars = list(s.free_symbols)
+            if not vars:
+                # if equation provided as 'x+1=0' try parsing
+                if "=" in expr:
+                    lhs, rhs = expr.split("=",1)
+                    s_eq = sp.Eq(sp.sympify(lhs), sp.sympify(rhs))
+                    sols = sp.solve(s_eq)
+                else:
+                    sols = []
+            else:
+                sols = sp.solve(s, vars)
+            out = {"ok": True, "result": str(sols), "repr": {"solutions": [str(x) for x in sols]}}
+            print(json.dumps(out))
+            return
+        elif mode == "derivative":
+            # expr like "x**3", variable optional 'var' field
+            varname = req.get("var", None)
+            s = sp.sympify(expr, evaluate=False)
+            vars = list(s.free_symbols)
+            if varname:
+                v = sp.Symbol(varname)
+            elif vars:
+                v = vars[0]
+            else:
+                v = sp.Symbol('x')
+            der = sp.diff(s, v)
+            out = {"ok": True, "result": str(der), "repr": {"derivative": str(der)}}
+            print(json.dumps(out))
+            return
+        elif mode == "integrate":
+            varname = req.get("var", None)
+            s = sp.sympify(expr, evaluate=False)
+            vars = list(s.free_symbols)
+            if varname:
+                v = sp.Symbol(varname)
+            elif vars:
+                v = vars[0]
+            else:
+                v = sp.Symbol('x')
+            integ = sp.integrate(s, v)
+            out = {"ok": True, "result": str(integ), "repr": {"integral": str(integ)}}
+            print(json.dumps(out))
+            return
+        else:
+            print(json.dumps({"ok": False, "error": "unsupported_mode"}))
+            return
+    except Exception as e:
+        tb = traceback.format_exc()
+        print(json.dumps({"ok": False, "error": str(e), "trace": tb}))
+
+if __name__ == "__main__":
+    main()
+
*** End Patch
*** Begin Patch
*** Add File:ops/math/calc_service.py
+#!/usr/bin/env python3
+"""
+Calculator/CAS FastAPI service that invokes calc_worker.py via subprocess for sandboxing.
+Provides endpoints:
+ - POST /v1/compute {mode, expr, precision}
+Example modes: eval, sympy, solve, derivative, integrate
+"""
+from fastapi import FastAPI, HTTPException
+from pydantic import BaseModel
+import subprocess
+import json
+import os
+import shlex
+import uuid
+from typing import Optional
+
+WORKER = os.path.join(os.path.dirname(__file__), "calc_worker.py")
+app = FastAPI(title="Aegis Calculator Service")
+
+class CalcRequest(BaseModel):
+    mode: str
+    expr: str
+    precision: Optional[int] = 50
+
+@app.post("/v1/compute")
+def compute(req: CalcRequest):
+    payload = {"mode": req.mode, "expr": req.expr, "precision": int(req.precision or 50)}
+    try:
+        proc = subprocess.Popen([ "python", WORKER ],
+                                stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
+                                text=True)
+        stdout, stderr = proc.communicate(input=json.dumps(payload), timeout=15)
+    except subprocess.TimeoutExpired:
+        proc.kill()
+        raise HTTPException(status_code=504, detail="calc_worker_timeout")
+    except Exception as e:
+        raise HTTPException(status_code=500, detail=f"spawn_error: {e}")
+    if stdout:
+        try:
+            data = json.loads(stdout)
+            return data
+        except Exception:
+            raise HTTPException(status_code=500, detail=f"invalid_worker_output: {stdout[:500]}")
+    else:
+        raise HTTPException(status_code=500, detail=f"worker_no_output: {stderr[:500]}")
+
*** End Patch
*** Begin Patch
*** Add File:ops/automation/calc_tool_adapter.py
+#!/usr/bin/env python3
+"""
+Helper adapter used by agent/tool runners to call the calculator service (local HTTP) or fallback to worker.
+Provides compute(mode, expr, precision) -> dict
+"""
+import os
+import requests
+import json
+
+CALC_URL = os.environ.get("CALC_URL", "http://localhost:8100/v1/compute")
+
+def compute(mode, expr, precision=50):
+    try:
+        r = requests.post(CALC_URL, json={"mode": mode, "expr": expr, "precision": precision}, timeout=10)
+        r.raise_for_status()
+        return r.json()
+    except Exception as e:
+        # fallback: call worker directly
+        try:
+            import subprocess, json, os
+            worker = os.path.join(os.path.dirname(__file__), "..", "math", "calc_worker.py")
+            proc = subprocess.Popen(["python", worker], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+            payload = json.dumps({"mode": mode, "expr": expr, "precision": precision})
+            out, err = proc.communicate(input=payload, timeout=15)
+            return json.loads(out)
+        except Exception as e2:
+            return {"ok": False, "error": f"both_remote_and_local_failed: {e} / {e2}"}
+
*** End Patch
*** Begin Patch
*** Add File:ops/verifier/verifier_with_cas.py
+#!/usr/bin/env python3
+"""
+Enhanced verifier that combines NLI entailment checks and deterministic CAS checks for math claims.
+ - Uses ops/verifier/nli_verifier.verify_claim_against_snippets for entailment
+ - Uses calc_tool_adapter to evaluate numeric/symbolic claims when the claim looks like math
+"""
+import re
+from ops.verifier.nli_verifier import verify_claim_against_snippets
+from ops.automation.calc_tool_adapter import compute as calc_compute
+
+def looks_like_math(s: str) -> bool:
+    # heuristic: contains digits, operators, math words
+    if re.search(r"[0-9\+\-\*\/\^=]", s):
+        return True
+    if any(w in s.lower() for w in ("integrate","differentiate","derivative","solve","limit","sum")):
+        return True
+    return False
+
+def verify_claim(claim: str, snippets: list, threshold=0.7) -> dict:
+    """
+    If claim appears mathematical, attempt deterministic check:
+      - For arithmetic expressions: evaluate claim via CAS and compare with snippet-derived evidence (if any)
+      - For algebraic statements: request simplify/solve from CAS
+    Otherwise fall back to NLI verifier over snippets.
+    Returns structure: {"ok":bool, "method": "cas"|"nli"|"mixed", "details": {...}}
+    """
+    if looks_like_math(claim):
+        # Try to compute claim deterministically
+        # For simple forms like "2+2=4", split on '='
+        if "=" in claim:
+            lhs, rhs = claim.split("=",1)
+            lhs_res = calc_compute("eval", lhs.strip())
+            rhs_res = calc_compute("eval", rhs.strip())
+            ok = False
+            details = {"lhs": lhs_res, "rhs": rhs_res}
+            if lhs_res.get("ok") and rhs_res.get("ok"):
+                try:
+                    ok = float(lhs_res["result"]) == float(rhs_res["result"])
+                except Exception:
+                    ok = str(lhs_res["result"]).strip() == str(rhs_res["result"]).strip()
+            # However also run NLI to see if snippets support claim
+            nli = verify_claim_against_snippets(claim, snippets, threshold=threshold)
+            return {"ok": ok and nli["ok"], "method": "mixed", "details": {"cas": details, "nli": nli}}
+        else:
+            # Try to evaluate expression
+            eval_res = calc_compute("eval", claim)
+            if eval_res.get("ok"):
+                # run NLI on claim as hypothesis
+                nli = verify_claim_against_snippets(claim, snippets, threshold=threshold)
+                return {"ok": nli["ok"], "method": "cas", "details": {"cas": eval_res, "nli": nli}}
+            else:
+                # fallback to NLI
+                nli = verify_claim_against_snippets(claim, snippets, threshold=threshold)
+                return {"ok": nli["ok"], "method": "nli", "details": {"nli": nli}}
+    else:
+        nli = verify_claim_against_snippets(claim, snippets, threshold=threshold)
+        return {"ok": nli["ok"], "method": "nli", "details": {"nli": nli}}
+
*** End Patch
*** Begin Patch
*** Add File:ops/edge/numeric_fidelity_test.py
+#!/usr/bin/env python3
+"""
+On-device numeric fidelity test harness.
+ - Runs representative numeric kernels (matrix multiply, convolution-like ops) in FP32 baseline and in lower-precision simulated mode (FP16).
+ - Compares results and reports relative/absolute errors and whether they exceed thresholds.
+ - Intended to be run on actual target devices or CI emulators to validate quantized model numeric stability.
+"""
+import numpy as np
+import json
+from datetime import datetime
+OUT = "/tmp/numeric_fidelity_report.json"
+
+def matmul_test(n=512):
+    a = np.random.randn(n, n).astype(np.float32)
+    b = np.random.randn(n, n).astype(np.float32)
+    ref = a.dot(b)
+    # simulate lower precision by casting to float16 and computing in float32 afterward
+    a_q = a.astype(np.float16).astype(np.float32)
+    b_q = b.astype(np.float16).astype(np.float32)
+    qres = a_q.dot(b_q)
+    diff = np.linalg.norm(ref - qres) / (np.linalg.norm(ref) + 1e-12)
+    return {"rel_error": float(diff)}
+
+def run_all():
+    results = {"ts": datetime.utcnow().isoformat()+"Z", "tests": {}}
+    for n in (128, 256, 512):
+        results["tests"][f"matmul_{n}"] = matmul_test(n)
+    with open(OUT, "w") as fh:
+        json.dump(results, fh, indent=2)
+    print("Wrote", OUT)
+    return OUT
+
+if __name__=="__main__":
+    run_all()
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/continuous_invariants_templates.json
+{
+  "max_speed": {"type":"numeric_limit", "variable":"speed", "op":"le", "value":5.0, "description":"vehicle speed must be <= 5m/s"},
+  "max_lateral_accel": {"type":"numeric_limit", "variable":"lateral_accel", "op":"le", "value":4.0, "description":"lateral accel bounds"},
+  "min_stopping_margin": {"type":"stopping_distance", "params":{"min_margin_m":0.5}, "description":"stopping margin vs obstacle"},
+  "planner_timeliness_ms": {"type":"planner_budget", "max_ms": 50, "description":"planner response time"},
+  "energy_budget": {"type":"numeric_limit", "variable":"energy_consumption","op":"le","value":100.0}
+}
+
*** End Patch
*** Begin Patch
*** Add File:ops/formal/continuous_fuzz.py
+#!/usr/bin/env python3
+"""
+Fuzzer for continuous/dynamical invariants:
+ - Mutates trajectory traces (position, speed, accel) to seek invariant violations
+ - Uses existing prove_invariants(prover_state, invariants) integration (if available) to check
+ - Writes counterexamples to /tmp/continuous_fuzz_counterexamples.jsonl
+"""
+import os
+import json
+import random
+from datetime import datetime
+from ops.formal.formal_prover_integration import prove_invariants
+
+OUT = "/tmp/continuous_fuzz_counterexamples.jsonl"
+INV_FILE = os.environ.get("CONT_INVARIANTS", "ops/formal/continuous_invariants_templates.json")
+
+def mutate_traj(base):
+    # base: dict with fields speed, lateral_accel, position, planner_ms, energy_consumption
+    m = dict(base)
+    # random jitter and bursts
+    for k in ["speed", "lateral_accel", "planner_ms", "energy_consumption"]:
+        if k in m:
+            perturb = (random.random()*2-1) * (abs(m.get(k,1.0)) + 1.0)
+            m[k] = max(0, m.get(k,0) + perturb)
+    # random sudden obstacle
+    m["obstacle_dist"] = random.uniform(0, 200)
+    m["position"] = [random.uniform(-100,100), random.uniform(-100,100)]
+    return m
+
+def run(iterations=500):
+    base = {"speed":1.0,"lateral_accel":0.5,"planner_ms":10,"energy_consumption":10.0,"position":[0,0],"obstacle_dist":100.0}
+    inv = json.load(open(INV_FILE))
+    with open(OUT,"w") as fh:
+        for i in range(iterations):
+            s = mutate_traj(base)
+            res = prove_invariants(s, inv)
+            if not res.get("ok"):
+                rec = {"ts": datetime.utcnow().isoformat()+"Z", "mutant": s, "result": res}
+                fh.write(json.dumps(rec) + "\n")
+    print("Fuzz complete, results:", OUT)
+
+if __name__=="__main__":
+    run()
+
*** End Patch
*** Begin Patch
*** Add File:ops/math/bench_datasets/gsm8k_sample.jsonl
+{"question":"If you have 3 apples and buy 4 more, how many apples do you have?","answer":"7"}
+{"question":"A train travels 60 miles in 1.5 hours. What is its average speed in miles per hour?","answer":"40"}
+{"question":"Compute 12 * (5 + 3).","answer":"96"}
+
*** End Patch
*** Begin Patch
*** Add File:ops/ci/math_bench_runner.py
+#!/usr/bin/env python3
+"""
+Run small math benchmark (GSM8K sample) against configured LLM endpoint and verify using CAS service.
+ - Expects LLM_API env var pointing to model generation endpoint that returns JSON {"text": "<answer>"}
+ - Uses calc service via ops/automation/calc_tool_adapter.compute to verify numeric answers
+ - Writes /tmp/math_bench_results.json
+"""
+import os
+import json
+import requests
+from datetime import datetime
+from ops.automation.calc_tool_adapter import compute as calc_compute
+
+LLM_API = os.environ.get("LLM_API", "http://localhost:9000/generate")
+DATA = "ops/math/bench_datasets/gsm8k_sample.jsonl"
+OUT = "/tmp/math_bench_results.json"
+
+def call_llm(prompt):
+    try:
+        r = requests.post(LLM_API, json={"prompt": prompt, "max_tokens": 64}, timeout=20)
+        r.raise_for_status()
+        return r.json().get("text","").strip()
+    except Exception as e:
+        return ""
+
+def run():
+    results = {"ts": datetime.utcnow().isoformat()+"Z", "cases": []}
+    for line in open(DATA):
+        item = json.loads(line)
+        q = item["question"]
+        gold = item.get("answer")
+        prompt = f"Solve: {q}\nGive final numeric answer only."
+        llm_ans = call_llm(prompt)
+        # try to evaluate LLM answer (strip text)
+        # If LLM returns words, attempt to use CAS to compute expected result as canonical numeric
+        ok = False
+        details = {"llm_ans": llm_ans, "gold": gold}
+        # try evaluating llm answer as expression
+        try:
+            cas = calc_compute("eval", llm_ans)
+            if cas.get("ok"):
+                # compare numeric strings (loose)
+                got = str(cas["result"]).strip()
+                ok = (got == str(gold).strip())
+                details["llm_eval"] = cas
+        except Exception:
+            pass
+        # fallback: evaluate gold via CAS as well
+        if not ok and gold:
+            gold_eval = calc_compute("eval", str(gold))
+            details["gold_eval"] = gold_eval
+            if "llm_eval" in details and details["llm_eval"].get("ok") and gold_eval.get("ok"):
+                try:
+                    ok = float(details["llm_eval"]["result"]) == float(gold_eval["result"])
+                except Exception:
+                    ok = str(details["llm_eval"]["result"]) == str(gold_eval["result"])
+        results["cases"].append({"question": q, "ok": ok, "details": details})
+    with open(OUT, "w") as fh:
+        json.dump(results, fh, indent=2)
+    print("Wrote", OUT)
+
+if __name__=="__main__":
+    run()
+
*** End Patch
*** Begin Patch
*** Add File:.github/workflows/math_bench.yml
+name: Math Bench (GSM8K sample) & Numeric Fidelity
+on:
+  workflow_dispatch:
+  pull_request:
+    types: [opened, synchronize]
+
+jobs:
+  math-bench:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Setup Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.11'
+      - name: Install deps for calculator worker
+        run: |
+          python -m pip install --upgrade pip
+          pip install sympy mpmath requests
+      - name: Run GSM8K sample benchmark
+        env:
+          LLM_API: ${{ secrets.LLM_API }}
+        run: |
+          python ops/ci/math_bench_runner.py
+      - name: Run numeric fidelity tests (host)
+        run: |
+          python ops/edge/numeric_fidelity_test.py
+      - name: Upload results
+        uses: actions/upload-artifact@v4
+        with:
+          name: math-bench-results
+          path: |
+            /tmp/math_bench_results.json
+            /tmp/numeric_fidelity_report.json
+
*** End Patch
*** End Patch
