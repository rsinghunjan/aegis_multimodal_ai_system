*** Begin Patch
*** Add File: scripts/deploy_milvus_certmanager.sh
+#!/usr/bin/env bash
+#
+# Turnkey deploy script to install cert-manager, deploy Milvus via Helm with
+# production values, create TLS certs and root auth secret, and verify the deployment.
+#
+# Usage:
+#   NAMESPACE=aegis \
+#   GKE_CLUSTER=... (optional) \
+#   MILVUS_VALUES_BASE64=<base64-encoded-values.yaml> \
+#   ./scripts/deploy_milvus_certmanager.sh
+#
+# Environment:
+# - MILVUS_VALUES_BASE64 (optional): base64 of a helm values file to override defaults (recommended for prod)
+# - NAMESPACE (default: aegis)
+# - KUBE_CONFIG_DATA (base64 kubeconfig) or have kubectl context configured locally
+#
+set -euo pipefail
+NAMESPACE="${NAMESPACE:-aegis}"
+MILVUS_VALUES_BASE64="${MILVUS_VALUES_BASE64:-}"
+KUBECONFIG_PATH="${KUBECONFIG_PATH:-/tmp/kubeconfig}"
+
+# If KUBE_CONFIG_DATA is provided, wire it up
+if [ -n "${KUBE_CONFIG_DATA:-}" ]; then
+  echo "Writing kubeconfig to ${KUBECONFIG_PATH}"
+  echo "$KUBE_CONFIG_DATA" | base64 --decode > "${KUBECONFIG_PATH}"
+  export KUBECONFIG="${KUBECONFIG_PATH}"
+fi
+
+echo "Ensure helm & kubectl are available"
+if ! command -v helm >/dev/null 2>&1; then
+  echo "helm not found in PATH" >&2
+  exit 2
+fi
+if ! command -v kubectl >/dev/null 2>&1; then
+  echo "kubectl not found in PATH" >&2
+  exit 2
+fi
+
+# Install cert-manager (if not present)
+if ! kubectl get ns cert-manager >/dev/null 2>&1; then
+  echo "Installing cert-manager..."
+  kubectl apply --validate=false -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.crds.yaml
+  kubectl create namespace cert-manager || true
+  helm repo add jetstack https://charts.jetstack.io
+  helm repo update
+  helm upgrade --install cert-manager jetstack/cert-manager \
+    --namespace cert-manager \
+    --set installCRDs=true \
+    --version v1.12.0 || true
+  echo "Waiting for cert-manager to be ready..."
+  kubectl -n cert-manager rollout status deploy/cert-manager  --timeout=3m || true
+fi
+
+# Create target namespace
+kubectl create namespace "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
+
+# Apply cert-manager ClusterIssuer (self-signed for internal)
+cat <<'YAML' | kubectl apply -f -
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: aegis-issuer
+spec:
+  selfSigned: {}
+YAML
+
+# Add milvus helm repo and update
+helm repo add milvus https://milvus-io.github.io/milvus-helm/
+helm repo update
+
+# If user provided values override, write a temp file
+if [ -n "$MILVUS_VALUES_BASE64" ]; then
+  echo "Using provided MILVUS_VALUES_BASE64"
+  echo "$MILVUS_VALUES_BASE64" | base64 --decode > /tmp/milvus-values.yaml
+  MILVUS_VALUES_FILE="/tmp/milvus-values.yaml"
+else
+  MILVUS_VALUES_FILE=""
+fi
+
+# Install/upgrade Milvus using Helm
+echo "Installing/upgrading Milvus in namespace ${NAMESPACE}..."
+if [ -n "$MILVUS_VALUES_FILE" ]; then
+  helm upgrade --install aegis-milvus milvus/milvus -n "${NAMESPACE}" -f "${MILVUS_VALUES_FILE}"
+else
+  helm upgrade --install aegis-milvus milvus/milvus -n "${NAMESPACE}"
+fi
+
+echo "Waiting for milvus pods to be ready (this may take a few minutes)..."
+kubectl -n "${NAMESPACE}" wait --for=condition=ready pods --all --timeout=10m || true
+
+# Create TLS certificate for internal service if not present (cert-manager will populate secret)
+if ! kubectl -n "${NAMESPACE}" get secret aegis-milvus-tls >/dev/null 2>&1; then
+  echo "Creating certificate resource for aegis-milvus..."
+  cat <<YAML | kubectl -n "${NAMESPACE}" apply -f -
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: aegis-milvus-cert
+spec:
+  secretName: aegis-milvus-tls
+  dnsNames:
+    - "aegis-milvus.${NAMESPACE}.svc"
+  issuerRef:
+    name: aegis-issuer
+](#)
î€€
